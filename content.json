{"meta":{"title":"weifo","subtitle":"选择你所爱的，爱你所选择的","description":"电音爱好者","author":"weifo","url":"https://weifo.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-11-11T15:42:38.854Z","updated":"2019-11-11T15:42:38.854Z","comments":false,"path":"/404.html","permalink":"https://weifo.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2020-03-12T14:22:55.725Z","updated":"2020-03-12T14:22:55.724Z","comments":false,"path":"about/index.html","permalink":"https://weifo.github.io/about/index.html","excerpt":"","text":"12345678910111213141516171819202122232425&#123; name: 'weifo', age: '22', sex: '男'， experience: '2018-01-01 至今', education: '本科', email: 'mwfherotic@163.com', github: 'https://github.com/weifo', blog: 'weifo.github.io', description: '踌躇满志又不知所措', character: '拖延症 好吃懒做', skills: [ ['html', 'css', 'Javascript','ES6', 'Node','python'], ['webpack'], ['git'], ['eslint'], ['React技术栈','bootstrap','vue'] ], devTools: [ ['Visual Studio Code', 'Webstorm', 'Sublime Text'], ['Chrome DevTools'] ]&#125; blog1hexo + github Pages"},{"title":"书单","date":"2019-11-09T17:46:22.311Z","updated":"2019-03-18T15:39:40.000Z","comments":false,"path":"books/index.html","permalink":"https://weifo.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-11-09T17:46:22.316Z","updated":"2019-03-18T15:39:40.000Z","comments":false,"path":"categories/index.html","permalink":"https://weifo.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-11-09T17:46:22.321Z","updated":"2019-03-18T15:39:40.000Z","comments":false,"path":"repository/index.html","permalink":"https://weifo.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-11-06T08:15:28.000Z","updated":"2019-03-18T15:39:40.000Z","comments":true,"path":"tags/index.html","permalink":"https://weifo.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"react-redux","slug":"react-redux","date":"2020-02-10T14:42:05.000Z","updated":"2020-03-15T13:18:27.842Z","comments":false,"path":"2020/02/10/react-redux/","link":"","permalink":"https://weifo.github.io/2020/02/10/react-redux/","excerpt":"ruduxredux 运行流程图： 简单概述：click -&gt; store.dispatch(action) -&gt; reduer -&gt; newState -&gt; viewUpdate react-readux 中 通过 connect 链接组件和 redux , this.props.dispatch() 调用 后面将会讲到… redux 依赖包也是十分的简洁先来个demo","text":"ruduxredux 运行流程图： 简单概述：click -&gt; store.dispatch(action) -&gt; reduer -&gt; newState -&gt; viewUpdate react-readux 中 通过 connect 链接组件和 redux , this.props.dispatch() 调用 后面将会讲到… redux 依赖包也是十分的简洁先来个demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const redux = require('redux')const createStore = redux.createStoreconst types = &#123; UPDATE_NAME: 'UPDATE_NAME'&#125;const defaultStore = &#123; user: 'tom'&#125;/** * reducer 纯函数 接收一个state,返回一个新的state * @param &#123;Object&#125; state * @param &#123;Object&#125; action [type] 必选参数 * @return newState * */function getUser(state = defaultStore, action) &#123; const &#123; type, payload &#125; = action let res = Object.assign(&#123;&#125;, defaultStore) switch (type) &#123; case types.UPDATE_NAME: res.user = payload.name break default: return res &#125; return res&#125;const store = createStore(getUser)/** * listener * */store.subscribe(() =&gt; &#123; console.log(store.getState())&#125;)/** * dispatch(action) action * */store.dispatch(&#123; type: types.UPDATE_NAME, payload: &#123; name: '大帅哥' &#125;&#125;)//@log &#123; name: '大帅哥' &#125; 用户发出 action 【store.dispatch(action)】 Store 自动调用 Reducer , 返回新的 state 【let nextState = getUser(previousState, action)】 State 一旦有变化，Store 就会调用监听函数 【store.subscribe(listener)】 运行过程如下： storeStore 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store常用方法： store.dispatch() ：分发 action 较为常用 store.subscribe() : state 发生变化后立即执行 store.getState() : 获取 store 中存着的 state createStorecreateStore 如其名，创建 store 下面是该方法的部分源码： 12345678910111213141516171819202122232425262728/** * @param &#123;Function&#125; reducer 函数 * @param &#123;any&#125; [preloadedState] The initial state * @param &#123;Function&#125; [enhancer] The store enhancer * @returns &#123;Store&#125; * */export default function createStore(reducer, preloadedState, enhancer) &#123; if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState preloadedState = undefined &#125; if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; return enhancer(createStore)(reducer, preloadedState) &#125; // ... return &#123; dispatch, // 分发 action subscribe, // 监听器 getState, // 获取 store 的 state 值 replaceReducer, [$$observable]: observable // 供Redux内部使用 &#125;&#125; preloadedState: 初始化的initialState，第二个参数不是Object,而是Function，createStore会认为你忽略了preloadedState而传入了一个enhancer createStore会返回enhancer(createStore)(reducer, preloadedState)的调用结果，这是常见高阶函数的调用方式。在这个调用中enhancer接受createStore作为参数，对createStore的能力进行增强，并返回增强后的createStore dispatch(action)diapatch 是 store 对象的方法，主要用来分发 action , redux 规定 action 一定要包含一个 type 属性，且 type 属性也要唯一 dispatch 是 store 非常核心的一个方法，也是我们在应用中最常使用的方法，下面是 dispatch 的源码 ： 12345678910111213141516171819202122232425262728293031function dispatch(action) &#123; if (!isPlainObject(action)) &#123; // 校验了action是否为一个原生js对象 throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.') &#125; if (typeof action.type === 'undefined') &#123; // action对象是否包含了必要的type字段 throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?') &#125; if (isDispatching) &#123; // 判断当前是否处于某个action分发过程中, 主要是为了避免在reducer中分发action throw new Error('Reducers may not dispatch actions.') &#125; try &#123; isDispatching = true currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; const listeners = (currentListeners = nextListeners) for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; // 在一系列检查完毕后，若均没有问题，将当前的状态和action传给当前reducer，用于生成新的state return action&#125; reducer &amp;&amp; store.replaceReducerRedux 中负责响应 action 并修改数据的角色就是reducer，reducer的本质实际上是一个函数replaceReducer: 12345678910111213/** * @desc 替换当前的reducer的函数 * @param &#123;Function&#125; * @return &#123;void&#125; */function replaceReducer(nextReducer) &#123; if (typeof nextReducer !== 'function') &#123; throw new Error('Expected the nextReducer to be a function.') &#125; currentReducer = nextReducer dispatch(&#123; type: ActionTypes.REPLACE &#125;)&#125; replaceReducer 使用场景： 当你的程序要进行代码分割的时候 当你要动态的加载不同的 reducer 的时候 当你要实现一个实时 reloading 机制的时候 中间件 middleware以上介绍了 redux 的实现流的过程，应用场景无非于 button – click –&gt; disptch – action –&gt; reducer – newState –&gt; view 但是这种实现方式是基于同步的方式的，日常开发中当然少不了 http 这些异步请求，这种情况下必须等到服务器数据返回后才重新渲染 view, 显然某些时候回阻塞页面的展示。 举例来说，要添加日志功能，把 Action 和 State 打印出来，可以对 store.dispatch 进行如下改造。 123456let next = store.dispatchstore.dispatch = function dispatchAndLog(action) &#123; console.log('dispatching', action) next(action) console.log('next state', store.getState())&#125; 上面代码中，对 store.dispatch 进行了重定义，在发送 Action 前后添加了打印功能。这就是中间件的雏形。 中间件就是一个函数，对 store.dispatch 方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。 applyMiddlewareRedux 提供了applyMiddleware来装载middleware：它是 Redux 的原生方法，作用是将所有中间件组成一个数组，依次执行。下面是它的源码。 123456789101112131415161718192021222324252627/** * @param &#123;...Function&#125; middlewares * returns &#123;Function&#125; A store enhancer applying the middleware */export default function applyMiddleware(...middlewares) &#123; return createStore =&gt; (...args) =&gt; &#123; const store = createStore(...args) let dispatch = () =&gt; &#123; throw new Error( `Dispatching while constructing your middleware is not allowed. ` + `Other middleware would not be applied to this dispatch.` ) &#125; const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args) &#125; const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125; 所有中间件被放进了一个数组 chain，然后嵌套执行，最后执行 store.dispatch。可以看到，中间件内部（middlewareAPI）可以拿到getState和dispatch这两个方法 compose 实际上是函数式编程中的组合，接收多个函数体并且将其组合成一个新的函数，例如compose 后 [fn1, fn2…] 依次从右到左嵌套执行函数 而compose用于applyMiddleware 也是为了组合中间件dispatch = compose(…chain)(store.dispatch)==&gt;dispatch=fn1(fn2(fn3(store.dispatch))) 123456789101112131415/** * @param &#123;...Function&#125; funcs The functions to compose. * @returns &#123;Function&#125; A function obtained by composing the argument functions */export default function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))&#125; redux-thunk上面的中间件的介绍可以知道redux 通过 applyMiddleware 来装载中间件，通过 compose 方法可以组合函数 异步的问题可以通过 redux-thunk 解决，用法也不难 react 组件中使用相关如下： 1234567891011121314151617181920212223242526272829// 配置 redux 加上这个...import &#123; createStore, applyMiddleware, compose &#125; from 'redux'import thunk from 'redux-thunk'// ...const store = createStore(getUser, compose(applyMiddleware(thunk)))// react 中使用import &#123; connect &#125; from 'react-redux'handleClick = () =&gt; &#123; this.props.dispatch(dispatch =&gt; &#123; return axios.get('https://randomuser.me/api/').then(res =&gt; &#123; dispatch(&#123; type: types.CHANGE_ARRAY, payload: &#123; name: res.data.results[0].name.title &#125; &#125;) &#125;) &#125;)&#125;const mapStateToProps = (state, props) =&gt; &#123; return &#123; name: state.demo.name &#125;&#125;export default connect(mapStateToProps)(Demo) 处理异步的还有很多插件 如 redux-soga 等，楼主并未实践过，所以不做延伸… react-redux下面是在 react 中使用的代码的雏形： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import &#123; createStore &#125; from 'redux'let defaultState = &#123; count: 1&#125;/** * Reducer * */function demoReducer(state = defaultState, action = &#123;&#125;) &#123; const &#123; type, payload &#125; = action const res = Object.assign(&#123;&#125;, state) if (type === 'changeCount') &#123; res.count = payload.count &#125; return res&#125;/** * @Store 存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。 * combineReducers(&#123; ...reducers &#125;) 可以组合多个reducer * */const store = createStore( demoReducer, window.devToolsExtension &amp;&amp; window.devToolsExtension() // 配置redux 开发工具)// ... 根元素下配置下 Providerimport &#123; Provider &#125; from 'react-redux'ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root'))// 组件中使用import &#123; connect &#125; from 'react-redux'//usethis.dispatch(&#123; type: 'changeCount', payload: &#123; count: 22 &#125;&#125;)const mapStateToProps = (state, props) =&gt; &#123; return &#123; name: state.demo.name &#125;&#125;export default connect(mapStateToProps)(Demo) mapStateToProps 用于建立组件跟 store 的 state 的映射关系作为一个函数，它可以传入两个参数，结果一定要返回一个 object 传入mapStateToProps之后，会订阅 store 的状态改变，在每次 store 的 state 发生变化的时候，都会被调用 如果写了第二个参数 props，那么当 props 发生变化的时候，mapStateToProps 也会被调用 mapDispatchToProps mapDispatchToProps用于建立组件跟 store.dispatch 的映射关系 可以是一个 object，也可以传入函数 如果mapDispatchToProps是一个函数，它可以传入 dispatch,props,定义 UI 组件如何发出 action，实际上就是要调用 dispatch 这个方法 1234567891011121314151617181920212223import &#123; connect &#125; from 'react-redux'import &#123; bindActionCreators &#125; from 'redux'// 页面中使用...this.props.changeName()const mapDispatchToProps = (&#123; changeName &#125; = (dispatch, props) =&gt; &#123; return bindActionCreators( &#123; changeName: function() &#123; return &#123; type: types.UPDATE_NAME, payload: &#123; name: '大大大' &#125; &#125; &#125; &#125;, dispatch )&#125;)export default connect(mapDispatchToProps)(App) 模块化配置下面的配置仅供参考。实现的功能： 整合 action、types、reducer 到一个文件 根据开发/生成环境配置不同的 redux 中间件(开发环境配置 dev-tools ) 支持装饰器模式 redux 热加载配置（这里面顺便将 react 热加载配置也加上了） 注意：项目基于 create-react-app eject 后的配置改造实现的。下面用了别名 @ ，需要改下 webpack 的配置，如果你配置不成功。详情可以看我的 github 上面有源码. 链接入口 安装123npm install redux react-redux redux-thunk --savenpm install redux-devtools-extension react-hot-loader -Dnpm install @babel/plugin-proposal-decorators -D 相关文件夹如图： models/demo.jsdemo 模块。 123456789101112131415161718192021222324// typesconst ADD_COUNT = 'ADD_COUNT'// actionsexport const addCount = () =&gt; &#123; return &#123; type: ADD_COUNT &#125;&#125;// stateconst defaultState = &#123; count: 11&#125;// reducerexport const demoReducer = (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; case ADD_COUNT: return &#123; ...state, count: ++state.count &#125; default: return state &#125;&#125;export default demoReducer models/index.js模块的导出口。 1234567import &#123; combineReducers &#125; from 'redux'import demo from './demo'export default combineReducers(&#123; demo&#125;) redux/index.jsredux 仓库的总出口 1234567891011121314151617181920212223242526272829import thunk from 'redux-thunk'import &#123; compose, createStore, applyMiddleware &#125; from 'redux'import &#123; composeWithDevTools &#125; from 'redux-devtools-extension'import rootReducer from './models'let storeEnhancersif (process.env.NODE_ENV === 'production') &#123; storeEnhancers = compose(thunk)&#125; else &#123; storeEnhancers = compose(composeWithDevTools(applyMiddleware(thunk)))&#125;const configureStore = (initialState = &#123;&#125;) =&gt; &#123; const store = createStore(rootReducer, initialState, storeEnhancers) if (module.hot &amp;&amp; process.env.NODE_ENV !== 'production') &#123; // Enable Webpack hot module replacement for reducers module.hot.accept('./models', () =&gt; &#123; console.log('replacing reducer...') const nextRootReducer = require('./models').default store.replaceReducer(nextRootReducer) &#125;) &#125; return store&#125;export default configureStore() src/index.jsreact 项目的入口配置。 12345678910111213141516171819202122232425import React from 'react'import ReactDOM from 'react-dom'import &#123; AppContainer &#125; from 'react-hot-loader'import App from './App'import &#123; Provider &#125; from 'react-redux'import store from '@/redux'const render = Component =&gt; &#123; ReactDOM.render( &lt;AppContainer&gt; &lt;Provider store=&#123;store&#125;&gt; &lt;Component /&gt; &lt;/Provider&gt; &lt;/AppContainer&gt;, document.getElementById('root') )&#125;render(App)if (module.hot) &#123; module.hot.accept('./App', () =&gt; &#123; render(App) &#125;)&#125; App.jsx12345678910111213141516171819202122232425262728import React, &#123; Component, Fragment &#125; from 'react'import &#123; connect &#125; from 'react-redux'import &#123; addCount &#125; from '@/redux/models/demo'import &#123; Button &#125; from 'antd'const mapStateToProps = state =&gt; (&#123; count: state.demo.count&#125;)@connect( mapStateToProps, &#123; addCount &#125;)class ReduxTest extends Component &#123; render() &#123; return ( &lt;Fragment&gt; &#123;this.props.count&#125; &lt;Button type=\"primary\" onClick=&#123;this.props.addCount&#125;&gt; Click &lt;/Button&gt; &lt;hr /&gt; &lt;/Fragment&gt; ) &#125;&#125;export default ReduxTest .babelrc配置 babel 装饰器模式 123456&#123; \"presets\": [\"react-app\"], \"plugins\": [ [\"@babel/plugin-proposal-decorators\", &#123; \"legacy\": true &#125;] ]&#125; vscode 装饰器模式如果有报警的话，可以根目录下新建 jsconfig.json 123456789101112131415161718&#123; \"compilerOptions\": &#123; \"experimentalDecorators\": true, \"baseUrl\": \"./\", \"paths\": &#123; \"@/*\": [ \"src/*\" ] &#125;, \"jsx\": \"react\" &#125;, \"exclude\": [ \"node_modules\", \"build\", \"config\", \"scripts\" ]&#125; 参考 阮一峰 redux 入门教程 配置文件可以看我的 github : react-demo","categories":[{"name":"React","slug":"React","permalink":"https://weifo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://weifo.github.io/tags/React/"}]},{"title":"react - hooks(v16.7)","slug":"react-hooks","date":"2020-02-08T07:30:32.000Z","updated":"2020-03-15T13:18:17.505Z","comments":false,"path":"2020/02/08/react-hooks/","link":"","permalink":"https://weifo.github.io/2020/02/08/react-hooks/","excerpt":"前言本文不做概念性的解析，旨在实操 hooks，相关资源可以自行谷歌。以下提供相关参考资料： Introducing Hooks 理解 React Hooks React Hooks 实用指南 - 大都借鉴这篇文章 Hooks 一览","text":"前言本文不做概念性的解析，旨在实操 hooks，相关资源可以自行谷歌。以下提供相关参考资料： Introducing Hooks 理解 React Hooks React Hooks 实用指南 - 大都借鉴这篇文章 Hooks 一览 useState useState 可以让您的函数组件也具备类组件的 state 功能。 12345/** * @state - state的值 * @setState - 更新state的函数, 接受一个参数值来更新 state */const [state, setState] = useState(initialState) 案例12345678910111213import React, &#123; useState &#125; from 'react'function Base() &#123; const [count, setCount] = useState(0) return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; )&#125;export default Base 值得注意的是，state 是对象的话， setState 接收什么参数，就更新对象下的所有属性，而不是更新单个属性。 12345678910111213141516import React, &#123; useState &#125; from 'react'function Demo2() &#123; const [info, setInfo] = useState(&#123; name: 'guodada', age: 22 &#125;) return ( &lt;div&gt; &lt;p&gt;name: &#123;info.name&#125;&lt;/p&gt; &lt;p&gt;age: &#123;info.age&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setInfo(&#123; name: 'Sam' &#125;)&#125;&gt;setInfo&lt;/button&gt; &lt;/div&gt; )&#125; click button =&gt; info = { name: &#39;Sam&#39; }，age 丢失。 根据业务需求，我们可以在函数组件中使用多个 useState，这里不再进行演示。 useEffectEffect Hook: 它与 React Class 中的 componentDidMount，componentDidUpdate 和 componentWillUnmount 具有相同的用途。模拟的是生命周期 12345/** * @didUpdate - function * @[] - 参数2为数组，不加参数或者不写的话任何state 的变化都会执行 didUpdate 函数 */useEffect(didUpdate, []) 案例12345678910111213141516171819202122class Example extends React.Component &#123; state = &#123; count: 0 &#125; componentDidMount() &#123; document.title = `You clicked $&#123;this.state.count&#125; times` &#125; componentDidUpdate() &#123; document.title = `You clicked $&#123;this.state.count&#125; times` &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 等同于 12345678910111213141516import &#123; useState, useEffect &#125; from 'react'function Example() &#123; const [count, setCount] = useState(0) useEffect(() =&gt; &#123; document.title = `You clicked $&#123;count&#125; times` &#125;) return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; )&#125; 添加第二个参数进行控制12345678910111213141516171819import React, &#123; useState, useEffect &#125; from 'react'function Example() &#123; const [count, setCount] = useState(0) const [count2, setCount2] = useState(0) useEffect(() =&gt; &#123; console.log('run useEffect') &#125;, [count]) // 只有count 变化时才执行这个 useEffect 函数 return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/button&gt; &lt;p&gt;You clicked &#123;count2&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount2(count2 + 1)&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; )&#125; useContext useReducer 是 useState 的代提方案。当你有一些更负责的数据时可以使用它。（组件本地的redux） 使用语法如下： 1234567/** * @state =&gt; your state * @dispatch * @param &#123;state&#125; * @param &#123;action&#125; **/const [state, dispatch] = useReducer(reducer, initialState) 案例12345678910111213141516171819202122232425262728293031323334353637383940import React, &#123; Component, useReducer &#125; from 'react'function TestUseReducer() &#123; const [state, dispatch] = useReducer( (state, action) =&gt; &#123; switch (action.type) &#123; case 'update': return &#123; name: action.payload &#125; default: return state &#125; &#125;, &#123; name: '' &#125; ) const handleNameChange = e =&gt; &#123; dispatch(&#123; type: 'update', payload: e.target.value &#125;) &#125; return ( &lt;div&gt; &lt;p&gt;你好：&#123;state.name&#125;&lt;/p&gt; &lt;input onChange=&#123;handleNameChange&#125; /&gt; &lt;/div&gt; )&#125;class App extends Component &#123; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;h2&gt;Start editing to see some magic happen!&lt;/h2&gt; &lt;TestUseReducer /&gt; &lt;/div&gt; ) &#125;&#125;export default App useCallback useCallback 和 useMemo 有些相似。它接收一个内联函数和一个数组，它返回的是一个记忆化版本的函数。 使用语法如下： 1const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a), [a]) 案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, &#123; Component, useCallback &#125; from 'react'function TestUseCallback(&#123; num &#125;) &#123; const memoizedCallback = useCallback( () =&gt; &#123; console.log('这里监听 num 值的更新重新做一些操作和计算') num.forEach(item =&gt; item++ ) return num &#125;, [num] ) console.log('记忆 num &gt; ', memoizedCallback()) console.log('原始 num &gt; ', num) return null&#125;const num1 = [1, 2, 3]const num2 = [4, 5, 6]class App extends Component &#123; state = &#123; num: num1, count: 0 &#125; componentDidMount() &#123; setInterval(() =&gt; &#123; this.setState(state =&gt; (&#123; count: state.count + 1 &#125;)) &#125;, 3000) &#125; handleChangeNum = () =&gt; &#123; this.setState(&#123; num: num2 &#125;) &#125; render() &#123; const &#123; num &#125; = this.state return ( &lt;div className=\"App\"&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;h2&gt;Start editing to see some magic happen!&lt;/h2&gt; &lt;button onClick=&#123;this.handleChangeNum&#125;&gt;修改传入的Num值&lt;/button&gt; &lt;TestUseCallback num=&#123;num&#125; /&gt; &lt;/div&gt; ) &#125;&#125;export default App useRef123456789101112131415161718192021import React, &#123; useRef &#125; from 'react'function TestUseRef() &#123; const inputEl = useRef(null) const onButtonClick = () =&gt; &#123; inputEl.current.focus() // 设置useRef返回对象的值 &#125; return ( &lt;div&gt; &lt;p&gt;TestUseRef&lt;/p&gt; &lt;div&gt; &lt;input ref=&#123;inputEl&#125; type=\"text\" /&gt; &lt;button onClick=&#123;onButtonClick&#125;&gt;input聚焦&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; )&#125;export default TestUseRef","categories":[{"name":"React","slug":"React","permalink":"https://weifo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://weifo.github.io/tags/React/"}]},{"title":"react - 生命周期","slug":"react-LifeCycle","date":"2020-02-05T13:20:13.000Z","updated":"2020-03-15T13:09:01.437Z","comments":false,"path":"2020/02/05/react-LifeCycle/","link":"","permalink":"https://weifo.github.io/2020/02/05/react-LifeCycle/","excerpt":"v16.3+ Mounting constructor(props) static getDerivedStateFromProps(props, state) render() componentDidMount() Updating static getDerivedStateFromProps() shouldComponentUpdate(nextProps, nextState) render() getSnapshotBeforeUpdate(prevProps, prevState) componentDidUpdate(prevProps, prevState, snapshot)","text":"v16.3+ Mounting constructor(props) static getDerivedStateFromProps(props, state) render() componentDidMount() Updating static getDerivedStateFromProps() shouldComponentUpdate(nextProps, nextState) render() getSnapshotBeforeUpdate(prevProps, prevState) componentDidUpdate(prevProps, prevState, snapshot) constructor(props)React 组件的构造函数在安装之前被调用。在为 React.Component 子类实现构造函数时，应该在任何其他语句之前调用 super(props)。否则，this.props 将在构造函数中未定义，这可能导致错误。 Avoid copying props into state! This is a common mistake: 12345constructor(props) &#123; super(props) // Don't do this! this.state = &#123; color: props.color &#125;&#125; static getDerivedStateFromProps(nextProps, prevState)props / state 改变时触发，需要返回一个对象或者 null，相当于 setState demo 1234static getDerivedStateFromProps(nextProps, prevState)&#123; if (nextProps.sum !== prevState.sum) return &#123; sum: nextProps.sum &#125; // 类似于 setState(&#123; sum: nextProps.sum &#125;) return null&#125; render()12345render()&#123; // don't do this this.setState(&#123; num: 12 &#125;) return null&#125; componentDidMount()组件挂载后。 shouldComponentUpdate(nextProps, nextState)1shouldComponentUpdate(nextProps, nextState) return true / false 来决定是否重新 render getSnapshotBeforeUpdate(prevProps, prevState)相当于 componentWillUpdate componentDidUpdate(prevProps, prevState, snapshot)更新后 - 这里谨慎使用 setState() v16.3 以下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import React, &#123; Component &#125; from 'react'/** * * 挂载数据： * @example constructor =&gt; componentWillMount =&gt; render =&gt; componentDidMount * * 数据变化： * @example props change: componentWillReceiveProps =&gt; shouldComponentUpdate =&gt; componentWillUpdate =&gt; render =&gt; componentDidUpdate * @example state change: shouldComponentUpdate =&gt; componentWillUpdate =&gt; componentDidUpdate * */class LifeCycle extends React.Component &#123; constructor() &#123; super() // 声明constructor时必须调用super方法 this.state = &#123; subNum: 2 &#125; console.log('01 constructor') &#125; componentWillMount() &#123; console.log('02 componentWillMount') &#125; componentDidMount() &#123; console.log('04 componentDidMount') &#125; componentWillReceiveProps(nextProps) &#123; console.log('05 componentWillReceiveProps') &#125; shouldComponentUpdate(nextProps, nextState) &#123; console.log('06 shouldComponentUpdate') return true // 记得要返回true &#125; componentWillUpdate(nextProps, nextState) &#123; console.log('07 componentWillUpdate') &#125; componentDidUpdate(prevProps, prevState) &#123; console.log('08 componentDidUpdate') &#125; componentWillUnmount() &#123; console.log('09 componentWillUnmount') &#125; changeState = () =&gt; &#123; this.setState(prevState =&gt; (&#123; subNum: ++prevState.subNum &#125;)) &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.changeState&#125;&gt;change state&lt;/button&gt; &lt;h2&gt;&#123;this.state.subNum&#125;&lt;/h2&gt; &lt;/div&gt; ) &#125;&#125;class App extends Component &#123; state = &#123; num: 1 &#125; changeProps = () =&gt; &#123; // this.setState((prevState, props) =&gt; (&#123;&#125;)) this.setState(prevState =&gt; (&#123; num: ++prevState.num &#125;)) &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.changeProps&#125;&gt;change props&lt;/button&gt; &lt;hr /&gt; &lt;LifeCycle num=&#123;this.state.num&#125; /&gt; &lt;/div&gt; ) &#125;&#125;export default App","categories":[{"name":"React","slug":"React","permalink":"https://weifo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://weifo.github.io/tags/React/"}]},{"title":"react-context","slug":"react-context","date":"2020-02-03T01:58:42.000Z","updated":"2020-03-15T13:08:42.690Z","comments":false,"path":"2020/02/03/react-context/","link":"","permalink":"https://weifo.github.io/2020/02/03/react-context/","excerpt":"简单使用Context 设计目的是为共享那些被认为对于一个组件树而言是“全局”的数据，你可以看做为 redux，因为 redux 也是通过这个东东实现的。 1234567891011121314151617181920212223242526import React, &#123; Component &#125; from 'react'/** * 1. 创建 context * 2. 根组件 App 包裹 MyContext.Provider * 3. App =&gt; Father =&gt; Child =&gt; MyContext.Consumer =&gt; context.age 取出结果 */const MyContext = React.createContext()const Child = () =&gt; ( &lt;MyContext.Consumer&gt;&#123;(&#123; age &#125;) =&gt; &lt;p&gt;My age is &#123;age&#125;&lt;/p&gt;&#125;&lt;/MyContext.Consumer&gt;)const Father = () =&gt; &lt;Child /&gt;class App extends Component &#123; render() &#123; return ( &lt;MyContext.Provider value=&#123;&#123; age: 22 &#125;&#125;&gt; &lt;Father /&gt; &lt;/MyContext.Provider&gt; ) &#125;&#125;export default App","text":"简单使用Context 设计目的是为共享那些被认为对于一个组件树而言是“全局”的数据，你可以看做为 redux，因为 redux 也是通过这个东东实现的。 1234567891011121314151617181920212223242526import React, &#123; Component &#125; from 'react'/** * 1. 创建 context * 2. 根组件 App 包裹 MyContext.Provider * 3. App =&gt; Father =&gt; Child =&gt; MyContext.Consumer =&gt; context.age 取出结果 */const MyContext = React.createContext()const Child = () =&gt; ( &lt;MyContext.Consumer&gt;&#123;(&#123; age &#125;) =&gt; &lt;p&gt;My age is &#123;age&#125;&lt;/p&gt;&#125;&lt;/MyContext.Consumer&gt;)const Father = () =&gt; &lt;Child /&gt;class App extends Component &#123; render() &#123; return ( &lt;MyContext.Provider value=&#123;&#123; age: 22 &#125;&#125;&gt; &lt;Father /&gt; &lt;/MyContext.Provider&gt; ) &#125;&#125;export default App 理论知识React.createContext1const &#123; Provider, Consumer &#125; = React.createContext(defaultValue) 创建一对 { Provider, Consumer }。当 React 渲染 context 组件 Consumer 时，它将从组件树的上层中最接近的匹配的 Provider 读取当前的 context 值。 Provider1&lt;Provider value=&#123;/* some value */&#125;&gt; React 组件允许 Consumers 订阅 context 的改变。接收一个 value 属性传递给 Provider 的后代 Consumers。一个 Provider 可以联系到多个 Consumers。Providers 可以被嵌套以覆盖组件树内更深层次的值。 Consumer123&lt;Consumer&gt; &#123;value =&gt; /* render something based on the context value */&#125;&lt;/Consumer&gt; 一个可以订阅 context 变化的 React 组件。 注意，MyContext.Consumer 使用的是 render props 这种模式，render props 模式指的是让 prop 可以是一个 render 函数 父子耦合经常需要从组件树中某个深度嵌套的组件中更新 context。在这种情况下，可以通过 context 向下传递一个函数，以允许 Consumer 更新 context ： 1234567891011121314151617181920212223242526272829303132333435363738394041import React, &#123; Component &#125; from 'react'const MyContext = React.createContext()const Child = () =&gt; ( &lt;MyContext.Consumer&gt; &#123;ctx =&gt; ( &lt;div&gt; &lt;p&gt;My age is &#123;ctx.age&#125;&lt;/p&gt; &lt;button onClick=&#123;ctx.changeAge&#125;&gt;changeAge&lt;/button&gt; &lt;/div&gt; )&#125; &lt;/MyContext.Consumer&gt;)const Father = () =&gt; &lt;Child /&gt;class App extends Component &#123; state = &#123; age: 22 &#125; changeAge = () =&gt; &#123; this.setState(prevState =&gt; (&#123; age: ++prevState.age &#125;)) &#125; render() &#123; return ( &lt;MyContext.Provider value=&#123;&#123; age: this.state.age, changeAge: this.changeAge &#125;&#125;&gt; &lt;Father /&gt; &lt;/MyContext.Provider&gt; ) &#125;&#125;export default App 作用于多个上下文为了保持 context 快速进行二次渲染， React 需要使每一个 Consumer 在组件树中成为一个单独的节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import React, &#123; Component &#125; from 'react'const MyContext = React.createContext()const UserContext = React.createContext()const Child = () =&gt; ( &lt;MyContext.Consumer&gt; &#123;ctx =&gt; ( &lt;UserContext.Consumer&gt; &#123;user =&gt; ( &lt;div&gt; &lt;p&gt;My name is &#123;user.name&#125;&lt;/p&gt; &lt;p&gt;My age is &#123;ctx.age&#125;&lt;/p&gt; &lt;button onClick=&#123;ctx.changeAge&#125;&gt;changeAge&lt;/button&gt; &lt;/div&gt; )&#125; &lt;/UserContext.Consumer&gt; )&#125; &lt;/MyContext.Consumer&gt;)const Father = () =&gt; &lt;Child /&gt;class App extends Component &#123; state = &#123; age: 22, name: '郭大大' &#125; changeAge = () =&gt; &#123; this.setState(prevState =&gt; (&#123; age: ++prevState.age &#125;)) &#125; render() &#123; return ( &lt;MyContext.Provider value=&#123;&#123; age: this.state.age, changeAge: this.changeAge &#125;&#125;&gt; &lt;UserContext.Provider value=&#123;&#123; name: this.state.name &#125;&#125;&gt; &lt;Father /&gt; &lt;/UserContext.Provider&gt; &lt;/MyContext.Provider&gt; ) &#125;&#125;export default App 如果两个或者多个上下文的值经常被一起使用，也许你需要考虑你自己渲染属性的组件提供给它们。 在生命周期方法中访问 Context在生命周期方法中从上下文访问值是一种相对常见的用例。而不是将上下文添加到每个生命周期方法中，只需要将它作为一个 props 传递，然后像通常使用 props 一样去使用它。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import React, &#123; Component &#125; from 'react'const MyContext = React.createContext()class Child extends Component &#123; componentDidMount() &#123; console.log(this.props.ctx) &#125; render() &#123; const &#123; age, changeAge &#125; = this.props.ctx return ( &lt;div&gt; &lt;p&gt;My age is &#123;age&#125;&lt;/p&gt; &lt;button onClick=&#123;changeAge&#125;&gt;changeAge&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;const Father = props =&gt; ( &lt;MyContext.Consumer&gt; &#123;ctx =&gt; &lt;Child &#123;...props&#125; ctx=&#123;ctx&#125; /&gt;&#125; &lt;/MyContext.Consumer&gt;)class App extends Component &#123; state = &#123; age: 22 &#125; changeAge = () =&gt; &#123; this.setState(prevState =&gt; (&#123; age: ++prevState.age &#125;)) &#125; render() &#123; return ( &lt;MyContext.Provider value=&#123;&#123; age: this.state.age, changeAge: this.changeAge &#125;&#125;&gt; &lt;Father /&gt; &lt;/MyContext.Provider&gt; ) &#125;&#125;export default App 转发 Refs一个关于渲染属性API的问题是 refs 不会自动的传递给被封装的元素。为了解决这个问题，使用 React.forwardRef： fancy-button.js 1234567891011121314151617class FancyButton extends React.Component &#123; focus() &#123; // ... &#125; // ...&#125;// 使用 context 传递当前的 \"theme\" 给 FancyButton.// 使用 forwardRef 传递 refs 给 FancyButton 也是可以的.export default React.forwardRef((props, ref) =&gt; ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; ( &lt;FancyButton &#123;...props&#125; theme=&#123;theme&#125; ref=&#123;ref&#125; /&gt; )&#125; &lt;/ThemeContext.Consumer&gt;)) app.js 12345678910import FancyButton from './fancy-button'const ref = React.createRef()// ref属性将指向 FancyButton 组件,// ThemeContext.Consumer 没有包裹它// 这意味着我们可以调用 FancyButton 的方法就像这样 ref.current.focus()&lt;FancyButton ref=&#123;ref&#125; onClick=&#123;handleClick&#125;&gt; Click me!&lt;/FancyButton&gt; 尽量减少使用 context因为 context 使用 reference identity 确定何时重新渲染，在 Consumer 中，当一个 Provider 的父节点重新渲染的时候，有一些问题可能触发意外的渲染。例如下面的代码，所有的 Consumner 在 Provider 重新渲染之时，每次都将重新渲染，因为一个新的对象总是被创建对应 Provider 里的 value 123456789class App extends React.Component &#123; render() &#123; return ( &lt;Provider value=&#123;&#123;something: 'something'&#125;&#125;&gt; &lt;Toolbar /&gt; &lt;/Provider&gt; ); &#125;&#125; 为了防止这样, 提升 value 到父节点的 state 里: 123456789101112131415class App extends React.Component &#123; constructor(props) &#123; this.state = &#123; value: &#123;something: 'something'&#125;, &#125;; &#125; render() &#123; return ( &lt;Provider value=&#123;this.state.value&#125;&gt; &lt;Toolbar /&gt; &lt;/Provider&gt; ); &#125;&#125; 注意点React context的局限性： 在组件树中，如果中间某一个组件 ShouldComponentUpdate returning false 了，会阻碍 context 的正常传值，导致子组件无法获取更新。 组件本身 extends React.PureComponent 也会阻碍 context 的更新。 Context 应该是唯一不可变的 组件只在初始化的时候去获取 Context","categories":[{"name":"React","slug":"React","permalink":"https://weifo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://weifo.github.io/tags/React/"}]},{"title":"react 入门","slug":"react-basic","date":"2020-02-02T15:03:29.000Z","updated":"2020-03-15T12:52:03.694Z","comments":false,"path":"2020/02/02/react-basic/","link":"","permalink":"https://weifo.github.io/2020/02/02/react-basic/","excerpt":"123456789101112&lt;script src=\"https://unpkg.com/react@16/umd/react.development.js\"&gt;&lt;/script&gt;&lt;script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"&gt;&lt;/script&gt;&lt;!-- 生产环境中不建议使用 --&gt;&lt;script src=\"https://unpkg.com/babel-standalone@6.15.0/babel.min.js\"&gt;&lt;/script&gt;&lt;div id=\"example\"&gt;&lt;/div&gt;&lt;script type=\"text/babel\"&gt;ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example'));&lt;/script&gt; react.min.js - React 的核心库 react-dom.min.js - 提供与 DOM 相关的功能 babel.min.js - Babel 可以将 ES6 代码转为 ES5 代码","text":"123456789101112&lt;script src=\"https://unpkg.com/react@16/umd/react.development.js\"&gt;&lt;/script&gt;&lt;script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"&gt;&lt;/script&gt;&lt;!-- 生产环境中不建议使用 --&gt;&lt;script src=\"https://unpkg.com/babel-standalone@6.15.0/babel.min.js\"&gt;&lt;/script&gt;&lt;div id=\"example\"&gt;&lt;/div&gt;&lt;script type=\"text/babel\"&gt;ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example'));&lt;/script&gt; react.min.js - React 的核心库 react-dom.min.js - 提供与 DOM 相关的功能 babel.min.js - Babel 可以将 ES6 代码转为 ES5 代码 使用 create-react-app 快速构建 React 开发环境123cnpm install -g create-react-appcreate-react-app my-appnpm run eject TodoList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import React, &#123;Component&#125; from 'react';class TodoList extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; list: [], inputValue: '' &#125; this.handleChange = this.handleChange.bind(this) this.handleBtnClick = this.handleBtnClick.bind(this) &#125; handleChange(e) &#123; this.setState(&#123; inputValue: e.target.value &#125;) &#125; handleBtnClick() &#123; this.setState( &#123; list: [...this.state.list, this.state.inputValue], inputValue: '' &#125; ) &#125; handleItemClick(index) &#123; let list = [...this.state.list] list.splice(index, 1) this.setState(&#123; list &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;div&gt; &lt;input value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleChange&#125;/&gt; &lt;button onClick=&#123;this.handleBtnClick&#125; className='btn'&gt;add&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &#123; this.state.list.map((item, index) =&gt; &#123; return ( &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemClick.bind(this, index)&#125;&gt;&#123;item&#125;&lt;/li&gt; ) &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;export default TodoList 组件化todoList 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import React, &#123;Component&#125; from 'react';import TodoItem from './TodoItem'class TodoList extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; list: [], inputValue: '' &#125; this.handleChange = this.handleChange.bind(this) this.handleBtnClick = this.handleBtnClick.bind(this) &#125; handleChange(e) &#123; this.setState(&#123; inputValue: e.target.value &#125;) &#125; handleBtnClick() &#123; this.setState( &#123; list: [...this.state.list, this.state.inputValue], inputValue: '' &#125; ) &#125; handleItemClick(index) &#123; let list = [...this.state.list] list.splice(index, 1) this.setState(&#123;list&#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;div&gt; &lt;input value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleChange&#125;/&gt; &lt;button onClick=&#123;this.handleBtnClick&#125; className='btn'&gt;add&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &#123; this.state.list.map((item, index) =&gt; &#123; // return ( // &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemClick.bind(this, index)&#125;&gt;&#123;item&#125;&lt;/li&gt; // ) return ( &lt;TodoItem key=&#123;index&#125; content=&#123;item&#125; index=&#123;index&#125; delete=&#123;this.handleItemClick.bind(this, index)&#125; /&gt; ) &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;export default TodoList todoItem12345678910111213141516171819import React, &#123;Component&#125; from 'react'; class TodoItem extends Component &#123; constructor(props) &#123; super(props) this.handleDelete = this.handleDelete.bind(this) &#125; // 子组件想要和父组件通信，要调用父组件传递过来的方法 handleDelete(index) &#123; this.props.delete(index) &#125; // 父组件通过属性的形式向子组件传递参数 // 子组件通过props接受父组件传递过来的参数 render() &#123; return ( &lt;li onClick=&#123;this.handleDelete&#125;&gt;&#123;this.props.content&#125;&lt;/li&gt; ) &#125;&#125; export default TodoItem","categories":[{"name":"React","slug":"React","permalink":"https://weifo.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://weifo.github.io/tags/React/"}]},{"title":"git 实用指南","slug":"git-command","date":"2020-01-23T13:30:04.000Z","updated":"2020-03-15T13:17:52.912Z","comments":false,"path":"2020/01/23/git-command/","link":"","permalink":"https://weifo.github.io/2020/01/23/git-command/","excerpt":"commit 规范速查 feat：新功能（feature） fix：修补 bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改 bug 的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 revert: 撤销以前的 commit 1revert: feat(pencil): add 'graphiteWidth' option","text":"commit 规范速查 feat：新功能（feature） fix：修补 bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改 bug 的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 revert: 撤销以前的 commit 1revert: feat(pencil): add 'graphiteWidth' option 本地创建、连接远程仓库123456789# 创建并连接远程仓库mkdir git-democd git-demo/git init# 连接远程仓库git remote add origin https://github.com/gershonv/git-demo.git 新建文件并推向远端1234567891011# 创建 a.jstouch a.js# 添加到暂存区（见下文）git add .# commit 记录（见下文）git commit -m 'feat: 新增 a.js 文件'# 推向远端 master 分支（见下文）git push origin master git add git add [file1 file2 file3...]: 添加多个文件 git add . : 暂存所有文件 git status M - 被修改，A - 被添加，D - 被删除，R - 重命名，?? - 未被跟踪 撤销操作撤销 git add123456789# 新建 b.js 文件touch b.jsgit add .git statis# 撤销 git addgit reset head b.js git reset head : 如果后面什么都不跟的话 就是上一次 add 里面的全部撤销了 git reset head file: 对某个文件进行撤销了 撤销本地修改12345678910111213141516# 修改文件vim a.js# 插入数据shift + i# 保存退出shift + : wq# 加入暂存区git add .git commit -m 'refactor: 修改 a.js 文件'# 撤销修改git checkout -- a.js 撤销 git commit12345# 查看 commit 记录git log# 重置到某个节点。git reset --hard ea794cf0dcf934b594 分支新建分支并推向远程1234567891011# 新建并切换本地分支git checkout -b dev# 查看当前分支git branch# 查看远程分支git branch -r# 推送到远程git push origin dev 合并分支12345678# 开发完 dev 分支后git checkout master# 合并 dev 分支到主分支git merge dev# 推送git push origin master 分支管理123456789# 查看所有分支 远程+本地git branch -a# 删除远程分支git push origin -d dev# 删除本地分支git checkout mastergit branch -d dev","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://weifo.github.io/categories/开发工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://weifo.github.io/tags/Git/"}]},{"title":"HTTP - 缓存机制","slug":"http-cache","date":"2020-01-23T01:23:23.000Z","updated":"2020-03-15T13:17:46.685Z","comments":false,"path":"2020/01/23/http-cache/","link":"","permalink":"https://weifo.github.io/2020/01/23/http-cache/","excerpt":"缓存实现的步骤 首先是当用户请求资源时，会判断是否有缓存，如果没有，则会向原服务器请求资源。 如果有缓存，则会进入强缓存的范畴，判断缓存是否新鲜 如果缓存新鲜，则会直接返回缓存副本给客户端。 如果缓存不新鲜了，则表示强缓存失败，将会进入到协商缓存。 协商缓存将判断是否存在 Etag 和 Last-Modified 首部 如果未发生变化，则表示命中了协商缓存，会重定向到缓存副本，将资源返回给客户端 否则的话表示协商缓存未命中，服务器会返回新的资源。 强缓存 服务端告知客户端缓存时间后，由客户端判断并决定是否使用缓存。 强缓存是通过 Expires 首部或 Cache-Control: max-age 来实现的。 Expires: 响应头，代表该资源的过期时间。 Cache-Control: 请求/响应头，缓存控制字段，精确控制缓存策略。","text":"缓存实现的步骤 首先是当用户请求资源时，会判断是否有缓存，如果没有，则会向原服务器请求资源。 如果有缓存，则会进入强缓存的范畴，判断缓存是否新鲜 如果缓存新鲜，则会直接返回缓存副本给客户端。 如果缓存不新鲜了，则表示强缓存失败，将会进入到协商缓存。 协商缓存将判断是否存在 Etag 和 Last-Modified 首部 如果未发生变化，则表示命中了协商缓存，会重定向到缓存副本，将资源返回给客户端 否则的话表示协商缓存未命中，服务器会返回新的资源。 强缓存 服务端告知客户端缓存时间后，由客户端判断并决定是否使用缓存。 强缓存是通过 Expires 首部或 Cache-Control: max-age 来实现的。 Expires: 响应头，代表该资源的过期时间。 Cache-Control: 请求/响应头，缓存控制字段，精确控制缓存策略。 server.js - demo 12345678910111213const http = require('http')http .createServer(function(request, response) &#123; response.writeHead(200, &#123; 'Content-Type': 'text/javascript', 'Conche-Control': 'max-age=2000, public' // 缓存时间 2000s；public: 资源允许被中间服务器缓存 &#125;) response.end(\"console.log('script loaded')\") &#125;) .listen(3301)console.log('http://127.0.0.1:3301') Expires(HTTP/1.0)Expires 和 Cache-Control: max-age 都是用来标识资源的过期时间的首部。 由于 expires 是一个绝对时间，如果人为的更改时间，会对缓存的有效期造成影响，使缓存有效期的设置失去意义。因此在 http1.1 中我们有了 expires 的完全替代首部 cache-control：max-age Cache-Control(HTTP/1.1)除了可以设置 max-age 相对过期时间以外，还可以设置成如下几种值： public，资源允许被中间服务器缓存。 浏览器请求服务器时，如果缓存时间没到，中间服务器直接返回给浏览器内容，而不必请求源服务器。 private，资源不允许被中间代理服务器缓存 浏览器请求服务器时，中间服务器都要把浏览器的请求透传给服务器。 no-cache，浏览器不做缓存检查。 每次访问资源，浏览器都要向服务器询问，如果文件没变化，服务器只告诉浏览器继续使用缓存（304）。 no-store，浏览器和中间代理服务器都不能缓存资源。 每次访问资源，浏览器都必须请求服务器，并且，服务器不去检查文件是否变化，而是直接返回完整的资源。 must-revalidate，可以缓存，但是使用之前必须先向源服务器确认。 proxy-revalidate，要求缓存服务器针对缓存资源向源服务器进行确认。 s-maxage：缓存服务器对资源缓存的最大时间。 Cache-Control 对缓存的控制粒度更细，包括缓存代理服务器的缓存控制。 协商缓存 由服务端决定并告知客户端是否使用缓存。 协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。协商缓存是通过请求头 Last-Modified 或 Etag 来实现的。 Last-Modified 标识的是文档最后修改时间 Etag 则是以文档内容来进行编码的。 Last-Modified 响应头，资源最近修改时间，由服务器告诉浏览器。 Last-Modified （上次修改时间）主要配合 If-Modified-Since 或者 If-Unmodified-Since 使用， 对比上次修改时间以验证资源是否需要更新 If-Modified-Since: 请求头 首次请求资源时，服务器在返回资源的同时，会在 Response Headers 中写入 Last-Modified 首部，表示该资源在服务器上的最后修改时间。 当再次请求该资源时，会在 Request Headers 中写入 If-Modified-Since 首部，此时的 If-Modified-Since 的值是首次请求资源时所返回的 Last-Modified 的值。 服务器接收到请求后，会根据 If-Modified-Since 的值判断资源在该日期之后是否发生过变化。 如果没有，则会返回 304 Not Modified;如果变化了，则会返回变化过后的资源，同时更新 Last-Modified 的值。 资源未更新 network 面板截图 资源发生更新 network 面板截图可以看到 Last-Modified 和 If-Modified-Since 标识的时间不一样 server.js - demo 1234567891011121314const http = require('http')http .createServer(function(request, response) &#123; response.writeHead(200, &#123; 'Content-Type': 'text/javascript', 'Conche-Control': 'max-age=2000, public', // 缓存时间 2000s；public: 资源允许被中间服务器缓存 'Last-Modified': '123' &#125;) response.end(\"console.log('script loaded')\") &#125;) .listen(3301)console.log('http://127.0.0.1:3301') Etag 响应头，资源标识，由服务器告诉浏览器。 Etag 和 If-None-Match 配合使用， （文件内容对比）对比资源的签名来决定是否使用缓存。 server.js - demo 123456789101112131415161718192021222324252627const http = require('http')http .createServer(function(request, response) &#123; const etag = request.headers['if-none-match'] if (etag === '777') &#123; response.writeHead(304, &#123; 'Content-Type': 'text/javascript', 'Cache-Control': 'max-age=120, no-cache', // 缓存时间 120s；no-cache: 浏览器不做缓存检查 'Last-Modified': '123', Etag: '777' &#125;) response.end() &#125; else &#123; // etag change response.writeHead(200, &#123; 'Content-Type': 'text/javascript', 'Conche-Control': 'max-age=120, no-cache', // 缓存时间 120s；no-cache: 浏览器不做缓存检查 'Last-Modified': '123', Etag: '777' &#125;) response.end(\"console.log('script loaded')\") &#125; &#125;) .listen(3301)console.log('http://127.0.0.1:3301') 总结与缓存方案 服务器和浏览器约定资源过期时间 Cache-Control: expires=xxx 服务器告诉浏览器资源上次修改时间 Last-Modified 增加相对时间的控制 Cache-Control: max-age=xxx 增加文件内容对比，引入Etag 缓存优先级 Pragma &gt; Cache-Control &gt; Expires &gt; ETag &gt; Last-Modified 参考与相关链接： 浅谈 HTTP 缓存 面试精选之 http 缓存","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://weifo.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://weifo.github.io/tags/HTTP/"}]},{"title":"ES6 - Map 和 Set","slug":"es6-map&set","date":"2020-01-21T01:07:08.000Z","updated":"2020-03-15T13:17:40.812Z","comments":false,"path":"2020/01/21/es6-map&set/","link":"","permalink":"https://weifo.github.io/2020/01/21/es6-map&set/","excerpt":"Map 和 SetJavaScript 的默认对象表示方式{}可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对。 但是 JavaScript 的对象有个小问题，就是键必须是字符串。但实际上 Number 或者其他数据类型作为键也是非常合理的。 MapMap是一组键值对的结构，具有极快的查找速度。 举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array： 12var names = ['Michael', 'Bob', 'Tracy']var scores = [95, 75, 85] 给定一个名字，要查找对应的成绩，就先要在 names 中找到对应的位置，再从 scores 取出对应的成绩，Array 越长，耗时越长。 如果用 Map 实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用 JavaScript 写一个 Map 如下：","text":"Map 和 SetJavaScript 的默认对象表示方式{}可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对。 但是 JavaScript 的对象有个小问题，就是键必须是字符串。但实际上 Number 或者其他数据类型作为键也是非常合理的。 MapMap是一组键值对的结构，具有极快的查找速度。 举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array： 12var names = ['Michael', 'Bob', 'Tracy']var scores = [95, 75, 85] 给定一个名字，要查找对应的成绩，就先要在 names 中找到对应的位置，再从 scores 取出对应的成绩，Array 越长，耗时越长。 如果用 Map 实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用 JavaScript 写一个 Map 如下： 12var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]])m.get('Michael') // 95 初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法： 1234567var m = new Map() // 空Mapm.set('Adam', 67) // 添加新的key-valuem.set('Bob', 59)m.has('Adam') // 是否存在key 'Adam': truem.get('Adam') // 67m.delete('Adam') // 删除key 'Adam'm.get('Adam') // undefined 由于一个 key 只能对应一个 value，所以，多次对一个 key 放入 value，后面的值会把前面的值冲掉： 1234var m = new Map()m.set('Adam', 67)m.set('Adam', 88)m.get('Adam') // 88 SetSet和Map类似，也是一组 key 的集合，但不存储 value。由于 key 不能重复，所以，在Set中，没有重复的 key。 要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set： 12var s1 = new Set() // 空Setvar s2 = new Set([1, 2, 3]) // 含1, 2, 3 重复元素在Set中自动被过滤： 12var s = new Set([1, 2, 3, 3, '3'])s // Set &#123;1, 2, 3, \"3\"&#125; 注意数字3和字符串&#39;3&#39;是不同的元素。 通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果： 1234s.add(4)s // Set &#123;1, 2, 3, 4&#125;s.add(4)s // 仍然是 Set &#123;1, 2, 3, 4&#125; 通过delete(key)方法可以删除元素： 1234var s = new Set([1, 2, 3])s // Set &#123;1, 2, 3&#125;s.delete(3)s // Set &#123;1, 2&#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://weifo.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://weifo.github.io/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://weifo.github.io/tags/ES6/"}]},{"title":"ES6 - generator","slug":"es6-generator","date":"2020-01-20T03:24:35.000Z","updated":"2020-03-15T13:17:33.267Z","comments":false,"path":"2020/01/20/es6-generator/","link":"","permalink":"https://weifo.github.io/2020/01/20/es6-generator/","excerpt":"","text":"基本概念 Generator 函数是 ES6 提供的一种异步编程解决方案。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。 形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function 关键字与函数名之间有一个星号；二是，函数体内部使用 yield 表达式，定义不同的内部状态。 1234567891011121314151617181920212223242526// 该函数有三个状态：hello，world 和 return 语句（结束执行）function* helloWorldGenerator() &#123; yield 'hello' yield 'world' return 'ending'&#125;var hw = helloWorldGenerator()// 只有调用 next() 函数才会执行hw.next() // &#123; value: 'hello', done: false &#125;hw.next() // &#123; value: 'world', done: false &#125;hw.next() // &#123; value: 'ending', done: true &#125;hw.next() // &#123; value: undefined, done: true &#125;hw // &#123;&#125;// yield表达式如果用在另一个表达式之中，必须放在圆括号里面function* demo() &#123; console.log('Hello' + yield) // SyntaxError console.log('Hello' + yield 123) // SyntaxError console.log('Hello' + (yield)) // OK console.log('Hello' + (yield 123)) // OK&#125; Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象 总结一下： 调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。 以后，每次调用遍历器对象的 next 方法，就会返回一个有着 value 和 done 两个属性的对象。 value 属性表示当前的内部状态的值，是 yield 表达式后面那个表达式的值 done 属性是一个布尔值，表示是否遍历结束。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://weifo.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://weifo.github.io/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://weifo.github.io/tags/ES6/"}]},{"title":"ES6 - Class","slug":"es6-class","date":"2020-01-16T14:19:09.000Z","updated":"2020-03-15T13:17:25.963Z","comments":false,"path":"2020/01/16/es6-class/","link":"","permalink":"https://weifo.github.io/2020/01/16/es6-class/","excerpt":"简介JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。 12345678910function Point(x, y) &#123; this.x = x this.y = y&#125;Point.prototype.toString = function() &#123; return '(' + this.x + ', ' + this.y + ')'&#125;var p = new Point(1, 2) ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。 1234567891011//定义类class Point &#123; constructor(x, y) &#123; this.x = x // this 代表实例对象 this.y = y &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')' &#125;&#125;","text":"简介JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。 12345678910function Point(x, y) &#123; this.x = x this.y = y&#125;Point.prototype.toString = function() &#123; return '(' + this.x + ', ' + this.y + ')'&#125;var p = new Point(1, 2) ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。 1234567891011//定义类class Point &#123; constructor(x, y) &#123; this.x = x // this 代表实例对象 this.y = y &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')' &#125;&#125; constructor: 构造方法，类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。 一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。 this: 关键对象 定义“类”的方法的时候，前面不需要加上 function 这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 ES6 的类，完全可以看作构造函数的另一种写法。 12345678910111213141516class Point &#123; // ...&#125;typeof Point // \"function\" ==&gt; 类的数据类型就是函数Point === Point.prototype.constructor // true ==&gt; 类本身就指向构造函数// 定义与使用class Bar &#123; doStuff() &#123; console.log('stuff') &#125;&#125;var b = new Bar() // new 默认执行Bar类的 constructor 方法，该方法默认返回实例对象 即thisb.doStuff() // \"stuff\" 构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。 1234567891011121314151617181920class Point &#123; constructor() &#123; // ... &#125; toString() &#123; // ... &#125; toValue() &#123; // ... &#125;&#125;// 等同于Point.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;, toValue() &#123;&#125;&#125; 在类的实例上面调用方法，其实就是调用原型上的方法。 1234class B &#123;&#125;let b = new B()b.constructor === B.prototype.constructor // true 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign 方法可以很方便地一次向类添加多个方法。 123456789101112131415class Point &#123; constructor() &#123; // ... &#125;&#125;Object.assign(Point.prototype, &#123; toString() &#123;&#125;, toValue() &#123;&#125;&#125;)// prototype对象的constructor属性，直接指向“类”的本身，这与 ES5 的行为是一致的Point.prototype.constructor === Point // trueObject.keys(Point.prototype) // [] ==&gt; 类的内部所有定义的方法，都是不可枚举的（non-enumerable）这一点与 ES5 的行为不一致 类的属性名，可以采用表达式。 1234567891011let methodName = 'getArea'class Square &#123; constructor(length) &#123; // ... &#125; [methodName]() &#123; // ... &#125;&#125; 类的实例对象与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。 1234567891011121314151617181920//定义类class Point &#123; constructor(x, y) &#123; this.x = x this.y = y &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')' &#125;&#125;var point = new Point(2, 3)point.toString() // (2, 3)point.hasOwnProperty('x') // truepoint.hasOwnProperty('y') // truepoint.hasOwnProperty('toString') // falsepoint.__proto__.hasOwnProperty('toString') // true hasOwnProperty: 查找对象原型上是否有某属性 （上面代码表示 toString 保存在Point类中，point 是通过原型链获得 toString 方法） Class 表达式与函数一样，类也可以使用表达式的形式定义。 12345678910const MyClass = class Me &#123; getClassName() &#123; return Me.name // 内部可以使用到这个类Me &#125;&#125;// 这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类let inst = new MyClass()inst.getClassName() // MeMe.name // ReferenceError: Me is not defined 如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。 123const MyClass = class &#123; /* ... */&#125; 采用 Class 表达式，可以写出立即执行的 Class。 1234567891011let person = new class &#123; constructor(name) &#123; this.name = name &#125; sayName() &#123; console.log(this.name) &#125;&#125;('张三')person.sayName() // \"张三\" 私有方法和私有属性私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。 在命名上加以区别: 123456789101112131415lass Widget &#123; // 公有方法 foo (baz) &#123; this._bar(baz); &#125; // 私有方法 _bar(baz) &#123; return this.snaf = baz; &#125; // ...&#125;// 不保险的，在类的外部，还是可以调用到这个方法 将私有方法移出模块，因为模块内部的所有方法都是对外可见的: 1234567891011class Widget &#123; foo(baz) &#123; bar.call(this, baz) &#125; // ...&#125;function bar(baz) &#123; return (this.snaf = baz)&#125; 上面代码中，foo 是公有方法，内部调用了 bar.call(this, baz)。这使得 bar 实际上成为了当前模块的私有方法。 利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值: 1234567891011121314151617onst bar = Symbol('bar');const snaf = Symbol('snaf');export default class myClass&#123; // 公有方法 foo(baz) &#123; this[bar](baz); &#125; // 私有方法 [bar](baz) &#123; return this[snaf] = baz; &#125; // ...&#125;; 上面代码中，bar 和 snaf 都是 Symbol 值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。 this 的指向类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 123456789101112131415class Logger &#123; printName(name = 'there') &#123; // this 默认指向 Logger this.print(`Hello $&#123;name&#125;`) &#125; print(text) &#123; console.log(text) &#125;&#125;const logger = new Logger()const &#123; printName &#125; = loggerprintName() // TypeError: Cannot read property 'print' of undefined// this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。 解决办法 在构造方法中绑定this 1234567class Logger &#123; constructor() &#123; this.printName = this.printName.bind(this) &#125; // ...&#125; 箭头函数 12345678class Logger &#123; constructor() &#123; this.printName = (name = 'there') =&gt; &#123; this.print(`Hello $&#123;name&#125;`) &#125; &#125; // ...&#125; 使用Proxy，获取方法的时候，自动绑定this 12345678910111213141516171819unction selfish (target) &#123; const cache = new WeakMap(); const handler = &#123; get (target, key) &#123; const value = Reflect.get(target, key); if (typeof value !== 'function') &#123; return value; &#125; if (!cache.has(value)) &#123; cache.set(value, value.bind(target)); &#125; return cache.get(value); &#125; &#125;; const proxy = new Proxy(target, handler); return proxy;&#125;const logger = selfish(new Logger()); getter setter与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 12345678910111213141516171819class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return 'getter' &#125; set prop(value) &#123; console.log('setter: ' + value) &#125;&#125;let inst = new MyClass()inst.prop = 123// setter: 123inst.prop// 'getter' 存值函数和取值函数是设置在属性的 Descriptor 对象上的 Class 的 Generator 方法todo // 对 Generator 不熟悉，待下次理解了在写 Class 的静态方法静态方法：不会被实例继承，而是直接通过类来调用。 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用 1234567891011class Foo &#123; static classMethod() &#123; return 'hello' &#125;&#125;Foo.classMethod() // 'hello'var foo = new Foo()foo.classMethod()// TypeError: foo.classMethod is not a function 注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。 12345678910111213class Foo &#123; static bar() &#123; this.baz() &#125; static baz() &#123; console.log('hello') &#125; baz() &#123; console.log('world') &#125;&#125;Foo.bar() // hello 父类的静态方法，可以被子类继承。 123456789class Foo &#123; static classMethod() &#123; return 'hello' &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod() // 'hello' 静态方法也是可以从super对象上调用的 12345678910111213class Foo &#123; static classMethod() &#123; return 'hello' &#125;&#125;class Bar extends Foo &#123; static classMethod() &#123; return super.classMethod() + ', too' &#125;&#125;Bar.classMethod() // \"hello, too\" Class 的静态属性和实例属性静态属性：Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。 1234class Foo &#123;&#125;Foo.prop = 1Foo.prop // 1 ES6 明确规定，Class 内部只有静态方法，没有静态属性 写法无效如下： 12345678910// 以下两种写法都无效class Foo &#123; // 写法一 prop: 2 // 写法二 static prop: 2&#125;Foo.prop // undefined 类的实例属性类的实例属性可以用等式，写入类的定义之中 1234567class MyClass &#123; myProp = 42 constructor() &#123; console.log(this.myProp) // 42 &#125;&#125; 类的静态属性类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。 12345678class MyClass &#123; static myStaticProp = 42 constructor() &#123; console.log(MyClass.myStaticProp) // 42 &#125;&#125;var p = new MyClass() // p 中实例属性没有 myStaticProp","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://weifo.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://weifo.github.io/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://weifo.github.io/tags/ES6/"}]},{"title":"ES6 - async await","slug":"es6-async&await","date":"2020-01-12T04:02:26.000Z","updated":"2020-03-15T13:17:20.142Z","comments":false,"path":"2020/01/12/es6-async&await/","link":"","permalink":"https://weifo.github.io/2020/01/12/es6-async&await/","excerpt":"async 函数 async 函数是什么？一句话，它就是 Generator 函数的语法糖。async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已 12345678910111213141516171819function getSomething() &#123; return 'something'&#125;async function testAsync() &#123; return 'Hello async'&#125;async function test() &#123; const v1 = await getSomething() // 普通值 const v2 = await testAsync() // Promise对象 console.log(v1, v2)&#125;test() .then(() =&gt; &#123; console.log('调用该函数时，会立即返回一个Promise对象') &#125;) .catch(e =&gt; &#123;&#125;)","text":"async 函数 async 函数是什么？一句话，它就是 Generator 函数的语法糖。async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已 12345678910111213141516171819function getSomething() &#123; return 'something'&#125;async function testAsync() &#123; return 'Hello async'&#125;async function test() &#123; const v1 = await getSomething() // 普通值 const v2 = await testAsync() // Promise对象 console.log(v1, v2)&#125;test() .then(() =&gt; &#123; console.log('调用该函数时，会立即返回一个Promise对象') &#125;) .catch(e =&gt; &#123;&#125;) async 函数的实现原理async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。 1234567891011async function fn(args) &#123; // ...&#125;// 等同于function fn(args) &#123; return spawn(function*() &#123; // ... &#125;)&#125; 所有的 async 函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器。下面给出 spawn 函数的实现，基本就是前文自动执行器的翻版。 1234567891011121314151617181920function spawn(genF) &#123; return new Promise(function(resolve, reject) &#123; const gen = genF() let next function step(nextF) &#123; let next try &#123; next = nextF() &#125; catch (err) &#123; return reject(err) &#125; if (next.done) return resolve(next.value) Promise.resolve(next.value).then( v =&gt; step(() =&gt; gen.next(v)), e =&gt; gen.throw(e) ) &#125; step(() =&gt; gen.next(undefined)) &#125;)&#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://weifo.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://weifo.github.io/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://weifo.github.io/tags/ES6/"}]},{"title":"Vue 生命周期","slug":"vue-life-hooks","date":"2020-01-06T02:30:09.000Z","updated":"2020-03-15T13:18:37.747Z","comments":false,"path":"2020/01/06/vue-life-hooks/","link":"","permalink":"https://weifo.github.io/2020/01/06/vue-life-hooks/","excerpt":"","text":"生命周期钩子函数 解释： created阶段的ajax请求与mounted请求的区别：前者页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 单个组件生命周期 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 &lt;template&gt; &lt;div&gt; &lt;h3&gt;单组件&lt;/h3&gt; &lt;el-button @click=\"dataVar += 1\"&gt;更新 &#123;&#123;dataVar&#125;&#125;&lt;/el-button&gt; &lt;el-button @click=\"handleDestroy\"&gt;销毁&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; export default &#123; data() &#123; return &#123; dataVar: 1 &#125; &#125;, beforeCreate() &#123; this.compName = 'single' console.log(`--$&#123;this.compName&#125;--beforeCreate`) &#125;, created() &#123; console.log(`--$&#123;this.compName&#125;--created`) &#125;, beforeMount() &#123; console.log(`--$&#123;this.compName&#125;--beforeMount`) &#125;, mounted() &#123; console.log(`--$&#123;this.compName&#125;--mounted`) &#125;, beforeUpdate() &#123; console.log(`--$&#123;this.compName&#125;--beforeUpdate`) &#125;, updated() &#123; console.log(`--$&#123;this.compName&#125;--updated`) &#125;, beforeDestroy() &#123; console.log(`--$&#123;this.compName&#125;--beforeDestroy`) &#125;, destroyed() &#123; console.log(`--$&#123;this.compName&#125;--destroyed`) &#125;, methods: &#123; handleDestroy() &#123; this.$destroy() &#125; &#125;&#125;&lt;/script&gt; 总结： 初始化组件时，会执行beforeCreate/Created/beforeMount/mounted四个钩子函数 当改变data中定义的变量（响应式变量）时，会执行beforeUpdate/updated钩子函数 当切换组件（当前组件未缓存）时，会执行beforeDestory/destroyed钩子函数 初始化和销毁时的生命钩子函数均只会执行一次，beforeUpdate/updated可多次执行 父子组件生命周期","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://weifo.github.io/categories/Javascript/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://weifo.github.io/tags/Vue/"}]},{"title":"Sequelize - 使用 model 查询数据","slug":"copy","date":"2020-01-03T06:56:03.000Z","updated":"2020-03-15T13:17:06.140Z","comments":false,"path":"2020/01/03/copy/","link":"","permalink":"https://weifo.github.io/2020/01/03/copy/","excerpt":"","text":"Sequelize 中有两种查询：使用 Model（模型）中的方法查询和使用 sequelize.query() 进行基于 SQL 语句的原始查询。 下面是事先创建好的数据： 123456789101112mysql&gt; select * from users;+----+----------+------+------+-------+| id | name | age | sex | score |+----+----------+------+------+-------+| 1 | guodada0 | 15 | 0 | 60 || 2 | guodada1 | 16 | 1 | 80 || 3 | guodada2 | 17 | 0 | 55 || 4 | guodada3 | 18 | 1 | 87 || 5 | guodada4 | 19 | 0 | 73 || 6 | guodada5 | 20 | 1 | 22 |+----+----------+------+------+-------+6 rows in set (0.00 sec) findAll - 搜索数据库中的多个元素123456const result = await UserModel.findAll() // result 将是所有 UserModel 实例的数组// the same asconst result = await UserModel.all()//... 限制字段查询时，如果只需要查询模型的部分属性，可以在通过在查询选项中指定 attributes 实现。该选项是一个数组参数，在数组中指定要查询的属性即可，这些要查询的属性就表示要在数据库查询的字段： 123Model.findAll(&#123; attributes: ['foo', 'bar']&#125;) 字段重命名查询属性（字段）可以通过传入一个嵌套数据进行重命名： 12345Model.findAll(&#123; attributes: ['foo', ['bar', 'baz']]&#125;)// SELECT foo, bar AS baz ... demo 123456789const results = await UserModel.findAll(&#123; attributes: [['name', 'username'], 'age', 'score']&#125;)// [&#123;\"username\":\"guodada0\",\"age\":15,\"score\":60&#125;,&#123;\"username\":\"guodada1\",\"age\":16,\"score\":80&#125; ...]ctx.body = results// 访问查询结果 通过 instance.get('xxx')console.log(results[0]['username'], results[0].get('username')) // undefind, 'guodada0' 通过 sequelize.fn 方法进行聚合查询base demo123456789101112131415161718192021const UserModel = sequelize.define('user', &#123; name: Sequelize.STRING, age: Sequelize.INTEGER, sex: Sequelize.INTEGER, score: Sequelize.INTEGER&#125;)sequelize.sync().then(async () =&gt; &#123; try &#123; const results = await UserModel.findAll(&#123; attributes: ['name', 'age', 'score'] &#125;) results.map(user =&gt; &#123; console.log(user.name, user.age, user.score) // guodada0 15 60 | guodada1 16 80... &#125;) &#125; catch (err) &#123; console.log(err) &#125;&#125;)// SELECT `name`, `age`, `score` FROM `users` AS `user`; 通过 sequelize.fn 方法进行聚合查询123Model.findAll(&#123; attributes: [[sequelize.fn('COUNT', sequelize.col('hats')), 'no_hats']]&#125;) // SELECT COUNT(hats) AS no_hats ... 在使用聚合函数时，要给聚合字段指定一个别名。如，在上例中我们为聚合函数指定了别名&#39;no_hats&#39;，这样我们就能在查询的回调函数实例中通过 instance.get(&#39;no_hats&#39;)来访问聚合统计的结果。 demo 12345const results = await UserModel.findAll(&#123; attributes: [[sequelize.fn('SUM', sequelize.col('score')), 'scoreSum']]&#125;)console.log(results[0].get('scoreSum')) // 377 include/exclude当需要查询所有字段并对某一字段使用聚合查询时，而只需要以对象的形式传入 attributes 并添加 include 子属性即可。 1234567891011// 拽定全查询字段比较麻烦Model.findAll(&#123; attributes: ['id', 'foo', 'bar', 'baz', 'quz', [sequelize.fn('COUNT', sequelize.col('hats')), 'no_hats']]&#125;)// 这样会比较简短，且在你添加/删除属性后不会出错Model.findAll(&#123; attributes: &#123; include: [[sequelize.fn('COUNT', sequelize.col('hats')), 'no_hats']] &#125;&#125;)// SELECT id, foo, bar, baz, quz, COUNT(hats) AS no_hats ... 全部查询时，可以通过 exclude 子属性来排除不需要查询的字段： 12345Model.findAll(&#123; attributes: &#123; exclude: ['baz'] &#125;&#125;)// SELECT id, foo, bar, quz ... 通过 sequelize.fn 方法进行聚合查询","categories":[{"name":"Sequelize","slug":"Sequelize","permalink":"https://weifo.github.io/categories/Sequelize/"}],"tags":[{"name":"Sequelize","slug":"Sequelize","permalink":"https://weifo.github.io/tags/Sequelize/"}]},{"title":"随笔 - 如何用es6+写出优雅的js代码","slug":"随笔-如何用es6+写出优雅的js代码","date":"2019-12-12T01:59:21.000Z","updated":"2020-03-15T13:19:47.993Z","comments":false,"path":"2019/12/12/随笔-如何用es6+写出优雅的js代码/","link":"","permalink":"https://weifo.github.io/2019/12/12/随笔-如何用es6+写出优雅的js代码/","excerpt":"兼容 IE ？不存在的好吗。 其实使用新语法配合 babel 的转码，已经可以解决这一些问题了。既然如此，那就多使用新语法去探索一下怎么更好的去写代码吧。 下面分享个人开发中常用的 js 写法技巧，希望对各位有所帮助。 使用 let / constvar 命令会发生”变量提升“现象，即变量可以在声明之前使用，值为 undefined。这种现象多多少少是有些奇怪的。 个人认为，对声明的变量确定后面不会发生更改时，即使性能上没有太大提升差异在，但使用 const, 代码的可读性也会增强很多。 const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。 let 变量指向的内存地址，保存的只是一个指向实际数据的指针 补充 const 定义的变量不是数据不可变，而是保存的引用地址不能发生改变。例子如下： 1234const person = &#123; age: 22 &#125;person.age = 1console.log(person.age) // 1 详情看 let 和 const 命令","text":"兼容 IE ？不存在的好吗。 其实使用新语法配合 babel 的转码，已经可以解决这一些问题了。既然如此，那就多使用新语法去探索一下怎么更好的去写代码吧。 下面分享个人开发中常用的 js 写法技巧，希望对各位有所帮助。 使用 let / constvar 命令会发生”变量提升“现象，即变量可以在声明之前使用，值为 undefined。这种现象多多少少是有些奇怪的。 个人认为，对声明的变量确定后面不会发生更改时，即使性能上没有太大提升差异在，但使用 const, 代码的可读性也会增强很多。 const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。 let 变量指向的内存地址，保存的只是一个指向实际数据的指针 补充 const 定义的变量不是数据不可变，而是保存的引用地址不能发生改变。例子如下： 1234const person = &#123; age: 22 &#125;person.age = 1console.log(person.age) // 1 详情看 let 和 const 命令 解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 好处就是：解决了访问多层嵌套的对象或数组的命名，减少代码量 声明多个变量: 12let [age, name, sex] = [22, 'guodada', 1]console.log(age, name, sex) // 22, guodada, 1 使用在对象中： 123456789101112const obj = &#123; name: &#123; firstName: 'guo', lastName: 'dada' &#125;&#125;// 如果我们多处使用 firstName， 那就不必要每个地方都写 obj.name.firstName, 这样极大提升coding效率const &#123; firstName, lastName &#125; = obj.name// 等同于const firstName = obj.name.firstNameconst lastName = obj.name.lastName 使用在函数中: 1234567// 在参数中结构赋值，获取参数, 当参数多的使用时候十分方便function Destructuring(&#123; name, age &#125;) &#123; return &#123; name, age &#125; // 相当于 &#123; name: name, age: age &#125; , 可以简写&#125;const params = &#123; name: 'guodada', age: 22 &#125;Destructuring(params) 更多用法见 变量的解构赋值 ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。 12345678910function f(x, y) &#123; return &#123; x, y &#125;&#125;// 等同于function f(x, y) &#123; return &#123; x: x, y: y &#125;&#125;f(1, 2) // Object &#123;x: 1, y: 2&#125; 扩展符的运用es6 扩展符有很多用法，他可以使你的代码更加简洁，易懂。这里就举例常用的用法 在对象中的用法： 123456789101112131415let obj = &#123; name: 'guodada', age: 22, sex: 1&#125;// 复制对象。扩展符为浅复制！！！const copy = &#123; ...obj &#125;// 修改对象属性值(生成新对象) 相当于 Object.assgin(&#123;&#125;, obj, &#123; age: 18 &#125;)const newObj = &#123; ...obj, age: 18 &#125;// 结合结构赋值let &#123; sex, ...z &#125; = objz // &#123; name: 'guodada', age: 22 &#125; 在数组中的用法： 1234567891011121314const arr = [1, 2, 3]const arr2 = [4, 5, 6, 4]// 复制数组。扩展符为浅复制！！！const newArr = [...arr] // ...[1, 2, 3] =&gt; 相当于展开数组：1, 2, 3// 合并数组const conbineArr = [...arr, ...arr2]// 结合求最大值函数Math.max(...arr)// 结合 Set 实现数组去重。注意：json 等对象数组不可用[...new Set(arr2)] // [4, 5, 6] 扩展符的其他用法请自行查资料。 数组用法1234567891011121314const arr = [1, 2, 3, 4]Array.isArray(arr) // 判断是否为数组arr.includes(2) // true 判断数组中是否包含某项arr.findIndex(d =&gt; d === 3) // 2 找出第一个符合条件的数组成员并返回数组下标, 找不到返回 -1arr.find(d =&gt; d === 3) // 3 找出第一个符合条件的数组成员并返回, 找不到返回 undefined// es5 其他还有 filter map forEach 等，这里不做举例。arr.every(d =&gt; d &gt; 2) // false 每一项都满足条件则返回 truearr.some(d =&gt; d &gt; 2) // true 只要有一项满足条件则返回 true find/findIndex : 找出第一个符合条件的数组成员之后不再匹配，一定程度下优化查找。includes: 返回 true/false, 相较于 indexOf, 实用多了 flat() : 扁平化数组，常用于将数组转化为一维数组 12345678const arr = [1, 2, [3, 4]]arr.flat() // [1, 2, 3, 4] 扁平化数组, 默认展开一层。const arr2 = [1, 2, [3, 4, [5, 6]]]arr2.flat() // [1, 2, 3, 4, [5, 6]]arr2.flat(2) // [1, 2, 3, 4, 5, 6] flat(3) 也是展开两层... flatMap(): 在数组执行 map 方法后执行 flat, 用的不多，其实可以写 map 后写 flat 更好懂点。 123;[2, 3, 4].flatMap(x =&gt; [x, x * 2]) // [ 2, 4, 3, 6, 4, 8 ]// 1. [2, 3, 4].map(d =&gt; [d, d * 2]) =&gt; [[2, 4], [3, 6], [4, 8]]// 2. [[2, 4], [3, 6], [4, 8]].flat() 补充常用的对象转数组的用法： 12345const obj = &#123; name: 'guodada' &#125;Object.keys(obj) // ['name']Object.values(obj) // ['guodada']Object.entries(obj) // [['name', 'guodada']] 模板字符串用的挺多的，注意不兼容 IE ! 123456const name = 'guodada'const newStr = `welcome $&#123;name&#125;` // welcome guodada// the same asconst newStr = 'welcome ' + name 使用 async / awaitasync/await 实际上就是 generator 的语法糖, 主要用来解决异步问题，具体网上很多文章都有介绍，这里就不做多的解释吧。 123456789101112131415161718async function test() &#123; const data = await axios.get('https://randomuser.me/api/') console.log(data)&#125;// 等同于function test() &#123; axios.get('https://randomuser.me/api/').then(res =&gt; console.log(res)) // axios 也是 promise 对象&#125;// 结合try/catchasync function test() &#123; try &#123; const data = await axios.get('https://randomuser.me/api/') console.log(data) &#125; catch (err) &#123; console.log(err) &#125;&#125; ps 虽然好用，但是有时候适用场景不好，比如我们在拉取列表和用户信息需要同时进行时，await 后才执行下一条语句，这不是我们希望看到的。解决方法如下： 12// 结合 Promise.allawait Promise.all([anAsyncCall(), thisIsAlsoAsync(), oneMore()]) 传送门：async 函数 利用 class 封装代码主要是抽离代码逻辑，使得代复用性加强。同时，class 的形式会让结构变得更加清晰，譬如： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class MyForm &#123; /** * @func defaultLimit - 默认表单输入限制条件, value 为空时返回 true * @param &#123;Number&#125; type - 代表表单类型的节点！ * @param &#123;String&#125; value - 需要被验证的值 * @return Boolean * * 根据 type 属性对输出进行验证 * 1 0≤x≤50 整数 * 2 -1000≤x≤2000 整数 * 3 1≤x 整数 * 4 0≤x≤10 */ static defaultLimit(type, value) &#123; const typeLimitMap = &#123; 1: /^(\\d|[1-4]\\d|50)$/g, 2: /^-?(\\d&#123;1,3&#125;|1000)$|^(-|1\\d&#123;3&#125;|2000)$/, 3: /^[1-9]\\d*$/, 4: value =&gt; value &lt;= 10 &amp;&amp; value &gt;= 0 // 0≤ x ≤ 10 可以为小数 &#125; if (!typeLimitMap[type] || !value) return true if (typeof typeLimitMap[type] === 'function') return typeLimitMap[type](value) else return typeLimitMap[type].test(value) &#125; /** * @func translateLimit - 转换操作符 * @param &#123;String&#125; operator - 运算符 * @param &#123;*&#125; value - 被匹配的值 * @param &#123;*&#125; compareValue - 匹配的值 * @return Boolean * 'eq': '=' * 'ne': '≠' * 'gt': '&gt;' * 'lt': '&lt;' * 'ge': '≥' * 'le': '≤' */ static translateLimit(operator, value, compareValue) &#123; const type = &#123; eq: value === compareValue, ne: value !== compareValue, gt: value &gt; compareValue, lt: value &lt; compareValue, ge: value &gt;= compareValue, le: value &lt;= compareValue &#125; if (!Object.keys(type).includes(operator) || !value || value === '-') return true return type[operator] &#125; // ...&#125;export default MyForm 使用： 123import MyForm from './MyForm'MyForm.defaultLimit(1, 20) static ：静态属性，类可以直接调用 constructor : 实例化类的时候调用，即 new MyForm(), 这里没用到 更多知识请阅 Class 的基本语法 优化 if/else 语句 当逻辑或||时，找到为 true 的分项就停止处理，并返回该分项的值，否则执行完，并返回最后分项的值。 当逻辑与&amp;&amp;时，找到为 false 的分项就停止处理，并返回该分项的值。 12345const a = 0 || null || 3 || 4console.log(a) // 3const b = 3 &amp;&amp; 4 &amp;&amp; null &amp;&amp; 0console.log(b) // null 减少 if / else地狱般的调用 1234567891011121314151617const [age, name, sex] = [22, 'guodada', 1]if (age &gt; 10) &#123; if (name === 'guodada') &#123; if (sex &gt; 0) &#123; console.log('all right') &#125; &#125;&#125;// 使用 &amp;&amp;if (age &gt; 10 &amp;&amp; name === 'guodada' &amp;&amp; sex &gt; 0) &#123; console.log('all right')&#125;// 或者(太长了不推荐)age &gt; 10 &amp;&amp; name === 'guodada' &amp;&amp; sex &gt; 0 &amp;&amp; console.log('all right') 提一下 react 的坑点, 在 render 中 12345678910render()&#123; const arr = [] return arr.length &amp;&amp; null&#125;// 渲染出 0 ！// Boolean / undefind / null / NaN 等才不会渲染。我们可以使用 !! 强制转化为 boolean 解决这个问题return !!arr.length &amp;&amp; null// 使用 &amp;&amp; 控制组件的渲染this.state.visible &amp;&amp; &lt;Modal /&gt; 使用 Array.includes 来处理多重条件： 12345678910const ages = [18, 20, 12]if (age === 18 || age === 12) &#123; console.log('match')&#125;// betterif ([18, 12].includes(age)) &#123; console.log('match')&#125; 如果是较少的判断逻辑则可以使用三元运算符： 1234const age = 22const isAdult = age &gt;= 18 ? true : false // 这里可以简写为 const isAdult = age &gt; 18const type = age &gt;= 18 ? 'adult' : 'child' 优化 switch/case 语句switch/case 比 if/else 代码结构好点，但也和它一样有时十分冗长。 这里以自己实际项目中代码举例：有时我们可能需要对不同类型的字段进行不一样的正则验证，防止用户错误地输入。譬如 12345678910111213141516171819202122232425262728293031323334353637const [type, value] = [1, '20']/** * 根据 type 属性对输出进行验证 * 1 0≤x≤50 整数 * 2 -1000≤x≤2000 整数 * 3 1≤x 整数 */function func1(type, value) &#123; if (type === 1) &#123; return /^(\\d|[1-4]\\d|50)$/.test(value) &#125; else if (type === 2) &#123; return /^-?(\\d&#123;1,3&#125;|1000)$|^(-|1\\d&#123;3&#125;|2000)$/.test(value) &#125; else if (type === 3) &#123; return /^[1-9]\\d*$/.test(value) &#125; else &#123; return true &#125;&#125;func1(type, value)// 使用 switch/casefunction fun2(type, value) &#123; switch (type) &#123; case 1: return /^(\\d|[1-4]\\d|50)$/.test(value) case 2: return /^-?(\\d&#123;1,3&#125;|1000)$|^(-|1\\d&#123;3&#125;|2000)$/.test(value) case 3: return /^[1-9]\\d*$/.test(value) default: return true &#125;&#125;func2(type, value) 我们如何巧妙的解决这个代码冗长的问题呢，如下： 12345678function func3(type, value) &#123; const limitMap = &#123; 1: /^(\\d|[1-4]\\d|50)$/g, 2: /^-?(\\d&#123;1,3&#125;|1000)$|^(-|1\\d&#123;3&#125;|2000)$/, 3: /^[1-9]\\d*$/ &#125; return limitMap[type].test(value)&#125; 利用对象去匹配属性值，可以减少你的代码量，也使你的代码看起来更加简洁。你也可以使用 Map 对象去匹配。 12345function func4(type, value) &#123; const mapArr = [[1, /^(\\d|[1-4]\\d|50)$/g], [2, /^-?(\\d&#123;1,3&#125;|1000)$|^(-|1\\d&#123;3&#125;|2000)$/], [3, /^[1-9]\\d*$/]] const limitMap = new Map(mapArr) return limitMap.get(type).test(value)&#125; Map 是一种键值对的数据结构对象，它的匹配更加严格。它会区分开你传递的是字符串还是数字，譬如： 12limitMap.get(1) // /^(\\d|[1-4]\\d|50)$/glimitMap.get('1') // undefined 更多详见 Set 和 Map 数据结构 其他 函数参数默认值 12345function func(name, age = 22) &#123;&#125;// 等同于function func(name, age) &#123; age = age || 22&#125; 使用 === 代替 ==。其实大家都懂这个的。。。 箭头函数，es6 最常用的语法。 return boolean1234const a = 1return a === 1 ? true : false// 多此一举了，其实就等于return a === 1 敬请各位补充。交流才能进步，相视一笑，嘿嘿。 github - star 一下人生更美好 blog - 欢迎交流","categories":[{"name":"开发随笔","slug":"开发随笔","permalink":"https://weifo.github.io/categories/开发随笔/"}],"tags":[]},{"title":"五分钟了解(安装)typescript","slug":"ts_basic","date":"2019-11-14T15:05:08.000Z","updated":"2019-11-18T08:04:06.881Z","comments":false,"path":"2019/11/14/ts_basic/","link":"","permalink":"https://weifo.github.io/2019/11/14/ts_basic/","excerpt":"","text":"typescript的由来typescript是由微软的一个技术团队开发和维护的一个开源项目，之所以会推出这个项目是为了解决js的一个缺陷吧！由于Javascript是一种动态弱类型的语言，在测试和debug阶段会非常的痛苦，也是为了解决这一“痛点”，微软的VS code团队推出了typescript&ensp; (强弱/动态静态具体解释，click here!) 安装1npm install -g typescript 安装后即可通过 tsc -v 命令行来查看安装版本，如果提示tsc不是内部或外部命令的话，说明系统的环境变量没有配置，csdn上有相关的解决办法。 编译1tsc xxx.ts 编译后会在相同文件夹下生成同名的js文件，关于更加工程化地使用typescript可以参考官方文档 变量和函数声明与js语法相比，在所有的变量加上类型123456789101112131415let taylor:string='Taylor';let age:number=25;// 数组有两种定义方式let skills:string[]=['sing','gituar','writing'];let cats:Array&lt;string&gt;=['white','dog','miao'];// 函数声明function info(name:string,age:number):string&#123; let s:string=''; s=`He is $&#123;name&#125;,and he's $&#123;age&#125; years old`; return s;&#125;info('calvin harris',28) 接口和类123456789101112131415161718192021222324252627// 可选属性interface employee&#123; degree?:string, skilled?:boolean&#125;function test(config:employee):boolean&#123; if(config.skilled)&#123; return true &#125;else if(config.degree==='master')&#123; return true &#125;else&#123; return false &#125;&#125;let t1=test(&#123;degree:'master'&#125;)let t2=test(&#123;degree:'bachelor',skilled:'false'&#125;)let t3=test(&#123;skilled:'true'&#125;)console.log(t1,t2,t3)// 只读属性interface Point&#123; readonly x:number, readonly y:number&#125;let p1:Point=&#123;x:10,y:5&#125;p1.y=12// error","categories":[{"name":"技术","slug":"技术","permalink":"https://weifo.github.io/categories/技术/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://weifo.github.io/tags/前端/"}]},{"title":"包学不会的深拷贝与浅拷贝","slug":"deepclone","date":"2019-11-14T14:13:05.000Z","updated":"2019-11-30T05:40:26.649Z","comments":true,"path":"2019/11/14/deepclone/","link":"","permalink":"https://weifo.github.io/2019/11/14/deepclone/","excerpt":"","text":"深拷贝与浅拷贝的含义首先要知道在js的世界中，有两种类型的值，分别是基础类型和引用类型。基础类型包括string,number,boolean,Symbol,undefined,null,引用类型包括array,object等。 基本数据类型：直接存储在栈（stack）中的数据 引用数据类型：在栈中存放的是指针，真实的数据存放在堆中。 首先要分清拷贝和赋值的区别引用类型的赋值是直接赋值了一个指针，二者指向相同的数据内存。而拷贝是要创建一个新的对象/数组，如果只拷贝一层数据的话叫浅拷贝，如果拷贝多层数据叫深拷贝。 12345678910111213141516let obj=&#123; name:'Mike', age:36, hobby:['movies','music','running']&#125;// 这是赋值,任何一个都能操作共有的内存数据let obj1=obj;obj1.name='fred';obj1.hobby[1]='eat';console.log(obj,obj1)；// 这是浅拷贝,只能拷贝一层数据，当对象中有引用类型的value时，只会拷贝这个引用的指针let obj2=&#123;...obj&#125;;obj2.name='max';//不会改变源对象obj2.hobby[1]='sleep'; //会改变源对象console.log(obj,obj2) 如何实现浅拷贝数组的浅拷贝 slice方法 1234let arr=[1,5,9], arr1=arr.slice();arr1.push(11);console.log(arr,arr1) concat方法,当不给concat传参时，该方法和slice()作用相同 12let arr1=arr.concat();... spread操作符 123456let arr=[1,3,5,[8,9]];let arr1=[...arr];arr.push(15);console.log(arr,arr1);arr1[3].push(18);console.log(arr,arr1); 对象的浅拷贝 手动实现 12345678910function shallowCopy(src)&#123; var target=&#123;&#125;; for(let key in src)&#123; if(src.hasOwnProperty(key))&#123; target[key]=src[key]; &#125; &#125; return target&#125;// hasOwnProperty方法可以排除来自原型链上的属性 Object.assign() 1234let obj=&#123;a:&#123;name:'weifo',age:33&#125;&#125;;let copyobj=Object.assign(&#123;&#125;,obj);copyobj.a.name='curt';concole.log(obj.a.name);//curt spread 123let obj=&#123;name:'weifo',skill:['english','code']&#125;;let copyobj=&#123;...obj,name:'fred'&#125;;//&#123;name:'fred',skill:[...]&#125;//es6语法 深拷贝的实现 trick版 12345678910111213JSON.parse(JSON.stringify(obj))// 该方法的局限性：symbol，undefined，函数的属性值会被忽略，例子如下let syb=Symbol(12);let obj=&#123; name:'fred', say:function()&#123; alert('It wont alert'); &#125;, syb:syb， age:undefined&#125;let copy=JSON.parse(JSON.stringify(obj));console.log(copy);//&#123;name:'fred'&#125; 手动实现 12345678910111213141516171819function deepclone(src)&#123; if(typeof src==='object')&#123; let clone=Array.isArray(src)?[]:&#123;&#125;; for(let key in src)&#123; clone[key]=deepclone(src[key]); &#125; return clone &#125;else&#123; return src; &#125;&#125;let test=&#123; name:'fred', cities:['tokyo','paris','london']&#125;let clone=deepclone(test);clone.cities.push('rome');clone.name='weifo';console.log(test,clone) 解决循环引用上面的方法可以满足大部分的应用场景了，除了遇到对象引用自身的情况，如果采用上面的方法，会有爆栈的错误提示。 123456789const test=&#123; name:'weifo', field:[3,5,11], field1:&#123; child:'name' &#125;&#125;test.test=test;//循环引用deepclone(test)//RangeError 为了解决循环引用的问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝对象时，先去存储对象中找，找到的话直接返回，没有则继续拷贝。123456789101112131415function deepclone(target,map=new Map())&#123; if(typeof target==='object')&#123; let clone=Array.isArray(src)?[]:&#123;&#125;; if(map.get(target))&#123; return target &#125; map.set(target,clone); for(let key in target)&#123; clone[key]=clone(target[key],map); &#125; return clone &#125;else&#123; return target &#125;&#125; 使用lodash12345var _=require('lodash');var objects = [&#123; 'a': 1 &#125;, &#123; 'b': 2 &#125;]; var deep = _.cloneDeep(objects);console.log(deep[0] === objects[0]);//false","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://weifo.github.io/categories/前端开发/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://weifo.github.io/tags/javascript/"}]},{"title":"webpack-plugins","slug":"webpack-plugins","date":"2019-10-12T13:43:08.000Z","updated":"2020-03-15T13:18:52.020Z","comments":false,"path":"2019/10/12/webpack-plugins/","link":"","permalink":"https://weifo.github.io/2019/10/12/webpack-plugins/","excerpt":"功能类html-webpack-plugin 把编译后的文件（css/js）插入到入口文件中，可以只指定某些文件插入，可以对 html 进行压缩等 filename：输出文件名； template：模板文件，不局限于 html 后缀哦； removeComments：移除 HTML 中的注释； collapseWhitespace：删除空白符与换行符，整个文件会压成一行； inlineSource：插入到 html 的 css、js 文件都要内联，即不是以 link、script 的形式引入； inject：是否能注入内容到 输出 的页面去； chunks：指定插入某些模块； hash：每次会在插入的文件后面加上 hash ，用于处理缓存，如：；其他：favicon、meta、title ……；","text":"功能类html-webpack-plugin 把编译后的文件（css/js）插入到入口文件中，可以只指定某些文件插入，可以对 html 进行压缩等 filename：输出文件名； template：模板文件，不局限于 html 后缀哦； removeComments：移除 HTML 中的注释； collapseWhitespace：删除空白符与换行符，整个文件会压成一行； inlineSource：插入到 html 的 css、js 文件都要内联，即不是以 link、script 的形式引入； inject：是否能注入内容到 输出 的页面去； chunks：指定插入某些模块； hash：每次会在插入的文件后面加上 hash ，用于处理缓存，如：；其他：favicon、meta、title ……； 12345678910111213141516171819202122const path = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; mode: 'production', entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), // 输出文件的目录 filename: 'js/[name].[hash:8].js' // 打包路径及名称 &#125;, plugins: [ new HtmlWebpackPlugin(&#123; filename: 'index.html', // 生成文件名 template: './public/index.html', // 配置要被编译的html文件 hash: true, // 压缩HTML文件 minify: &#123; removeAttributeQuotes: true, //删除双引号 collapseWhitespace: true //折叠 html 为一行 &#125; &#125;) ]&#125; 传送门 ==&gt; html-webpack-plugin clean-webpack-plugin 在编译之前清理指定目录指定内容。 123456const CleanWebpackPlugin = require('clean-webpack-plugin')module.exports = &#123; plugins: [new CleanWebpackPlugin(['dist'])]&#125;// 指定清除哪些文件 new CleanWebpackPlugin(pathsToClean [, &#123;pathsToClean &#125;]) 详情请看 npm 传送门 ==&gt; clean-webpack-plugin copy-webpack-plugin12345const CopyWebpackPlugin = require('copy-webpack-plugin')module.exports = &#123; plugins: [new CopyWebpackPlugin([...patterns], options)]&#125; 传送门 ==&gt; copy-webpack-plugin compression-webpack-plugin 使用 compression-webpack-plugin 插件进行压缩，提供带 Content-Encoding 编码的压缩版的资源。 12345678910111213const CompressionPlugin = require('compression-webpack-plugin')module.exports = &#123; plugins: [ new CompressionPlugin(&#123; filename: '[path].gz[query]', //目标资源名称。[file] 会被替换成原资源。[path] 会被替换成原资源路径，[query] 替换成原查询字符串 algorithm: 'gzip', //算法 test: /\\.js(\\?.*)?$/i, //压缩 js deleteOriginalAssets: true, // 删除源文件 threshold: 10240, //只处理比这个值大的资源。按字节计算 minRatio: 0.8 //只有压缩率比这个值小的资源才会被处理 &#125;) ]&#125; 传送门 ==&gt; compression-webpack-plugin webpack-manifest-plugin 该插件可以显示出编译之前的文件和编译之后的文件的映射 1234const ManifestPlugin = require('webpack-manifest-plugin')module.exports = &#123; plugins: [new ManifestPlugin()]&#125; 传送门 ==&gt; webpack-manifest-plugin progress-bar-webpack-plugin 编译进度条插件 1234const ProgressBarPlugin = require('progress-bar-webpack-plugin') // 编译进度条插件module.exports = &#123; plugins: [new ProgressBarPlugin()]&#125; 传送门 ==&gt; progress-bar-webpack-plugin 代码相关webpack.ProvidePlugin 自动加载模块，而不必到处 import 或 require 。 1234567const webpack = require('webpack')module.exports = &#123; plugins: [new webpack.ProvidePlugin(&#123; $: 'jquery' &#125;)]&#125;// index.jsconsole.log($) 传送门 ==&gt; webpack.ProvidePlugin webpack.DefinePlugin DefinePlugin 允许创建一个在编译时可以配置的全局常量。这可能会对开发模式和发布模式的构建允许不同的行为非常有用。如果在开发构建中，而不在发布构建中执行日志记录，则可以使用全局常量来决定是否记录日志。这就是 DefinePlugin 的用处，设置它，就可以忘记开发和发布构建的规则。 12345678910module.exports = &#123; plugins: [ new webpack.DefinePlugin(&#123; PRODUCTION: JSON.stringify(true) &#125;) ]&#125;// index.jsconsole.log(PRODUCTION) // true 传送门 ==&gt; webpack.DefinePlugin mini-css-extract-pluginmini-css-extract-plugin，它默认就会对你的样式进行模块化拆分。相对 extract-text-webpack-plugin。 即 css 异步按需加载 1234567891011121314151617181920212223242526272829const MiniCssExtractPlugin = require('mini-css-extract-plugin') // 抽取 css 到独立文件module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.css$/, include: [path.resolve(__dirname, 'src')], use: [ &#123; loader: MiniCssExtractPlugin.loader, options: &#123; publicPath: '../' // chunk publicPath &#125; &#125;, 'css-loader' ] &#125; ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: 'css/[name].[hash:8].css', //这里配置跟output写法一致 chunkFilename: 'css/[id][chunkhash:8].css' &#125;) ]&#125; 传送门 ==&gt; mini-css-extract-plugin 编译结果优化类wbepack.IgnorePlugin防止在 import 或 require 调用时，生成以下正则表达式匹配的模块： requestRegExp 匹配(test)资源请求路径的正则表达式。 contextRegExp （可选）匹配(test)资源上下文（目录）的正则表达式。 moment 2.18 会将所有本地化内容和核心功能一起打包（见该 GitHub issue）。你可使用 IgnorePlugin 在打包时忽略本地化内容: 1new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/) 传送门 ==&gt; wbepack.IgnorePlugin uglifyjs-webpack-plugin js 代码压缩,默认会使用 optimization.minimizer， cache: Boolean/String ,字符串即是缓存文件存放的路径； test：正则表达式、字符串、数组都可以，用于只匹配某些文件，如：/.js(?.*)?\\$/i; parallel : 启用多线程并行运行来提高编译速度，经常编译的时候听到电脑跑的呼呼响，可能就是它干的，哈哈～； output.comments ： 删除所有注释， compress.warnings ：插件在进行删除一些无用代码的时候，不提示警告， compress.drop_console：喜欢打 console 的同学，它能自动帮你过滤掉，再也不用担心线上还打印日志了； 1234567891011121314151617181920212223242526const UglifyJsPlugin = require('uglifyjs-webpack-plugin')module.exports = &#123; optimization: &#123; minimizer: [ new UglifyJsPlugin(&#123; cache: true, // 开启缓存 parallel: true, // 开启多线程编译 sourceMap: true, // 是否sourceMap // 丑化参数 uglifyOptions: &#123; comments: false, warnings: false, compress: &#123; unused: true, dead_code: true, collapse_vars: true, reduce_vars: true &#125;, output: &#123; comments: false &#125; &#125; &#125;) ] &#125;&#125; 传送门 ==&gt; uglifyjs-webpack-plugin optimize-css-assets-webpack-plugin它的作用在于压缩 css 文件 assetNameRegExp：默认是全部的 css 都会压缩，该字段可以进行指定某些要处理的文件， cssProcessor：指定一个优化 css 的处理器，默认 cssnano， cssProcessorPluginOptions：cssProcessor 后面可以跟一个 process 方法，会返回一个 promise 对象，而 cssProcessorPluginOptions 就是一个 options 参数选项！ canPrint：布尔，是否要将编译的消息显示在控制台，没发现有什么用！ 坑点 ：建议使用高版本的包，之前低版本有遇到样式丢失把各浏览器前缀干掉的问题， 1234567891011const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin') // 丑化 cssmodule.exports = &#123; optimization: &#123; minimizer: [ new OptimizeCssAssetsPlugin(&#123; cssProcessor: require('cssnano'), // css 压缩优化器 cssProcessorOptions: &#123; discardComments: &#123; removeAll: true &#125; &#125; // 去除所有注释 &#125;) ] &#125;&#125; 传送门 ==&gt; optimize-css-assets-webpack-plugin SplitChunksPluginwebpack 把 chunk 分为两种类型，一种是初始加载 initial chunk，另外一种是异步加载 async chunk，如果不配置 SplitChunksPlugin，`webpack 会在 production 的模式下自动开启，默认情况下，webpack会将node_modules下的所有模块定义为异步加载模块，并分析你的entry、动态加载（import()、require.ensure）模块，找出这些模块之间共用的node_modules下的模块，并将这些模块提取到单独的chunk` 中，在需要的时候异步加载到页面当中，其中默认配置如下： 1234567891011121314151617181920212223242526module.exports = &#123; //... optimization: &#123; splitChunks: &#123; chunks: 'async', // 异步加载chunk minSize: 30000, maxSize: 0, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: '~', // 文件名中chunk分隔符 name: true, cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, // priority: -10 &#125;, default: &#123; minChunks: 2, // 最小的共享chunk数 priority: -20, reuseExistingChunk: true &#125; &#125; &#125; &#125;&#125; 传送门 ==&gt; SplitChunksPlugin webpack.HotModuleReplacementPlugin热更新, 配合 webpack-dev-server 使用 1yarn add webpack-dev-server -D 123456789101112131415161718new webpack.HotModuleReplacementPlugin()module.exports = &#123; devServer: &#123; port: 1234, open: true, // 自动打开浏览器 compress: true, // 服务器压缩 hot: true // 开启热加载 //... proxy、hot &#125;, plugins: [new webpack.HotModuleReplacementPlugin()]&#125;// index.jsif (module.hot) &#123; module.hot.accept()&#125; 传送门 ==&gt; devServer 传送门 ==&gt; webpack-dev-server 加快编译速度DllPlugin &amp;&amp; DllReferencePlugin &amp;&amp; autodll-webpack-pluginDllPlugin 和 DllReferencePlugin 提供分离包的方式可以大大提高构建时间性能。主要思想在于，将一些不做修改的依赖文件，提前打包，这样我们开发代码发布的时候就不需要再对这部分代码进行打包。从而节省了打包时间。 DllPlugin 插件：用于打包出一个个单独的动态链接库文件。DllReferencePlugin 插件：用于在主要配置文件中去引入 DllPlugin 插件打包好的动态链接库文件。 DllPlugin context (optional): manifest 文件中请求的上下文(context)(默认值为 webpack 的上下文(context)) name: 暴露出的 DLL 的函数名 (TemplatePaths: [hash] &amp; [name] ) path: manifest json 文件的绝对路径 (输出文件) DllReferencePlugin: 这个插件把只有 dll 的 bundle(们)(dll-only-bundle(s)) 引用到需要的预编译的依赖。 DllReferencePlugin context: (绝对路径) manifest (或者是内容属性)中请求的上下文 manifest: 包含 content 和 name 的对象，或者在编译时(compilation)的一个用于加载的 JSON manifest 绝对路径 content (optional): 请求到模块 id 的映射 (默认值为 manifest.content) name (optional): dll 暴露的地方的名称 (默认值为 manifest.name) (可参考 externals) scope (optional): dll 中内容的前缀 sourceType (optional): dll 是如何暴露的 (libraryTarget) 传送门 ==&gt; DllPlugin","categories":[{"name":"webpack","slug":"webpack","permalink":"https://weifo.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://weifo.github.io/tags/webpack/"}]},{"title":"webpack - 理论篇","slug":"webpack-theory","date":"2019-10-11T03:15:56.000Z","updated":"2020-03-15T13:18:57.339Z","comments":false,"path":"2019/10/11/webpack-theory/","link":"","permalink":"https://weifo.github.io/2019/10/11/webpack-theory/","excerpt":"entry123456789101112131415161718192021/** * @param &#123;String&#125; - String 时 打包为一个文件，默认包名 main.js * @param &#123;Array&#125; - Array 时 webpack会把数组里所有文件打包成一个js文件 * @param &#123;Object&#125; - Object 时 webpack会把对象里的文件分别打包成多个文件 * */module.exports = &#123; entry: './index.js', entry: ['./index.js', './about.js'], entry: &#123; app: './index.js', about: './about.js' &#125;, entry: &#123; app: './index.js', vendors: ['jquery'] // 分离第三方库 &#125;&#125;","text":"entry123456789101112131415161718192021/** * @param &#123;String&#125; - String 时 打包为一个文件，默认包名 main.js * @param &#123;Array&#125; - Array 时 webpack会把数组里所有文件打包成一个js文件 * @param &#123;Object&#125; - Object 时 webpack会把对象里的文件分别打包成多个文件 * */module.exports = &#123; entry: './index.js', entry: ['./index.js', './about.js'], entry: &#123; app: './index.js', about: './about.js' &#125;, entry: &#123; app: './index.js', vendors: ['jquery'] // 分离第三方库 &#125;&#125; vendors 第三方库// 待补充 output 指示 webpack 如何去输出、以及在哪里输出、输出的格式等 123456789module.exports = &#123; output: &#123; path: path.resolve(__dirname, 'dist'), // 输出文件的目录 filename: 'js/[name].[chunkhash:8].js', // 打包路径及名称 chunkFilename: 'js/[name].[chunkhash:8].js' // 按需加载 // publicPath：文件输出的公共路径， //... &#125;&#125; resolve 配置模块如何解析 extensions：自动解析确定的扩展,省去你引入组件时写后缀的麻烦， alias：非常重要的一个配置，它可以配置一些短路径， modules：webpack 解析模块时应该搜索的目录， … 123456789module.exports = &#123; resolve: &#123; extensions: ['.js', '.jsx', '.ts', '.tsx', '.scss', '.json', '.css'], alias: &#123; '@': path.resolve(__dirname, 'src') &#125;, modules: [path.resolve(__dirname, 'src'), 'node_modules'] &#125;&#125; module.rules rules：也就是之前的 loaders， test ： 正则表达式，匹配编译的文件， exclude：排除特定条件，如通常会写 node_modules，即把某些目录/文件过滤掉， include：它正好与 exclude 相反， use -loader ：必须要有它，它相当于是一个 test 匹配到的文件对应的解析器，babel-loader、style-loader、sass-loader、url-loader 等等， use - options：它与 loader 配合使用，可以是一个字符串或对象，它的配置可以直接简写在 loader 内一起，它下面还有 presets、plugins 等属性； plugins// 另一篇文章 webpack - plugins 篇 敬请期待 devtool 控制是否生成，以及如何生成 source map 文件，开发环境下更有利于定位问题，默认 false, 当然它的开启，也会影响编译的速度，所以生产环境一定一定记得关闭； 常用的值：cheap-eval-source-map、eval-source-map、cheap-module-eval-source-map、inline-cheap-module-source-map 等等 1devtool: 'eval-source-map' // 原始源代码 webpack-dev-server contentBase ：告诉服务(dev server)在哪里查找文件，默认不指定会在是当期项目根目录， historyApiFallback:可以是 boolean、 object，默认响应的入口文件，包括 404 都会指向这里，object 见下面示例： compress：启用 gzip 压缩， publicPath：它其实就是 output.publicPath，当你改变了它，即会覆盖了 output 的配置， stats： 可以自定控制要显示的编译细节信息， proxy：它其实就是 http-proxy-middleware，可以进行处理一些代理的请求。 123456789101112131415const webpack = require('webpack')module.exports = &#123; devServer: &#123; contentBase:'./assets', port: 1234, open: true, // 自动打开浏览器 compress: true // 服务器压缩 hot: true // 配合 HotModuleReplacementPlugin 使用 //... proxy、hot &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() ]&#125; optimization optimization 是 webpack4 新增的，主要是用来让开发者根据需要自定义一些优化构建打包的策略配置， minimize：true/false,告诉 webpack 是否开启代码最小化压缩， minimizer：自定 js 优化配置，会覆盖默认的配置，结合 UglifyJsPlugin 插件使用， removeEmptyChunks: bool 值，它检测并删除空的块。将设置为 false 将禁用此优化， nodeEnv：它并不是 node 里的环境变量，设置后可以在代码里使用 process.env.NODE_ENV === ‘development’来判断一些逻辑，生产环境 UglifyJsPlugin 会自动删除无用代码， splitChunks ：取代了 CommonsChunkPlugin，自动分包拆分、代码拆分，详细默认配置： 默认配置，只会作用于异步加载的代码块 —— chunks: ‘async’，它有三个值：all,async,initial 12345678910111213141516171819202122232425262728module.exports = &#123; // 优化构建打包的策略配置 optimization: &#123; minimize: true, // 是否开启代码最小化压缩 默认 false //splitChunks 默认配置 splitChunks: &#123; chunks: 'async', minSize: 30000, maxSize: 0, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: '~', name: true, cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true &#125; &#125; &#125; &#125;&#125; 配合 UglifyJsPlugin12345678910111213141516171819202122232425262728const UglifyJsPlugin = require('uglifyjs-webpack-plugin')module.exports = &#123; // 优化构建打包的策略配置 optimization: &#123; minimizer: [ new UglifyJsPlugin(&#123; cache: true, // 开启缓存 parallel: true, // 开启多线程编译 sourceMap: true, // 是否sourceMap uglifyOptions: &#123; // 丑化参数 comments: false, warnings: false, compress: &#123; unused: true, dead_code: true, collapse_vars: true, reduce_vars: true &#125;, output: &#123; comments: false &#125; &#125; &#125;) ] &#125;&#125; 参考 webpack4 配置详解之慢嚼细咽","categories":[{"name":"webpack","slug":"webpack","permalink":"https://weifo.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://weifo.github.io/tags/webpack/"}]},{"title":"webpack - 入门篇","slug":"webpack-入门","date":"2019-10-10T14:09:14.000Z","updated":"2020-03-15T13:19:10.088Z","comments":false,"path":"2019/10/10/webpack-入门/","link":"","permalink":"https://weifo.github.io/2019/10/10/webpack-入门/","excerpt":"什么是 webpackwebpack 可以看做是模块打包机：他做的事情是，分析你的项目结构，找到 JavaScript 模块以及其他的一些浏览器不能直接运行的扩展语言（Scss、TypeScript 等），将其打包为合适的格式以供浏览器使用 构建就是把源代码转换成发布到线上可执行的 JavaScript、CSS、HTML 代码，包括以下内容： 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等等 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载 模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件 自动刷新：监听本地源代码的变化，自动构建，刷新浏览器 代码校验：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。 构建其实是工程化、自动化思想在前端开发中的体现。把一系列流程用代码去实现，让代码自动化地执行这一系列复杂的流程。","text":"什么是 webpackwebpack 可以看做是模块打包机：他做的事情是，分析你的项目结构，找到 JavaScript 模块以及其他的一些浏览器不能直接运行的扩展语言（Scss、TypeScript 等），将其打包为合适的格式以供浏览器使用 构建就是把源代码转换成发布到线上可执行的 JavaScript、CSS、HTML 代码，包括以下内容： 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等等 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载 模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件 自动刷新：监听本地源代码的变化，自动构建，刷新浏览器 代码校验：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。 构建其实是工程化、自动化思想在前端开发中的体现。把一系列流程用代码去实现，让代码自动化地执行这一系列复杂的流程。 webpack 的基本概念 入口(entry point): 指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始，webpack 会找出有哪些模块和 library 是入口起点（直接和间接）依赖的。 默认值是 ./src/index.js，然而，可以通过在 webpack 配置中配置 entry 属性，来指定一个不同的入口起点（或者也可以指定多个入口起点）。 出口 output: 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，主输出文件默认为 ./dist/main.js，其他生成文件的默认输出目录是 ./dist loader: 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 注意，loader 能够 import 导入任何类型的模块（例如 .css 文件），这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是有很必要的，因为这可以使开发人员创建出更准确的依赖关系图。 插件 plugins: loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。 模式 mode: 通过选择 development 或 production 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化 webpack 构建过程 从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module。 每找到一个 Module， 就会根据配置的 Loader 去找出对应的转换规则。 对 Module 进行转换后，再解析出当前 Module 依赖的 Module。 这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。 最后 Webpack 会把所有 Chunk 转换成文件输出。 在整个流程中 Webpack 会在恰当的时机执行 Plugin 里定义的逻辑。 开发环境和生产环境我们在日常的前端开发工作中，一般都会有两套构建环境：一套开发时使用，一套供线上使用。 development: 用于开发的配置文件，用于定义 webpack dev server 和其他东西 production: 用于生产的配置文件，用于定义 UglifyJSPlugin，sourcemaps 等 简单来说，开发时可能需要打印 debug 信息，包含 sourcemap 文件，而生产环境是用于线上的即代码都是压缩后，运行时不打印 debug 信息等。譬如 axios、antd 等我们的生产环境中需要使用到那么我们应该安装该依赖在生产环境中，而 webpack-dev-server 则是需要安装在开发环境中 平时我们 npm 中安装的文件中有 -S -D, -D 表示我们的依赖是安装在开发环境的，而-S 的是安装依赖在生产环境中。 本文就来带你搭建基本的前端开发环境，前端开发环境需要什么呢？ 构建发布需要的 HTML、CSS、JS、图片等资源 使用 CSS 预处理器，这里使用 less 配置 babel 转码器 =&gt; 使用 es6+ 处理和压缩图片 配置热加载，HMR 以上配置就可以满足前端开发中需要的基本配置。下面是本文打包后的效果图： 搭建基本的开发环境安装123mkdir webpack-dev &amp;&amp; cd webpack-devnpm init -ynpm i webpack webpack-cli -D 添加 scripts生成了 package.json 文件，在文件中添加 123\"scripts\": &#123; \"build\": \"webpack --mode production\" &#125; –mode 模式 (必选，不然会有 WARNING)，是 webpack4 新增的参数选项，默认是 production --mode production 生产环境 提供 uglifyjs-webpack-plugin 代码压缩 不需要定义 new webpack.DefinePlugin({ &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;production&quot;) }) 默认 production 默认开启 NoEmitOnErrorsPlugin -&gt; optimization.noEmitOnErrors, 编译出错时跳过输出，以确保输出资源不包含错误 默认开启 ModuleConcatenationPlugin -&gt; optimization.concatenateModules, webpack3 添加的作用域提升(Scope Hoisting) --mode development 开发环境 使用 eval 构建 module, 提升增量构建速度 不需要定义 new webpack.DefinePlugin({ &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;development&quot;) }) 默认 development 默认开启 NamedModulesPlugin -&gt; optimization.namedModules 使用模块热替换(HMR)时会显示模块的相对路径 添加了 scripts 之后，新建src/index.js，然后执行npm run build ，你就会发现新增了一个 dist 目录，里边存放的是 webpack 构建好的 main.js 文件。 ps npm scripts 使用指南 新建 webpack.config.js 文件要想对 webpack 中增加更多的配置信息，我们需要建立一个 webpack 的配置文件。在根目录下创建 webpack.config.js 后再执行 webpack 命令，webpack 就会使用这个配置文件的配置了 配置中具备以下的基本信息： 12345678module.exports = &#123; entry: '', // 打包入口：指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始 output: '', // 出口 resolve: &#123;&#125;, // 配置解析：配置别名、extensions 自动解析确定的扩展等等 devServer: &#123;&#125;, // 开发服务器：run dev/start 的配置，如端口、proxy等 module: &#123;&#125;, // 模块配置：配置loader（处理非 JavaScript 文件，比如 less、sass、jsx、图片等等）等 plugins: [] // 插件的配置：打包优化、资源管理和注入环境变量&#125; 配置打包入口和出口首先我们往 webpack.config.js 添加点配置信息 123456789101112const path = require('path')module.exports = &#123; // 指定打包入口 entry: './src/index.js', // 打包出口 output: &#123; path: path.resolve(__dirname, 'dist'), // 解析路径为 ./dist filename: 'bundle.js' &#125;&#125; 上面我们定义了打包入口 ./src/index.js，打包出口为 ./dist, 打包的文件夹名字为bundle.js，执行npm run build命令后，index.js 文件会被打包为 bundle.js 文件。此时随便建立一个 html 文件引用这个bundle.js就可以看到你在index.js 写的代码了。 path.resolve([…paths]) 方法会把一个路径或路径片段的序列解析为一个绝对路径。 使用 html-webpack-plugin 创建 html 文件更多情况下我们不希望打包一次，就新建一次 html 文件来引用打包后的文件，这样显得不智能或者说当你打包的文件名修改后，引用路径就会出错。 这个时候我们就可以使用 html-webpack-plugin 插件来将 HTML 引用路径和我们的构建结果关联起来。 1npm install html-webpack-plugin -D 创建文件public/index.html 修改 webpack.config.js 文件 12345678910const HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; //... plugins: [ new HtmlWebpackPlugin(&#123; filename: 'index.html', // 配置输出文件名和路径 template: './public/index.html' // 配置要被编译的html文件 &#125;) ]&#125; 重新执行 npm run build, dist 目录就会多个 index.html 并引入了 bundle.js. 压缩 html 文件修改 webpack.config.js 12345678910111213141516const HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; //... plugins: [ new HtmlWebpackPlugin(&#123; filename: 'index.html', // 配置输出文件名和路径 template: './public/index.html', // 配置要被编译的html文件 hash: true, // 压缩 =&gt; production 模式使用 minify: &#123; removeAttributeQuotes: true, //删除双引号 collapseWhitespace: true //折叠 html 为一行 &#125; &#125;) ]&#125; 打包 css 文件我们希望使用 webpack 来进行构建 css 文件，，为此，需要在配置中引入 loader 来解析和处理 CSS 文件： 1npm install style-loader css-loader -D 新建 src/assets/style/color.css, 修改 webpack.config.js 文件： 123456789101112131415161718192021module.exports = &#123; //... module: &#123; /** * test: 匹配特定条件。一般是提供一个正则表达式或正则表达式的数组 * include: 匹配特定条件。一般是提供一个字符串或者字符串数组 * exclude: 排除特定条件 * and: 必须匹配数组中的所有条件 * or: 匹配数组中任何一个条件, * nor: 必须排除这个条件 */ rules: [ &#123; test: /\\.css$/, include: [path.resolve(__dirname, 'src')], use: ['style-loader', 'css-loader'] &#125; ] &#125; //...&#125; 经由上述两个 loader 的处理后，CSS 代码会转变为 JS， 如果需要单独把 CSS 文件分离出来，我们需要使用 mini-css-extract-plugin 插件 抽取 css 到独立文件, 自动添加前缀1npm i mini-css-extract-plugin postcss-loader autoprefixer -D 我们在写 css 时不免要考虑到浏览器兼容问题，如 transform 属性，需要添加浏览器前缀以适配其他浏览器。故使用到 postcss-loader 这个 loader， 下面则是相关的配置 webpack.config.js 123456789101112131415161718192021222324252627282930const MiniCssExtractPlugin = require('mini-css-extract-plugin')module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.css$/, include: [path.resolve(__dirname, 'src')], use: [ MiniCssExtractPlugin.loader, 'css-loader', &#123; loader: 'postcss-loader', options: &#123; plugins: [require('autoprefixer')] &#125; &#125; ] &#125; ] &#125;, plugins: [ //... new MiniCssExtractPlugin(&#123; filename: '[name].css', chunkFilename: '[id].css' &#125;) ]&#125; 打包 less 文件开发中通常会用到一门预处理语言，这里以less为例，通过less-loader可以打包 less 为 css 文件 1npm install less less-loader -D 新建 src/assets/style/index.less, 并且在 src/index.js 中引入 import &#39;./assets/style/index.less&#39; 配置 webpack.config.js 123456789101112131415161718192021222324const MiniCssExtractPlugin = require('mini-css-extract-plugin')module.exports = &#123; module: &#123; rules: [ // ... &#123; test: /\\.less$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', &#123; loader: 'postcss-loader', options: &#123; plugins: [require('autoprefixer')] // 添加css中的浏览器前缀 &#125; &#125;, 'less-loader' ] &#125; ] &#125; //...&#125; 执打包命令后就可以发现 index.less 中写的样式会和color.css一样被打包进 main.css中。 webpack@v4 升级踩坑: 关于使用 mini-css-extract-plugin 的注意点。 打包图片1npm install file-loader url-loader -D file-loader: 可以用于处理很多类型的文件，它的主要作用是直接输出文件，把构建后的文件路径返回。 url-loader:如果图片较多，会发很多 http 请求，会降低页面性能。url-loader 会将引入的图片编码，生成 dataURl。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此 url-loader 提供了一个 limit 参数，小于 limit 字节的文件会被转为 DataURl，大于 limit 的还会使用 file-loader 进行 copy。 url-loader 可以看作是增强版的 file-loader。 url-loader 把图片编码成 base64 格式写进页面，从而减少服务器请求。 1234567891011121314151617181920module.exports = &#123; module: &#123; rules: [ // ... &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: 'url-loader', options: &#123; outputPath: 'images/', //输出到images文件夹 limit: 500 //是把小于500B的文件打成Base64的格式，写入JS &#125; &#125; ] &#125; ] &#125; //...&#125; url-loader 和 file-loader 是什么关系呢？ 简单地说，url-loader 封装了 file-loader。url-loader 不依赖于 file-loader，即使用 url-loader 时，只需要安装 url-loader 即可，不需要安装 file-loader，因为 url-loader 内置了 file-loader。 通过上面的介绍，我们可以看到，url-loader 工作分两种情况： 文件大小小于 limit 参数，url-loader 将会把文件转为 DataURL； 文件大小大于 limit，url-loader 会调用 file-loader 进行处理，参数也会直接传给 file-loader。因此我们只需要安装 url-loader 即可。 有关 url-loader 和 file-loader 的解析：webpack 之图片引入-增强的 file-loader：url-loader 配置 babelbabel-loaderBabel 是一个让我们能够使用 ES 新特性的 JS 编译工具，我们可以在 webpack 中配置 Babel，以便使用 ES6、ES7 标准来编写 JS 代码。 Babel 7 的相关依赖包需要加上 @babel scope。一个主要变化是 presets 设置由原来的 env 换成了 @babel/preset-env, 可以配置 targets, useBuiltIns 等选项用于编译出兼容目标环境的代码。其中 useBuiltIns 如果设为 &quot;usage&quot;，Babel 会根据实际代码中使用的 ES6/ES7 代码，以及与你指定的 targets，按需引入对应的 polyfill，而无需在代码中直接引入 import &#39;@babel/polyfill&#39;，避免输出的包过大，同时又可以放心使用各种新语法特性。 1npm i babel-loader @babel/core @babel/preset-env -D 笔者这里配的版本号如下 12345&#123; \"babel-loader\": \"^8.0.4\", \"@babel/core\": \"^7.1.2\", \"@babel/preset-env\": \"^7.1.0\"&#125; babel-loader: 用 babel 转换 ES6 代码需要使用到 babel-loader @babel-preset-env： 默认情况下是等于 ES2015 + ES2016 + ES2017，也就是说它对这三个版本的 ES 语法进行转化。 @babel/core：babel 核心库 根目录下新建 .babelrc 文件 1234567891011121314&#123; \"presets\": [ [ \"@babel/preset-env\", &#123; \"modules\": false, \"targets\": &#123; \"browsers\": [\"&gt; 1%\", \"last 2 versions\", \"not ie &lt;= 8\"] &#125;, \"useBuiltIns\": \"usage\" &#125; ] ]&#125; presets 是一堆 plugins 的预设，起到方便的作用。 plugins 是编码转化工具，babel 会根据你配置的插件对代码进行相应的转化。 修改 webpack.config.js 1234567891011121314module.exports = &#123; module: &#123; rules: [ //... &#123; test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader' &#125; &#125; ] &#125;&#125; babel/polyfill 和 transform-runtime Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API ，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转码。 babel-polyfill: 如上述所说，对于新的 API，你可能需要引入 babel-polyfill 来进行兼容 关键点 babel-polyfill 是为了模拟一个完整的 ES2015+环境，旨在用于应用程序而不是库/工具。 babel-polyfill 会污染全局作用域 babel-runtime 的作用： 提取辅助函数。ES6 转码时，babel 会需要一些辅助函数，例如 _extend。babel 默认会将这些辅助函数内联到每一个 js 文件里， babel 提供了 transform-runtime 来将这些辅助函数“搬”到一个单独的模块 babel-runtime 中，这样做能减小项目文件的大小。 提供 polyfill：不会污染全局作用域，但是不支持实例方法如 Array.includes babel-runtime 更像是分散的 polyfill 模块，需要在各自的模块里单独引入，借助 transform-runtime 插件来自动化处理这一切，也就是说你不要在文件开头 import 相关的 polyfill，你只需使用，transform-runtime 会帮你引入。 对于开发应用来说，直接使用上述的按需 polyfill 方案是比较方便的，但如果是开发工具、库的话，这种方案未必适合（babel-polyfill 是通过向全局对象和内置对象的 prototype 上添加方法实现的，会造成全局变量污染）。Babel 提供了另外一种方案 transform-runtime，它在编译过程中只是将需要 polyfill 的代码引入了一个指向 core-js 中对应模块的链接(alias)。关于这两个方案的具体差异和选择，可以自行搜索相关教程，这里不再展开，下面提供一个 transform-runtime 的参考配置方案。 首先安装 runtime 相关依赖 12npm i @babel/plugin-transform-runtime -Dnpm i @babel/runtime -S 修改 .babelrc 1234&#123; //... \"plugins\": [\"@babel/plugin-transform-runtime\"]&#125; 打包前清理源目录文件 clean-webpack-plugin每次打包，都会生成项目的静态资源，随着某些文件的增删，我们的 dist 目录下可能产生一些不再使用的静态资源，webpack 并不会自动判断哪些是需要的资源，为了不让这些旧文件也部署到生产环境上占用空间，所以在 webpack 打包前最好能清理 dist 目录。 1npm install clean-webpack-plugin -D 修改 webpack.config.js 文件 1234const CleanWebpackPlugin = require('clean-webpack-plugin')module.exports = &#123; plugins: [new CleanWebpackPlugin(['dist'])]&#125; 提取公用代码假如你 a.js 和 b.js 都 import 了 c.js 文件，这段代码就冗杂了。为什么要提取公共代码，简单来说，就是减少代码冗余，提高加载速度。 12345678910111213141516171819202122232425262728293031module.exports = &#123; //... optimization: &#123; splitChunks: &#123; cacheGroups: &#123; commons: &#123; // 抽离自己写的公共代码 chunks: 'initial', name: 'common', // 打包后的文件名，任意命名 minChunks: 2, //最小引用2次 minSize: 0 // 只要超出0字节就生成一个新包 &#125;, styles: &#123; name: 'styles', // 抽离公用样式 test: /\\.css$/, chunks: 'all', minChunks: 2, enforce: true &#125;, vendor: &#123; // 抽离第三方插件 test: /node_modules/, // 指定是node_modules下的第三方包 chunks: 'initial', name: 'vendor', // 打包后的文件名，任意命名 // 设置优先级，防止和自定义的公共代码提取时被覆盖，不进行打包 priority: 10 &#125; &#125; &#125; &#125;&#125; hashhash 是干嘛用的？我们每次打包出来的结果可能都是同一个文件，那我上线的时候是不是要替换掉上线的 js，那我怎么知道哪是最新的呢，我们一般会清一下缓存。而 hash 就是为了解决这个问题而存在的 我们此时在改一些 webpack.config.js 的配置 1234567891011121314module.exports = &#123; //... output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].[hash:8].js' &#125;, //... plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name].[hash:8].css', chunkFilename: '[id].[hash:8].css' &#125;) ]&#125; 减少 resolve 的解析，配置别名如果我们可以精简 resolve 配置，让 webpack 在查询模块路径时尽可能快速地定位到需要的模块，不做额外的查询工作，那么 webpack 的构建速度也会快一些 123456789101112131415161718192021module.exports = &#123; resolve: &#123; /** * alias: 别名的配置 * * extensions: 自动解析确定的扩展, * 比如 import 'xxx/theme.css' 可以在extensions 中添加 '.css'， 引入方式则为 import 'xxx/theme' * @default ['.wasm', '.mjs', '.js', '.json'] * * modules 告诉 webpack 解析模块时应该搜索的目录 * 如果你想要添加一个目录到模块搜索目录，此目录优先于 node_modules/ 搜索 * 这样配置在某种程度上可以简化模块的查找，提升构建速度 @default node_modules 优先 */ alias: &#123; '@': path.resolve(__dirname, 'src'), tool$: path.resolve(__dirname, 'src/utils/tool.js') // 给定对象的键后的末尾添加 $，以表示精准匹配 &#125;, extensions: ['.wasm', '.mjs', '.js', '.json', '.jsx'], modules: [path.resolve(__dirname, 'src'), 'node_modules'] &#125;&#125; webpack-dev-serve上面讲到了都是如何打包文件，但是开发中我们需要一个本地服务，这时我们可以使用 webpack-dev-server 在本地开启一个简单的静态服务来进行开发。 webpack-dev-server 是 webpack 官方提供的一个工具，可以基于当前的 webpack 构建配置快速启动一个静态服务。当 mode 为 development 时，会具备 hot reload 的功能，即当源码文件变化时，会即时更新当前页面，以便你看到最新的效果。… 1npm install webpack-dev-server -D package.json 中 scripts 中添加 1&quot;start&quot;: &quot;webpack-dev-server --mode development&quot; 默认开启一个本地服务的窗口 http://localhost:8080/ 便于开发 配置开发服务器我们可以对 webpack-dev-server 做针对性的配置 123456789module.exports = &#123; // 配置开发服务器 devServer: &#123; port: 1234, open: true, // 自动打开浏览器 compress: true // 服务器压缩 //... proxy、hot &#125;&#125; contentBase: 服务器访问的根目录（可用于访问静态资源） port: 端口 open: 自动打开浏览器 模块热替换(hot module replacement)模块热替换(HMR - Hot Module Replacement)功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度： 保留在完全重新加载页面时丢失的应用程序状态。 只更新变更内容，以节省宝贵的开发时间。 调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。 上面我们 npm start 后修改一次文件，页面就会刷新一次。这样就存在很大问题了，比如我们使用 redux, vuex 等插件，页面一刷新那么存放在 redux, vuex 中的东西就会丢失，非常不利于我们的开发。 HMR 配合 webpack-dev-server ，首先我们配置下 webpack.config.js 123456789101112const webpack = require('webpack')module.exports = &#123; devServer: &#123; //... hot: true &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() //... ]&#125; 配置后还不行，因为 webpack 还不知道你要更新哪里, 修改 src/index.js 文件, 添加 123if (module.hot) &#123; module.hot.accept()&#125; 重启服务，npm start 之后，修改引入 index.js 文件后，页面就不会重新刷新了，这便实现了 HMR 但是但是有个问题是，你修改 css/less 等样式文件并未发生改变， what ? HMR 修改样式表 需要借助于 style-loader， 而我们之前用的是 MiniCssExtractPlugin.loader， 这也好办，修改其中一个 rules 就可以了，我们可以试试改 123456789101112131415161718192021module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.less$/, use: [ // MiniCssExtractPlugin.loader, 'style-loader', 'css-loader', &#123; loader: 'postcss-loader', options: &#123; plugins: [require('autoprefixer')] // 添加css中的浏览器前缀 &#125; &#125;, 'less-loader' ] &#125; ] &#125;&#125; 这样我们修改 less 文件就会发现 HMR 已经实现了。 其实，我们可以发现，dev 下配置的 loader 为 style-loader , 而生产环境下则是需要 MiniCssExtractPlugin.loader 这就涉及到了不同环境之间的配置。可以通过 process.env.NODE_ENV 获取当前是开发环境或者是生产环境，然后配置不同的 loader，这里就不做展开了。下一篇文章打算在做一个 react-cli 或者 vue-cli 的配置，将开发环境的配置与生产环境的配置分开为不同的文件。 结语前面讲到的知识都是 webpack 的一些基础的知识，更多的资料可以查询webpack 中文官网，官网讲的比较详细，我这里也是讲最常的配置，也是一篇入门系列的文章，文中涉及的知识点还有很多地方还需要完善，譬如 优化 webpack 的构建速度， 减小打包的体积等等。 学习 webpack 4.0 还需要多实践，多瞎搞，笔者也是刚刚学习 webpack 的配置，不对之处请各位指出。 下一篇文章打算从零配置一个脚手架，以加深自己对 webpack 的理解。 本文产生的代码：webpack-dev 参考 webpack4.x 入门一篇足矣 Webpack4 不深不浅的实践教程 webpack 之 babel 配置和 HMR 使用 webpack 4 和 Babel 7 配置 Vue.js 工程模板 webpack 4 ：从 0 配置到项目搭建 webpack 详解 手写一个 webpack4.0 配置 Webpack 4 教程：从零配置到生产发布（2018） Webpack 揭秘——走向高阶前端的必经之路 珠峰架构师培训公开课 webpack4.0 进阶 webpack 官网","categories":[{"name":"webpack","slug":"webpack","permalink":"https://weifo.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://weifo.github.io/tags/webpack/"}]},{"title":"面试题积累","slug":"随笔-面试","date":"2019-07-16T12:46:54.000Z","updated":"2020-03-15T13:19:30.476Z","comments":false,"path":"2019/07/16/随笔-面试/","link":"","permalink":"https://weifo.github.io/2019/07/16/随笔-面试/","excerpt":"Javascript正则 匹配整数 1234567var str = '102'// 1. ^(-|\\+) 以 - 或者 + 开头// 2. ? 表示出现或者不出现// 3. [1-9] 取值范围，也是首字符的取值范围// 4. \\d*$ ：* 等价于&#123;0,&#125;，表示出现任意次，有可能不出现。var reg = /^(-|\\+)?[1-9]\\d*$/reg.test(str) 用正则把[1,2,3,4]转换成 &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;","text":"Javascript正则 匹配整数 1234567var str = '102'// 1. ^(-|\\+) 以 - 或者 + 开头// 2. ? 表示出现或者不出现// 3. [1-9] 取值范围，也是首字符的取值范围// 4. \\d*$ ：* 等价于&#123;0,&#125;，表示出现任意次，有可能不出现。var reg = /^(-|\\+)?[1-9]\\d*$/reg.test(str) 用正则把[1,2,3,4]转换成 &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39; 1[1, 2, 3, 4].join().replace(/([^,])/g, \"'$1'\") // 逗号结尾的字符分组，加引号 dgfhfgh254bhku289fgdhdy675gfh 输出 [254,289,675] 12345var str = 'dgfhfgh254bhku289fgdhdy675gfh'str.replace(/\\d&#123;3&#125;/g, $1 =&gt; arr.push(+$1)) // 匹配出现3个数字的字符，+$1 转化为整数// question 假如要匹配连续出现的数字呢？ ↓↓↓str.replace(/\\d+/g, $1 =&gt; arr.push(+$1)) // + 匹配至少出现一次的数字 匹配数字范围 12// 限制 1000-2000，整数const reg = /^-?(?:[0-9]&#123;1,3&#125;|1000)$/ 字符串去重，把 aaacabbbccc 变成 abc 1234567var str = 'aaacabbbbcccc'var reg = /(.).*\\1/gstr.replace(reg, '$1')// \\1 表示的引用之前的那个分组 不管它匹配到什么（比如-），\\1都匹配那个同样的具体某个字符。var reg = /(\\w)\\1+/g // 匹配连续出现的字符 匹配一年中的 12 个月 123456var str = '12'var reg = /^(0?[1-9]|1[0-2])$/gconsole.log(reg.test(str))// 首位 0 时，第二位 1-9// 首位 1 时，第二位 0-2 理论补充 非捕获分组 ?: (?:)会作为匹配校验，并出现在匹配结果字符里面，但不作为子匹配返回。 12345var reg1 = /1(2)/var reg2 = /1(?:2)/'12'.match(reg1) // \"12\", \"2\"...'12'.match(reg2) // \"12\", ... 作用域， eventLoop，异步… 经典题 12345678910111213for (var i = 0; i &lt; 5; i++) &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, i * 1000)&#125; // 结果：每一秒输出一个5// settimeout 是异步, 每一秒在任务队列中添加任务。等主线执行完成后再执行任务队列里的任务var =&gt; let // 解决变量作用域// 为for循环头部的let不仅将i绑定到for循环快中，事实上它将其重新绑定到循环体的每一次迭代中，确保上一次迭代结束的值重新被赋值。// setTimeout里面的function()属于一个新的域，通过 var 定义的变量是无法传入到这个函数执行域中的，通过使用 let 来声明块变量，// 这时候变量就能作用于这个块，所以 function就能使用 i 这个变量了 this 的考察 123456789101112function f() &#123; y = function() &#123; x = 2 &#125; return function() &#123; var x = 3 y() console.log(this.x) &#125;.apply(this, arguments)&#125;f() // 2 变量提升 12345678910111213var a = 1function outer() &#123; var a = 2 function inner() &#123; a++ console.log(a) var a = 3 console.log(a) &#125; inner()&#125;outer() // NaN 3 其他 遍历 html 中所有 dom 节点，并计算 dom 节点数 12345678910111213141516var doms = []function getChildren(parent) &#123; if (parent.children.length &gt; 0) &#123; for (let i = 0; i &lt; parent.children.length; i++) &#123; getChildren(parent.children[i]) &#125; &#125; if (parent.nodeType === 1) &#123; // parent.nodeType === 1：节点是一个元素节点 doms.push(parent) &#125;&#125;getChildren(document)console.log(doms) 随机数 123var random = (m, n) =&gt; m + Math.floor(Math.random() * (n - m))random(1, 4) // 产生 1-4 之间的随机数 实现数组乱序 123456789101112function shuffle(array) &#123; let len = array.length let temp while (len) &#123; const i = Math.floor(Math.random() * len--) temp = array[len] array[len] = array[i] array[i] = temp &#125; return array&#125;shuffle([1, 3, 4, 5, 7])","categories":[{"name":"开发随笔","slug":"开发随笔","permalink":"https://weifo.github.io/categories/开发随笔/"}],"tags":[{"name":"面试系列","slug":"面试系列","permalink":"https://weifo.github.io/tags/面试系列/"}]},{"title":"js - 笔试题收集","slug":"随笔-面试2","date":"2019-07-11T11:57:47.000Z","updated":"2020-03-15T13:19:41.868Z","comments":false,"path":"2019/07/11/随笔-面试2/","link":"","permalink":"https://weifo.github.io/2019/07/11/随笔-面试2/","excerpt":"提取 get 请求参数有这样一个 URL：http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如`{a:&#39;1&#39;, b:’2’, c:’’, d:’xxx’, e:undefined}`。 12345678910111213141516171819let str = 'http://item.taobao.com/item.html?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e&amp;a=2'function test(str) &#123; let params = &#123;&#125; const paramsStr = str.replace(/.*\\?/, '') // 提取参数字符串 // [ 'a=1', 'b=2', 'c=', 'd=xxx', 'e' ] paramsStr.split('&amp;').forEach(v =&gt; &#123; d = v.split('=') // [a, 1] [b, 2] [c, ''] [d, xxx] [e] if (d[0] in params) &#123; Array.isArray(params[d[0]]) ? params[d[0]].push(d[1]) : (params[d[0]] = [params[d[0]], d[1]]) &#125; else &#123; params[d[0]] = d[1] &#125; &#125;) return params&#125;console.log(test(str)) // &#123; a: [ '1', '2' ], b: '2', c: '', d: 'xxx', e: undefined &#125; 数组降维","text":"提取 get 请求参数有这样一个 URL：http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如`{a:&#39;1&#39;, b:’2’, c:’’, d:’xxx’, e:undefined}`。 12345678910111213141516171819let str = 'http://item.taobao.com/item.html?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e&amp;a=2'function test(str) &#123; let params = &#123;&#125; const paramsStr = str.replace(/.*\\?/, '') // 提取参数字符串 // [ 'a=1', 'b=2', 'c=', 'd=xxx', 'e' ] paramsStr.split('&amp;').forEach(v =&gt; &#123; d = v.split('=') // [a, 1] [b, 2] [c, ''] [d, xxx] [e] if (d[0] in params) &#123; Array.isArray(params[d[0]]) ? params[d[0]].push(d[1]) : (params[d[0]] = [params[d[0]], d[1]]) &#125; else &#123; params[d[0]] = d[1] &#125; &#125;) return params&#125;console.log(test(str)) // &#123; a: [ '1', '2' ], b: '2', c: '', d: 'xxx', e: undefined &#125; 数组降维 可以使用 Array.prototype.flat() es6+ 123456let arr = [[1, 2], [3, 4]]let newArr = arr.flat() // [1, 2, 3, 4] 默认降维一层// 手写let newArr2 = Array.prototype.concat.apply([], arr) // [1, 2, 3, 4] js 计算 1234567891011121314const arr = [1, 8, 6, 2, 5, 4, 8, 3, 7]function maxArea(arr) &#123; let [start, area] = [0, 0] let end = arr.length - 1 while (start &lt; end) &#123; const h = Math.min(arr[start], arr[end]) const result = h * (end - start) area = result &gt; area ? result : area arr[start] &gt; arr[end] ? end-- : start++ &#125; return area&#125;console.log(maxArea(arr)) // 49 返回 1 到 400 所有自然数中一共出现过多少次“1”，如 1 到 21 一共出现过 13 次“1” 1234567let count = 0for (let num = 1; num &lt;= number; num++) &#123; ;`$&#123;num&#125;`.replace(/1/g, () =&gt; count++)&#125;console.log(count) // 180 正则给定字符串 str，检查其是否包含连续重复的字母（a-zA-Z），包含返回 true，否则返回 false 123456let str = 'adfdsaccsdd'function containsRepeatingLetter(str) &#123; return /([a-zA-Z])\\1/.test(str) // // \\1指代第一个括号的匹配项&#125;console.log(containsRepeatingLetter(str)) // true 在正则表达式中，利用()进行分组，使用斜杠加数字表示引用，\\1 就是引用第一个分组，\\2 就是引用第二个分组。将[a-zA-Z]做为一个分组，然后引用，就可以判断是否有连续重复的字母。 字符串转驼峰例如：border-bottom-color —-&gt; borderBottomColor 1234567891011let str = 'border-bottom-color'function toHump(params) &#123; let newStr = '' params.split('-').forEach((d, i) =&gt; &#123; newStr += i === 0 ? d : `$&#123;d.charAt(0).toUpperCase()&#125;$&#123;d.substring(1)&#125;` &#125;) return newStr&#125;console.log(toHump(str)) // borderBottomColor","categories":[{"name":"开发随笔","slug":"开发随笔","permalink":"https://weifo.github.io/categories/开发随笔/"}],"tags":[{"name":"面试系列","slug":"面试系列","permalink":"https://weifo.github.io/tags/面试系列/"}]},{"title":"页面重绘和回流以及优化","slug":"随笔-重排和重绘","date":"2019-07-10T12:51:52.000Z","updated":"2020-03-15T13:19:56.578Z","comments":false,"path":"2019/07/10/随笔-重排和重绘/","link":"","permalink":"https://weifo.github.io/2019/07/10/随笔-重排和重绘/","excerpt":"重绘 redraw &amp; 重排 reflow浏览器运行机制图： 浏览器的运行机制 1.构建DOM树（parse）： 渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node（包括js生成的标签）生成内容树（Content Tree/DOM Tree）； 2.构建渲染树（construct）：解析对应的CSS样式文件信息（包括js生成的样式和外部css文件），而这些文件信息以及HTML中可见的指令（如），构建渲染树（Rendering Tree/Frame Tree）； 3.布局渲染树（reflow/layout）：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标； 4.绘制渲染树（paint/repaint）：遍历渲染树，使用UI后端层来绘制每个节点。","text":"重绘 redraw &amp; 重排 reflow浏览器运行机制图： 浏览器的运行机制 1.构建DOM树（parse）： 渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node（包括js生成的标签）生成内容树（Content Tree/DOM Tree）； 2.构建渲染树（construct）：解析对应的CSS样式文件信息（包括js生成的样式和外部css文件），而这些文件信息以及HTML中可见的指令（如），构建渲染树（Rendering Tree/Frame Tree）； 3.布局渲染树（reflow/layout）：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标； 4.绘制渲染树（paint/repaint）：遍历渲染树，使用UI后端层来绘制每个节点。 重绘（repaint或redraw）当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。触发重绘的条件：改变元素外观属性。如：color，background-color等。 注意：table及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用table布局页面的原因之一。 重排（重构/回流/reflow）当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。所以，重排必定会引发重绘，但重绘不一定会引发重排。触发重排的条件：任何页面布局和几何属性的改变都会触发重排，比如： 页面渲染初始化；(无法避免) 添加或删除可见的DOM元素； 元素位置的改变，或者使用动画； 元素尺寸的改变——大小，外边距，边框； 浏览器窗口尺寸的变化（resize事件发生时）； 填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变； 读取某些元素属性：（offsetLeft/Top/Height/Width, clientTop/Left/Width/Height, scrollTop/Left/Width/Height, width/height, getComputedStyle(), currentStyle(IE) ) 重绘重排的代价：耗时，导致浏览器卡慢。 优化 浏览器自己的优化：浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。 我们要注意的优化：我们要减少重绘和重排就是要减少对渲染树的操作，则我们可以合并多次的DOM和样式的修改。并减少对style样式的请求。 直接改变元素的className display：none；先设置元素为display：none；然后进行页面布局等操作；设置完成后将元素设置为display：block；这样的话就只引发两次重绘和重排； 不要经常访问浏览器的flush队列属性；如果一定要访问，可以利用缓存。将访问的值存储起来，接下来使用就不会再引发回流； 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘； 将需要多次重排的元素，position属性设为absolute或fixed，元素脱离了文档流，它的变化不会影响到其他元素； 如果需要创建多个DOM节点，可以使用DocumentFragment创建完后一次性的加入document； 尽量不要使用table布局。","categories":[{"name":"开发随笔","slug":"开发随笔","permalink":"https://weifo.github.io/categories/开发随笔/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"https://weifo.github.io/tags/DOM/"}]},{"title":"HTTP - TCP 三次握手四次挥手","slug":"http-TCP","date":"2018-11-21T01:47:17.000Z","updated":"2020-03-15T13:18:03.619Z","comments":false,"path":"2018/11/21/http-TCP/","link":"","permalink":"https://weifo.github.io/2018/11/21/http-TCP/","excerpt":"TCP 的三次握手 HTTP 请求与 TCP 链接之间的关系，在客户端向服务端请求和返回的过程中，是需要去创建一个 TCP connection，因为 HTTP 是不存在链接这样一个概念的，它只有请求和响应这样一个概念，请求和响应都是一个数据包，中间要通过一个传输通道，这个传输通道就是在 TCP 里面创建了一个从客户端发起和服务端接收的一个链接，TCP 链接在创建的时候是有一个三次握手(三次网络传输)这样一个消耗在的。 下面是 TCP 报文格式图： ↓↓↓↓ 有几个字段需要重点介绍下： Seq 序号: sequeence number，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。 确认序号：acknowledgment number，只有 ACK 标志位为 1 时，确认序号字段才有效，Ack=Seq+1。 标志位：共 6 个，即 URG、ACK、PSH、RST、SYN、FIN 等，具体含义如下： URG：紧急指针（urgent pointer）有效。 ACK：确认序号有效。 PSH：接收方应该尽快将这个报文交给应用层。 RST：重置连接。 SYN：发起一个新连接。 FIN：释放一个连接。","text":"TCP 的三次握手 HTTP 请求与 TCP 链接之间的关系，在客户端向服务端请求和返回的过程中，是需要去创建一个 TCP connection，因为 HTTP 是不存在链接这样一个概念的，它只有请求和响应这样一个概念，请求和响应都是一个数据包，中间要通过一个传输通道，这个传输通道就是在 TCP 里面创建了一个从客户端发起和服务端接收的一个链接，TCP 链接在创建的时候是有一个三次握手(三次网络传输)这样一个消耗在的。 下面是 TCP 报文格式图： ↓↓↓↓ 有几个字段需要重点介绍下： Seq 序号: sequeence number，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。 确认序号：acknowledgment number，只有 ACK 标志位为 1 时，确认序号字段才有效，Ack=Seq+1。 标志位：共 6 个，即 URG、ACK、PSH、RST、SYN、FIN 等，具体含义如下： URG：紧急指针（urgent pointer）有效。 ACK：确认序号有效。 PSH：接收方应该尽快将这个报文交给应用层。 RST：重置连接。 SYN：发起一个新连接。 FIN：释放一个连接。 第一次握手 客户端发送一个 TCP 的 SYN 标志位置 1 的包指明客户打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。 简单记忆： 建立连接，等待服务器确认 Sequeence Number = X =&gt; 标识字节流字段为 X SYN = 1 =&gt; 发起一个新连接，序号为 1 第二次握手 服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为 1 同时，将确认序号(Acknowledgement Number)设置为客户的 I S N 加 1 以.即 X+1。 简单记忆： 服务器收到请求后确认联机 Sequeence Number = Y =&gt; 标识字节流字段为 Y acknowledgment number = X + 1 =&gt; 确认序号为 X + 1 SYN = 1 =&gt; 发起一个新连接，序号为 1 ACK = 1 =&gt; 确认序号有效 第三次握手 客户端再次发送确认包(ACK)SYN 标志位为 0,ACK 标志位为 1.并且把服务器发来 ACK 的序号字段+1,放在确定字段中发送给对方.并且在数据段放写 ISN 的+1 简单记忆：检查 ACK 是否正确, 若正确则建立连接。 acknowledgment number = Y + 1 =&gt; 确认序号为 Y + 1 ACK = 1 =&gt; 确认序号有效 TCP 四次挥手TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close()操作即可产生挥手操作。 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？这是因为服务端在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。而关闭连接时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即 close，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送。","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://weifo.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://weifo.github.io/tags/HTTP/"}]},{"title":"webpack - babel篇","slug":"webpack-babel","date":"2018-10-01T06:23:24.000Z","updated":"2020-03-15T13:18:45.820Z","comments":false,"path":"2018/10/01/webpack-babel/","link":"","permalink":"https://weifo.github.io/2018/10/01/webpack-babel/","excerpt":"Babel 是一个让我们能够使用 ES 新特性的 JS 编译工具，我们可以在 webpack 中配置 Babel，以便使用 ES6、ES7 标准来编写 JS 代码。 本文以当前最新版本的 babel - 7.10 为例， 做 babel 的配置. 相关版本号如下 123456789101112&#123; \"devDependencies\": &#123; \"@babel/core\": \"^7.1.6\", \"@babel/plugin-proposal-decorators\": \"^7.1.6\", \"@babel/plugin-transform-runtime\": \"^7.1.0\", \"@babel/preset-env\": \"^7.1.6\", \"@babel/runtime\": \"^7.1.5\", \"babel-loader\": \"^8.0.4\", \"webpack\": \"^4.26.1\", \"webpack-cli\": \"^3.1.2\" &#125;&#125;","text":"Babel 是一个让我们能够使用 ES 新特性的 JS 编译工具，我们可以在 webpack 中配置 Babel，以便使用 ES6、ES7 标准来编写 JS 代码。 本文以当前最新版本的 babel - 7.10 为例， 做 babel 的配置. 相关版本号如下 123456789101112&#123; \"devDependencies\": &#123; \"@babel/core\": \"^7.1.6\", \"@babel/plugin-proposal-decorators\": \"^7.1.6\", \"@babel/plugin-transform-runtime\": \"^7.1.0\", \"@babel/preset-env\": \"^7.1.6\", \"@babel/runtime\": \"^7.1.5\", \"babel-loader\": \"^8.0.4\", \"webpack\": \"^4.26.1\", \"webpack-cli\": \"^3.1.2\" &#125;&#125; babel-loader 和 @babel/core建立基本的 webpack 配置文件 1234567891011mkdir webpack-babel =&gt; cd webpack-babel =&gt; yarn init -y // 初始化npm i yarn -g // 安装了yarn可以忽略yarn add webpack webpack-cli -D// package.json 中添加：\"scripts\": &#123; \"start\": \"webpack --mode development\", \"build\": \"webpack --mode production\"&#125;yarn add babel-loader @babel/core -D yarn : 和 npm 几乎一样，本文使用 yarn 安装… babel-loader: 转义 js 文件代码的 loader @babel/core：babel 核心库 根目录下添加 webpack.config.js 123456789101112131415161718const path = require('path')module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].[hash:8].js' &#125;, module: &#123; rules: [ &#123; test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader' &#125; // options 在 .babelrc 定义 &#125; ] &#125;&#125; src/index.js 123456789101112const func = () =&gt; &#123; console.log('hello webpack')&#125;func()class User &#123; constructor() &#123; console.log('new User') &#125;&#125;const user = new User() 执行 yarn build 后就可以打包成功，打包后的代码是压缩后的。而 yarn start 后的代码是未压缩的。为了使代码可读性高一点，我们可以在webpack.config.js添加： 1234module.exports = &#123; //... devtool: true&#125; @babel-preset-env打包后我们可以发现箭头函数并未转化为 ES5 语法！ 查阅 babel plugins 文档，如果要转义箭头函数，需要使用到 @babel/plugin-transform-arrow-functions 这个插件同理转义 class 需要使用 @babel/plugin-transform-classes 1yarn add @babel/plugin-transform-arrow-functions @babel/plugin-transform-classes -D 根目录下建立 .babelrc 文件： 123456&#123; \"plugins\": [ \"@babel/plugin-transform-arrow-functions\", \"@babel/plugin-transform-classes\" ]&#125; yarn build 之后可以看出 箭头函数和类都被转义了。 但是假如你再使用 async await 之类的 es6 语法，你还得一个个添加，这是不实际的。 @babel-preset-env 就整合了这些语法转义插件： 123456789Using plugins:transform-template-literals &#123;&#125;transform-literals &#123;&#125;transform-function-name &#123;&#125;transform-arrow-functions &#123;&#125;transform-block-scoped-functions &#123;&#125;transform-classes &#123;&#125;transform-object-super &#123;&#125;//... 使用如下： 1yarn add @babel-preset-env -D .babelrc 123&#123; \"presets\": [\"@babel/preset-env\"]&#125; @babel/polyfill Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API ，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转码。 这样就导致了一些新的 API 老版浏览器不兼容。如上述所说，对于新的 API，你可能需要引入 @babel-polyfill 来进行兼容 1yarn add @babel-polyfill -D 修改 weboack.config.js 123module.exports = &#123; entry: ['@babel-polyfill', './src/index.js']&#125; yarn build 发现文件体积大了很多，因为上面的代码表示将 @babel-polyfill 的代码也打包进去了。 当然这不是我们希望的，如何按需编译呢？ 我们可以这么做： index.js 123456789101112131415161718import '@babel/polyfill' // 引入const func = () =&gt; &#123; console.log('hello webpack')&#125;func()class User &#123; constructor() &#123; console.log('new User') &#125;&#125;const user = new User()new Promise(resolve =&gt; console.log('promise'))Array.from('foo') 还原 webpack.config.js 123module.exports = &#123; entry: './src/index.js'&#125; 修改 .babelrc 123&#123; \"presets\": [[\"@babel/preset-env\", &#123; \"useBuiltIns\": \"usage\" &#125;]]&#125; yarn build 后发现我们的代码体积就变得很小了！ @babel/runtime 和 @babel/plugin-transform-runtime babel-polyfill 会污染全局作用域, 如引入 Array.prototype.includes 修改了 Array 的原型，除此外还有 String… babel-polyfill 引入新的对象： Promise、WeakMap 等 这也不是我们希望出现的。 @babel/runtime 的作用： 提取辅助函数。ES6 转码时，babel 会需要一些辅助函数，例如 _extend。babel 默认会将这些辅助函数内联到每一个 js 文件里， babel 提供了 transform-runtime 来将这些辅助函数“搬”到一个单独的模块 babel-runtime 中，这样做能减小项目文件的大小。 提供 polyfill：不会污染全局作用域，但是不支持实例方法如 Array.includes @transform-runtime 的作用： babel-runtime 更像是分散的 polyfill 模块，需要在各自的模块里单独引入，借助 transform-runtime 插件来自动化处理这一切，也就是说你不要在文件开头 import 相关的 polyfill，你只需使用，transform-runtime 会帮你引入。 12yarn add @babel/runtime-corejs2yarn add @babel/plugin-transform-runtime -D 修改 .babelrc 1234&#123; \"presets\": [\"@babel/preset-env\"], \"plugins\": [[\"@babel/plugin-transform-runtime\", &#123; \"corejs\": 2 &#125;]]&#125; index.js 移除 import &#39;@babel/polyfill&#39; @babel/plugin-proposal-decorators添加装饰器模式的支持 1yarn add @babel/plugin-proposal-decorators -D index.js 1234567891011function annotation(target) &#123; target.annotated = true&#125;@annotationclass User &#123; constructor() &#123; console.log('new User') &#125;&#125;//... .babelrc 1234567&#123; \"presets\": [\"@babel/preset-env\"], \"plugins\": [ [\"@babel/plugin-proposal-decorators\", &#123; \"decoratorsBeforeExport\": true &#125;], [\"@babel/plugin-transform-runtime\", &#123; \"corejs\": 2 &#125;] ]&#125;","categories":[{"name":"webpack","slug":"webpack","permalink":"https://weifo.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://weifo.github.io/tags/webpack/"}]}]}