{"meta":{"title":"weifo","subtitle":"选择你所爱的，爱你所选择的","description":"电音爱好者","author":"weifo","url":"https://weifo.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-11-11T15:42:38.854Z","updated":"2019-11-11T15:42:38.854Z","comments":false,"path":"/404.html","permalink":"https://weifo.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2019-11-11T15:42:16.369Z","updated":"2019-11-11T15:42:16.369Z","comments":false,"path":"about/index.html","permalink":"https://weifo.github.io/about/index.html","excerpt":"","text":"12345678910111213141516171819202122232425&#123; name: 'weifo', age: '22', sex: '男'， experience: '2018-01-01 至今', education: '本科', email: 'mwfherotic@163.com', github: 'https://github.com/weifo', blog: 'weifo.github.blog', description: '踌躇满志又不知所措', character: '拖延症 好吃懒做', skills: [ ['html', 'css', 'Javascript','ES6', 'Node','python'], ['webpack'], ['git'], ['eslint'], ['React技术栈','bootstrap','vue'] ], devTools: [ ['Visual Studio Code', 'Webstorm', 'Sublime Text'], ['Chrome DevTools'] ]&#125; blog1hexo + github Pages"},{"title":"书单","date":"2019-11-09T17:46:22.311Z","updated":"2019-03-18T15:39:40.000Z","comments":false,"path":"books/index.html","permalink":"https://weifo.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-11-09T17:46:22.316Z","updated":"2019-03-18T15:39:40.000Z","comments":false,"path":"categories/index.html","permalink":"https://weifo.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-11-09T17:46:22.321Z","updated":"2019-03-18T15:39:40.000Z","comments":false,"path":"repository/index.html","permalink":"https://weifo.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-11-06T08:15:28.000Z","updated":"2019-03-18T15:39:40.000Z","comments":true,"path":"tags/index.html","permalink":"https://weifo.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"随笔 - 如何用es6+写出优雅的js代码","slug":"随笔-如何用es6+写出优雅的js代码","date":"2019-12-12T01:59:21.000Z","updated":"2020-02-16T13:23:34.829Z","comments":true,"path":"2019/12/12/随笔-如何用es6+写出优雅的js代码/","link":"","permalink":"https://weifo.github.io/2019/12/12/随笔-如何用es6+写出优雅的js代码/","excerpt":"兼容 IE ？不存在的好吗。 其实使用新语法配合 babel 的转码，已经可以解决这一些问题了。既然如此，那就多使用新语法去探索一下怎么更好的去写代码吧。 下面分享个人开发中常用的 js 写法技巧，希望对各位有所帮助。 使用 let / constvar 命令会发生”变量提升“现象，即变量可以在声明之前使用，值为 undefined。这种现象多多少少是有些奇怪的。 个人认为，对声明的变量确定后面不会发生更改时，即使性能上没有太大提升差异在，但使用 const, 代码的可读性也会增强很多。 const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。 let 变量指向的内存地址，保存的只是一个指向实际数据的指针 补充 const 定义的变量不是数据不可变，而是保存的引用地址不能发生改变。例子如下： 1234const person = &#123; age: 22 &#125;person.age = 1console.log(person.age) // 1 详情看 let 和 const 命令","text":"兼容 IE ？不存在的好吗。 其实使用新语法配合 babel 的转码，已经可以解决这一些问题了。既然如此，那就多使用新语法去探索一下怎么更好的去写代码吧。 下面分享个人开发中常用的 js 写法技巧，希望对各位有所帮助。 使用 let / constvar 命令会发生”变量提升“现象，即变量可以在声明之前使用，值为 undefined。这种现象多多少少是有些奇怪的。 个人认为，对声明的变量确定后面不会发生更改时，即使性能上没有太大提升差异在，但使用 const, 代码的可读性也会增强很多。 const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。 let 变量指向的内存地址，保存的只是一个指向实际数据的指针 补充 const 定义的变量不是数据不可变，而是保存的引用地址不能发生改变。例子如下： 1234const person = &#123; age: 22 &#125;person.age = 1console.log(person.age) // 1 详情看 let 和 const 命令 解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 好处就是：解决了访问多层嵌套的对象或数组的命名，减少代码量 声明多个变量: 12let [age, name, sex] = [22, 'guodada', 1]console.log(age, name, sex) // 22, guodada, 1 使用在对象中： 123456789101112const obj = &#123; name: &#123; firstName: 'guo', lastName: 'dada' &#125;&#125;// 如果我们多处使用 firstName， 那就不必要每个地方都写 obj.name.firstName, 这样极大提升coding效率const &#123; firstName, lastName &#125; = obj.name// 等同于const firstName = obj.name.firstNameconst lastName = obj.name.lastName 使用在函数中: 1234567// 在参数中结构赋值，获取参数, 当参数多的使用时候十分方便function Destructuring(&#123; name, age &#125;) &#123; return &#123; name, age &#125; // 相当于 &#123; name: name, age: age &#125; , 可以简写&#125;const params = &#123; name: 'guodada', age: 22 &#125;Destructuring(params) 更多用法见 变量的解构赋值 ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。 12345678910function f(x, y) &#123; return &#123; x, y &#125;&#125;// 等同于function f(x, y) &#123; return &#123; x: x, y: y &#125;&#125;f(1, 2) // Object &#123;x: 1, y: 2&#125; 扩展符的运用es6 扩展符有很多用法，他可以使你的代码更加简洁，易懂。这里就举例常用的用法 在对象中的用法： 123456789101112131415let obj = &#123; name: 'guodada', age: 22, sex: 1&#125;// 复制对象。扩展符为浅复制！！！const copy = &#123; ...obj &#125;// 修改对象属性值(生成新对象) 相当于 Object.assgin(&#123;&#125;, obj, &#123; age: 18 &#125;)const newObj = &#123; ...obj, age: 18 &#125;// 结合结构赋值let &#123; sex, ...z &#125; = objz // &#123; name: 'guodada', age: 22 &#125; 在数组中的用法： 1234567891011121314const arr = [1, 2, 3]const arr2 = [4, 5, 6, 4]// 复制数组。扩展符为浅复制！！！const newArr = [...arr] // ...[1, 2, 3] =&gt; 相当于展开数组：1, 2, 3// 合并数组const conbineArr = [...arr, ...arr2]// 结合求最大值函数Math.max(...arr)// 结合 Set 实现数组去重。注意：json 等对象数组不可用[...new Set(arr2)] // [4, 5, 6] 扩展符的其他用法请自行查资料。 数组用法1234567891011121314const arr = [1, 2, 3, 4]Array.isArray(arr) // 判断是否为数组arr.includes(2) // true 判断数组中是否包含某项arr.findIndex(d =&gt; d === 3) // 2 找出第一个符合条件的数组成员并返回数组下标, 找不到返回 -1arr.find(d =&gt; d === 3) // 3 找出第一个符合条件的数组成员并返回, 找不到返回 undefined// es5 其他还有 filter map forEach 等，这里不做举例。arr.every(d =&gt; d &gt; 2) // false 每一项都满足条件则返回 truearr.some(d =&gt; d &gt; 2) // true 只要有一项满足条件则返回 true find/findIndex : 找出第一个符合条件的数组成员之后不再匹配，一定程度下优化查找。includes: 返回 true/false, 相较于 indexOf, 实用多了 flat() : 扁平化数组，常用于将数组转化为一维数组 12345678const arr = [1, 2, [3, 4]]arr.flat() // [1, 2, 3, 4] 扁平化数组, 默认展开一层。const arr2 = [1, 2, [3, 4, [5, 6]]]arr2.flat() // [1, 2, 3, 4, [5, 6]]arr2.flat(2) // [1, 2, 3, 4, 5, 6] flat(3) 也是展开两层... flatMap(): 在数组执行 map 方法后执行 flat, 用的不多，其实可以写 map 后写 flat 更好懂点。 123;[2, 3, 4].flatMap(x =&gt; [x, x * 2]) // [ 2, 4, 3, 6, 4, 8 ]// 1. [2, 3, 4].map(d =&gt; [d, d * 2]) =&gt; [[2, 4], [3, 6], [4, 8]]// 2. [[2, 4], [3, 6], [4, 8]].flat() 补充常用的对象转数组的用法： 12345const obj = &#123; name: 'guodada' &#125;Object.keys(obj) // ['name']Object.values(obj) // ['guodada']Object.entries(obj) // [['name', 'guodada']] 模板字符串用的挺多的，注意不兼容 IE ! 123456const name = 'guodada'const newStr = `welcome $&#123;name&#125;` // welcome guodada// the same asconst newStr = 'welcome ' + name 使用 async / awaitasync/await 实际上就是 generator 的语法糖, 主要用来解决异步问题，具体网上很多文章都有介绍，这里就不做多的解释吧。 123456789101112131415161718async function test() &#123; const data = await axios.get('https://randomuser.me/api/') console.log(data)&#125;// 等同于function test() &#123; axios.get('https://randomuser.me/api/').then(res =&gt; console.log(res)) // axios 也是 promise 对象&#125;// 结合try/catchasync function test() &#123; try &#123; const data = await axios.get('https://randomuser.me/api/') console.log(data) &#125; catch (err) &#123; console.log(err) &#125;&#125; ps 虽然好用，但是有时候适用场景不好，比如我们在拉取列表和用户信息需要同时进行时，await 后才执行下一条语句，这不是我们希望看到的。解决方法如下： 12// 结合 Promise.allawait Promise.all([anAsyncCall(), thisIsAlsoAsync(), oneMore()]) 传送门：async 函数 利用 class 封装代码主要是抽离代码逻辑，使得代复用性加强。同时，class 的形式会让结构变得更加清晰，譬如： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class MyForm &#123; /** * @func defaultLimit - 默认表单输入限制条件, value 为空时返回 true * @param &#123;Number&#125; type - 代表表单类型的节点！ * @param &#123;String&#125; value - 需要被验证的值 * @return Boolean * * 根据 type 属性对输出进行验证 * 1 0≤x≤50 整数 * 2 -1000≤x≤2000 整数 * 3 1≤x 整数 * 4 0≤x≤10 */ static defaultLimit(type, value) &#123; const typeLimitMap = &#123; 1: /^(\\d|[1-4]\\d|50)$/g, 2: /^-?(\\d&#123;1,3&#125;|1000)$|^(-|1\\d&#123;3&#125;|2000)$/, 3: /^[1-9]\\d*$/, 4: value =&gt; value &lt;= 10 &amp;&amp; value &gt;= 0 // 0≤ x ≤ 10 可以为小数 &#125; if (!typeLimitMap[type] || !value) return true if (typeof typeLimitMap[type] === 'function') return typeLimitMap[type](value) else return typeLimitMap[type].test(value) &#125; /** * @func translateLimit - 转换操作符 * @param &#123;String&#125; operator - 运算符 * @param &#123;*&#125; value - 被匹配的值 * @param &#123;*&#125; compareValue - 匹配的值 * @return Boolean * 'eq': '=' * 'ne': '≠' * 'gt': '&gt;' * 'lt': '&lt;' * 'ge': '≥' * 'le': '≤' */ static translateLimit(operator, value, compareValue) &#123; const type = &#123; eq: value === compareValue, ne: value !== compareValue, gt: value &gt; compareValue, lt: value &lt; compareValue, ge: value &gt;= compareValue, le: value &lt;= compareValue &#125; if (!Object.keys(type).includes(operator) || !value || value === '-') return true return type[operator] &#125; // ...&#125;export default MyForm 使用： 123import MyForm from './MyForm'MyForm.defaultLimit(1, 20) static ：静态属性，类可以直接调用 constructor : 实例化类的时候调用，即 new MyForm(), 这里没用到 更多知识请阅 Class 的基本语法 优化 if/else 语句 当逻辑或||时，找到为 true 的分项就停止处理，并返回该分项的值，否则执行完，并返回最后分项的值。 当逻辑与&amp;&amp;时，找到为 false 的分项就停止处理，并返回该分项的值。 12345const a = 0 || null || 3 || 4console.log(a) // 3const b = 3 &amp;&amp; 4 &amp;&amp; null &amp;&amp; 0console.log(b) // null 减少 if / else地狱般的调用 1234567891011121314151617const [age, name, sex] = [22, 'guodada', 1]if (age &gt; 10) &#123; if (name === 'guodada') &#123; if (sex &gt; 0) &#123; console.log('all right') &#125; &#125;&#125;// 使用 &amp;&amp;if (age &gt; 10 &amp;&amp; name === 'guodada' &amp;&amp; sex &gt; 0) &#123; console.log('all right')&#125;// 或者(太长了不推荐)age &gt; 10 &amp;&amp; name === 'guodada' &amp;&amp; sex &gt; 0 &amp;&amp; console.log('all right') 提一下 react 的坑点, 在 render 中 12345678910render()&#123; const arr = [] return arr.length &amp;&amp; null&#125;// 渲染出 0 ！// Boolean / undefind / null / NaN 等才不会渲染。我们可以使用 !! 强制转化为 boolean 解决这个问题return !!arr.length &amp;&amp; null// 使用 &amp;&amp; 控制组件的渲染this.state.visible &amp;&amp; &lt;Modal /&gt; 使用 Array.includes 来处理多重条件： 12345678910const ages = [18, 20, 12]if (age === 18 || age === 12) &#123; console.log('match')&#125;// betterif ([18, 12].includes(age)) &#123; console.log('match')&#125; 如果是较少的判断逻辑则可以使用三元运算符： 1234const age = 22const isAdult = age &gt;= 18 ? true : false // 这里可以简写为 const isAdult = age &gt; 18const type = age &gt;= 18 ? 'adult' : 'child' 优化 switch/case 语句switch/case 比 if/else 代码结构好点，但也和它一样有时十分冗长。 这里以自己实际项目中代码举例：有时我们可能需要对不同类型的字段进行不一样的正则验证，防止用户错误地输入。譬如 12345678910111213141516171819202122232425262728293031323334353637const [type, value] = [1, '20']/** * 根据 type 属性对输出进行验证 * 1 0≤x≤50 整数 * 2 -1000≤x≤2000 整数 * 3 1≤x 整数 */function func1(type, value) &#123; if (type === 1) &#123; return /^(\\d|[1-4]\\d|50)$/.test(value) &#125; else if (type === 2) &#123; return /^-?(\\d&#123;1,3&#125;|1000)$|^(-|1\\d&#123;3&#125;|2000)$/.test(value) &#125; else if (type === 3) &#123; return /^[1-9]\\d*$/.test(value) &#125; else &#123; return true &#125;&#125;func1(type, value)// 使用 switch/casefunction fun2(type, value) &#123; switch (type) &#123; case 1: return /^(\\d|[1-4]\\d|50)$/.test(value) case 2: return /^-?(\\d&#123;1,3&#125;|1000)$|^(-|1\\d&#123;3&#125;|2000)$/.test(value) case 3: return /^[1-9]\\d*$/.test(value) default: return true &#125;&#125;func2(type, value) 我们如何巧妙的解决这个代码冗长的问题呢，如下： 12345678function func3(type, value) &#123; const limitMap = &#123; 1: /^(\\d|[1-4]\\d|50)$/g, 2: /^-?(\\d&#123;1,3&#125;|1000)$|^(-|1\\d&#123;3&#125;|2000)$/, 3: /^[1-9]\\d*$/ &#125; return limitMap[type].test(value)&#125; 利用对象去匹配属性值，可以减少你的代码量，也使你的代码看起来更加简洁。你也可以使用 Map 对象去匹配。 12345function func4(type, value) &#123; const mapArr = [[1, /^(\\d|[1-4]\\d|50)$/g], [2, /^-?(\\d&#123;1,3&#125;|1000)$|^(-|1\\d&#123;3&#125;|2000)$/], [3, /^[1-9]\\d*$/]] const limitMap = new Map(mapArr) return limitMap.get(type).test(value)&#125; Map 是一种键值对的数据结构对象，它的匹配更加严格。它会区分开你传递的是字符串还是数字，譬如： 12limitMap.get(1) // /^(\\d|[1-4]\\d|50)$/glimitMap.get('1') // undefined 更多详见 Set 和 Map 数据结构 其他 函数参数默认值 12345function func(name, age = 22) &#123;&#125;// 等同于function func(name, age) &#123; age = age || 22&#125; 使用 === 代替 ==。其实大家都懂这个的。。。 箭头函数，es6 最常用的语法。 return boolean1234const a = 1return a === 1 ? true : false// 多此一举了，其实就等于return a === 1 敬请各位补充。交流才能进步，相视一笑，嘿嘿。 github - star 一下人生更美好 blog - 欢迎交流","categories":[{"name":"开发随笔","slug":"开发随笔","permalink":"https://weifo.github.io/categories/开发随笔/"}],"tags":[]},{"title":"五分钟了解(安装)typescript","slug":"ts_basic","date":"2019-11-14T15:05:08.000Z","updated":"2019-11-18T08:04:06.881Z","comments":false,"path":"2019/11/14/ts_basic/","link":"","permalink":"https://weifo.github.io/2019/11/14/ts_basic/","excerpt":"","text":"typescript的由来typescript是由微软的一个技术团队开发和维护的一个开源项目，之所以会推出这个项目是为了解决js的一个缺陷吧！由于Javascript是一种动态弱类型的语言，在测试和debug阶段会非常的痛苦，也是为了解决这一“痛点”，微软的VS code团队推出了typescript&ensp; (强弱/动态静态具体解释，click here!) 安装1npm install -g typescript 安装后即可通过 tsc -v 命令行来查看安装版本，如果提示tsc不是内部或外部命令的话，说明系统的环境变量没有配置，csdn上有相关的解决办法。 编译1tsc xxx.ts 编译后会在相同文件夹下生成同名的js文件，关于更加工程化地使用typescript可以参考官方文档 变量和函数声明与js语法相比，在所有的变量加上类型123456789101112131415let taylor:string='Taylor';let age:number=25;// 数组有两种定义方式let skills:string[]=['sing','gituar','writing'];let cats:Array&lt;string&gt;=['white','dog','miao'];// 函数声明function info(name:string,age:number):string&#123; let s:string=''; s=`He is $&#123;name&#125;,and he's $&#123;age&#125; years old`; return s;&#125;info('calvin harris',28) 接口和类123456789101112131415161718192021222324252627// 可选属性interface employee&#123; degree?:string, skilled?:boolean&#125;function test(config:employee):boolean&#123; if(config.skilled)&#123; return true &#125;else if(config.degree==='master')&#123; return true &#125;else&#123; return false &#125;&#125;let t1=test(&#123;degree:'master'&#125;)let t2=test(&#123;degree:'bachelor',skilled:'false'&#125;)let t3=test(&#123;skilled:'true'&#125;)console.log(t1,t2,t3)// 只读属性interface Point&#123; readonly x:number, readonly y:number&#125;let p1:Point=&#123;x:10,y:5&#125;p1.y=12// error","categories":[{"name":"技术","slug":"技术","permalink":"https://weifo.github.io/categories/技术/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://weifo.github.io/tags/前端/"}]},{"title":"包学不会的深拷贝与浅拷贝","slug":"deepclone","date":"2019-11-14T14:13:05.000Z","updated":"2019-11-30T05:40:26.649Z","comments":true,"path":"2019/11/14/deepclone/","link":"","permalink":"https://weifo.github.io/2019/11/14/deepclone/","excerpt":"","text":"深拷贝与浅拷贝的含义首先要知道在js的世界中，有两种类型的值，分别是基础类型和引用类型。基础类型包括string,number,boolean,Symbol,undefined,null,引用类型包括array,object等。 基本数据类型：直接存储在栈（stack）中的数据 引用数据类型：在栈中存放的是指针，真实的数据存放在堆中。 首先要分清拷贝和赋值的区别引用类型的赋值是直接赋值了一个指针，二者指向相同的数据内存。而拷贝是要创建一个新的对象/数组，如果只拷贝一层数据的话叫浅拷贝，如果拷贝多层数据叫深拷贝。 12345678910111213141516let obj=&#123; name:'Mike', age:36, hobby:['movies','music','running']&#125;// 这是赋值,任何一个都能操作共有的内存数据let obj1=obj;obj1.name='fred';obj1.hobby[1]='eat';console.log(obj,obj1)；// 这是浅拷贝,只能拷贝一层数据，当对象中有引用类型的value时，只会拷贝这个引用的指针let obj2=&#123;...obj&#125;;obj2.name='max';//不会改变源对象obj2.hobby[1]='sleep'; //会改变源对象console.log(obj,obj2) 如何实现浅拷贝数组的浅拷贝 slice方法 1234let arr=[1,5,9], arr1=arr.slice();arr1.push(11);console.log(arr,arr1) concat方法,当不给concat传参时，该方法和slice()作用相同 12let arr1=arr.concat();... spread操作符 123456let arr=[1,3,5,[8,9]];let arr1=[...arr];arr.push(15);console.log(arr,arr1);arr1[3].push(18);console.log(arr,arr1); 对象的浅拷贝 手动实现 12345678910function shallowCopy(src)&#123; var target=&#123;&#125;; for(let key in src)&#123; if(src.hasOwnProperty(key))&#123; target[key]=src[key]; &#125; &#125; return target&#125;// hasOwnProperty方法可以排除来自原型链上的属性 Object.assign() 1234let obj=&#123;a:&#123;name:'weifo',age:33&#125;&#125;;let copyobj=Object.assign(&#123;&#125;,obj);copyobj.a.name='curt';concole.log(obj.a.name);//curt spread 123let obj=&#123;name:'weifo',skill:['english','code']&#125;;let copyobj=&#123;...obj,name:'fred'&#125;;//&#123;name:'fred',skill:[...]&#125;//es6语法 深拷贝的实现 trick版 12345678910111213JSON.parse(JSON.stringify(obj))// 该方法的局限性：symbol，undefined，函数的属性值会被忽略，例子如下let syb=Symbol(12);let obj=&#123; name:'fred', say:function()&#123; alert('It wont alert'); &#125;, syb:syb， age:undefined&#125;let copy=JSON.parse(JSON.stringify(obj));console.log(copy);//&#123;name:'fred'&#125; 手动实现 12345678910111213141516171819function deepclone(src)&#123; if(typeof src==='object')&#123; let clone=Array.isArray(src)?[]:&#123;&#125;; for(let key in src)&#123; clone[key]=deepclone(src[key]); &#125; return clone &#125;else&#123; return src; &#125;&#125;let test=&#123; name:'fred', cities:['tokyo','paris','london']&#125;let clone=deepclone(test);clone.cities.push('rome');clone.name='weifo';console.log(test,clone) 解决循环引用上面的方法可以满足大部分的应用场景了，除了遇到对象引用自身的情况，如果采用上面的方法，会有爆栈的错误提示。 123456789const test=&#123; name:'weifo', field:[3,5,11], field1:&#123; child:'name' &#125;&#125;test.test=test;//循环引用deepclone(test)//RangeError 为了解决循环引用的问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝对象时，先去存储对象中找，找到的话直接返回，没有则继续拷贝。123456789101112131415function deepclone(target,map=new Map())&#123; if(typeof target==='object')&#123; let clone=Array.isArray(src)?[]:&#123;&#125;; if(map.get(target))&#123; return target &#125; map.set(target,clone); for(let key in target)&#123; clone[key]=clone(target[key],map); &#125; return clone &#125;else&#123; return target &#125;&#125; 使用lodash12345var _=require('lodash');var objects = [&#123; 'a': 1 &#125;, &#123; 'b': 2 &#125;]; var deep = _.cloneDeep(objects);console.log(deep[0] === objects[0]);//false","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://weifo.github.io/categories/前端开发/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://weifo.github.io/tags/javascript/"}]},{"title":"webpack-plugins","slug":"webpack-plugins","date":"2019-10-12T13:43:08.000Z","updated":"2020-02-16T13:25:04.014Z","comments":true,"path":"2019/10/12/webpack-plugins/","link":"","permalink":"https://weifo.github.io/2019/10/12/webpack-plugins/","excerpt":"功能类html-webpack-plugin 把编译后的文件（css/js）插入到入口文件中，可以只指定某些文件插入，可以对 html 进行压缩等 filename：输出文件名； template：模板文件，不局限于 html 后缀哦； removeComments：移除 HTML 中的注释； collapseWhitespace：删除空白符与换行符，整个文件会压成一行； inlineSource：插入到 html 的 css、js 文件都要内联，即不是以 link、script 的形式引入； inject：是否能注入内容到 输出 的页面去； chunks：指定插入某些模块； hash：每次会在插入的文件后面加上 hash ，用于处理缓存，如：；其他：favicon、meta、title ……；","text":"功能类html-webpack-plugin 把编译后的文件（css/js）插入到入口文件中，可以只指定某些文件插入，可以对 html 进行压缩等 filename：输出文件名； template：模板文件，不局限于 html 后缀哦； removeComments：移除 HTML 中的注释； collapseWhitespace：删除空白符与换行符，整个文件会压成一行； inlineSource：插入到 html 的 css、js 文件都要内联，即不是以 link、script 的形式引入； inject：是否能注入内容到 输出 的页面去； chunks：指定插入某些模块； hash：每次会在插入的文件后面加上 hash ，用于处理缓存，如：；其他：favicon、meta、title ……； 12345678910111213141516171819202122const path = require('path')const HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; mode: 'production', entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), // 输出文件的目录 filename: 'js/[name].[hash:8].js' // 打包路径及名称 &#125;, plugins: [ new HtmlWebpackPlugin(&#123; filename: 'index.html', // 生成文件名 template: './public/index.html', // 配置要被编译的html文件 hash: true, // 压缩HTML文件 minify: &#123; removeAttributeQuotes: true, //删除双引号 collapseWhitespace: true //折叠 html 为一行 &#125; &#125;) ]&#125; 传送门 ==&gt; html-webpack-plugin clean-webpack-plugin 在编译之前清理指定目录指定内容。 123456const CleanWebpackPlugin = require('clean-webpack-plugin')module.exports = &#123; plugins: [new CleanWebpackPlugin(['dist'])]&#125;// 指定清除哪些文件 new CleanWebpackPlugin(pathsToClean [, &#123;pathsToClean &#125;]) 详情请看 npm 传送门 ==&gt; clean-webpack-plugin copy-webpack-plugin12345const CopyWebpackPlugin = require('copy-webpack-plugin')module.exports = &#123; plugins: [new CopyWebpackPlugin([...patterns], options)]&#125; 传送门 ==&gt; copy-webpack-plugin compression-webpack-plugin 使用 compression-webpack-plugin 插件进行压缩，提供带 Content-Encoding 编码的压缩版的资源。 12345678910111213const CompressionPlugin = require('compression-webpack-plugin')module.exports = &#123; plugins: [ new CompressionPlugin(&#123; filename: '[path].gz[query]', //目标资源名称。[file] 会被替换成原资源。[path] 会被替换成原资源路径，[query] 替换成原查询字符串 algorithm: 'gzip', //算法 test: /\\.js(\\?.*)?$/i, //压缩 js deleteOriginalAssets: true, // 删除源文件 threshold: 10240, //只处理比这个值大的资源。按字节计算 minRatio: 0.8 //只有压缩率比这个值小的资源才会被处理 &#125;) ]&#125; 传送门 ==&gt; compression-webpack-plugin webpack-manifest-plugin 该插件可以显示出编译之前的文件和编译之后的文件的映射 1234const ManifestPlugin = require('webpack-manifest-plugin')module.exports = &#123; plugins: [new ManifestPlugin()]&#125; 传送门 ==&gt; webpack-manifest-plugin progress-bar-webpack-plugin 编译进度条插件 1234const ProgressBarPlugin = require('progress-bar-webpack-plugin') // 编译进度条插件module.exports = &#123; plugins: [new ProgressBarPlugin()]&#125; 传送门 ==&gt; progress-bar-webpack-plugin 代码相关webpack.ProvidePlugin 自动加载模块，而不必到处 import 或 require 。 1234567const webpack = require('webpack')module.exports = &#123; plugins: [new webpack.ProvidePlugin(&#123; $: 'jquery' &#125;)]&#125;// index.jsconsole.log($) 传送门 ==&gt; webpack.ProvidePlugin webpack.DefinePlugin DefinePlugin 允许创建一个在编译时可以配置的全局常量。这可能会对开发模式和发布模式的构建允许不同的行为非常有用。如果在开发构建中，而不在发布构建中执行日志记录，则可以使用全局常量来决定是否记录日志。这就是 DefinePlugin 的用处，设置它，就可以忘记开发和发布构建的规则。 12345678910module.exports = &#123; plugins: [ new webpack.DefinePlugin(&#123; PRODUCTION: JSON.stringify(true) &#125;) ]&#125;// index.jsconsole.log(PRODUCTION) // true 传送门 ==&gt; webpack.DefinePlugin mini-css-extract-pluginmini-css-extract-plugin，它默认就会对你的样式进行模块化拆分。相对 extract-text-webpack-plugin。 即 css 异步按需加载 1234567891011121314151617181920212223242526272829const MiniCssExtractPlugin = require('mini-css-extract-plugin') // 抽取 css 到独立文件module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.css$/, include: [path.resolve(__dirname, 'src')], use: [ &#123; loader: MiniCssExtractPlugin.loader, options: &#123; publicPath: '../' // chunk publicPath &#125; &#125;, 'css-loader' ] &#125; ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: 'css/[name].[hash:8].css', //这里配置跟output写法一致 chunkFilename: 'css/[id][chunkhash:8].css' &#125;) ]&#125; 传送门 ==&gt; mini-css-extract-plugin 编译结果优化类wbepack.IgnorePlugin防止在 import 或 require 调用时，生成以下正则表达式匹配的模块： requestRegExp 匹配(test)资源请求路径的正则表达式。 contextRegExp （可选）匹配(test)资源上下文（目录）的正则表达式。 moment 2.18 会将所有本地化内容和核心功能一起打包（见该 GitHub issue）。你可使用 IgnorePlugin 在打包时忽略本地化内容: 1new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/) 传送门 ==&gt; wbepack.IgnorePlugin uglifyjs-webpack-plugin js 代码压缩,默认会使用 optimization.minimizer， cache: Boolean/String ,字符串即是缓存文件存放的路径； test：正则表达式、字符串、数组都可以，用于只匹配某些文件，如：/.js(?.*)?\\$/i; parallel : 启用多线程并行运行来提高编译速度，经常编译的时候听到电脑跑的呼呼响，可能就是它干的，哈哈～； output.comments ： 删除所有注释， compress.warnings ：插件在进行删除一些无用代码的时候，不提示警告， compress.drop_console：喜欢打 console 的同学，它能自动帮你过滤掉，再也不用担心线上还打印日志了； 1234567891011121314151617181920212223242526const UglifyJsPlugin = require('uglifyjs-webpack-plugin')module.exports = &#123; optimization: &#123; minimizer: [ new UglifyJsPlugin(&#123; cache: true, // 开启缓存 parallel: true, // 开启多线程编译 sourceMap: true, // 是否sourceMap // 丑化参数 uglifyOptions: &#123; comments: false, warnings: false, compress: &#123; unused: true, dead_code: true, collapse_vars: true, reduce_vars: true &#125;, output: &#123; comments: false &#125; &#125; &#125;) ] &#125;&#125; 传送门 ==&gt; uglifyjs-webpack-plugin optimize-css-assets-webpack-plugin它的作用在于压缩 css 文件 assetNameRegExp：默认是全部的 css 都会压缩，该字段可以进行指定某些要处理的文件， cssProcessor：指定一个优化 css 的处理器，默认 cssnano， cssProcessorPluginOptions：cssProcessor 后面可以跟一个 process 方法，会返回一个 promise 对象，而 cssProcessorPluginOptions 就是一个 options 参数选项！ canPrint：布尔，是否要将编译的消息显示在控制台，没发现有什么用！ 坑点 ：建议使用高版本的包，之前低版本有遇到样式丢失把各浏览器前缀干掉的问题， 1234567891011const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin') // 丑化 cssmodule.exports = &#123; optimization: &#123; minimizer: [ new OptimizeCssAssetsPlugin(&#123; cssProcessor: require('cssnano'), // css 压缩优化器 cssProcessorOptions: &#123; discardComments: &#123; removeAll: true &#125; &#125; // 去除所有注释 &#125;) ] &#125;&#125; 传送门 ==&gt; optimize-css-assets-webpack-plugin SplitChunksPluginwebpack 把 chunk 分为两种类型，一种是初始加载 initial chunk，另外一种是异步加载 async chunk，如果不配置 SplitChunksPlugin，`webpack 会在 production 的模式下自动开启，默认情况下，webpack会将node_modules下的所有模块定义为异步加载模块，并分析你的entry、动态加载（import()、require.ensure）模块，找出这些模块之间共用的node_modules下的模块，并将这些模块提取到单独的chunk` 中，在需要的时候异步加载到页面当中，其中默认配置如下： 1234567891011121314151617181920212223242526module.exports = &#123; //... optimization: &#123; splitChunks: &#123; chunks: 'async', // 异步加载chunk minSize: 30000, maxSize: 0, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: '~', // 文件名中chunk分隔符 name: true, cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, // priority: -10 &#125;, default: &#123; minChunks: 2, // 最小的共享chunk数 priority: -20, reuseExistingChunk: true &#125; &#125; &#125; &#125;&#125; 传送门 ==&gt; SplitChunksPlugin webpack.HotModuleReplacementPlugin热更新, 配合 webpack-dev-server 使用 1yarn add webpack-dev-server -D 123456789101112131415161718new webpack.HotModuleReplacementPlugin()module.exports = &#123; devServer: &#123; port: 1234, open: true, // 自动打开浏览器 compress: true, // 服务器压缩 hot: true // 开启热加载 //... proxy、hot &#125;, plugins: [new webpack.HotModuleReplacementPlugin()]&#125;// index.jsif (module.hot) &#123; module.hot.accept()&#125; 传送门 ==&gt; devServer 传送门 ==&gt; webpack-dev-server 加快编译速度DllPlugin &amp;&amp; DllReferencePlugin &amp;&amp; autodll-webpack-pluginDllPlugin 和 DllReferencePlugin 提供分离包的方式可以大大提高构建时间性能。主要思想在于，将一些不做修改的依赖文件，提前打包，这样我们开发代码发布的时候就不需要再对这部分代码进行打包。从而节省了打包时间。 DllPlugin 插件：用于打包出一个个单独的动态链接库文件。DllReferencePlugin 插件：用于在主要配置文件中去引入 DllPlugin 插件打包好的动态链接库文件。 DllPlugin context (optional): manifest 文件中请求的上下文(context)(默认值为 webpack 的上下文(context)) name: 暴露出的 DLL 的函数名 (TemplatePaths: [hash] &amp; [name] ) path: manifest json 文件的绝对路径 (输出文件) DllReferencePlugin: 这个插件把只有 dll 的 bundle(们)(dll-only-bundle(s)) 引用到需要的预编译的依赖。 DllReferencePlugin context: (绝对路径) manifest (或者是内容属性)中请求的上下文 manifest: 包含 content 和 name 的对象，或者在编译时(compilation)的一个用于加载的 JSON manifest 绝对路径 content (optional): 请求到模块 id 的映射 (默认值为 manifest.content) name (optional): dll 暴露的地方的名称 (默认值为 manifest.name) (可参考 externals) scope (optional): dll 中内容的前缀 sourceType (optional): dll 是如何暴露的 (libraryTarget) 传送门 ==&gt; DllPlugin","categories":[{"name":"webpack","slug":"webpack","permalink":"https://weifo.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://weifo.github.io/tags/webpack/"}]},{"title":"webpack - 理论篇","slug":"webpack-theory","date":"2019-10-11T03:15:56.000Z","updated":"2020-02-16T13:24:45.730Z","comments":true,"path":"2019/10/11/webpack-theory/","link":"","permalink":"https://weifo.github.io/2019/10/11/webpack-theory/","excerpt":"entry123456789101112131415161718192021/** * @param &#123;String&#125; - String 时 打包为一个文件，默认包名 main.js * @param &#123;Array&#125; - Array 时 webpack会把数组里所有文件打包成一个js文件 * @param &#123;Object&#125; - Object 时 webpack会把对象里的文件分别打包成多个文件 * */module.exports = &#123; entry: './index.js', entry: ['./index.js', './about.js'], entry: &#123; app: './index.js', about: './about.js' &#125;, entry: &#123; app: './index.js', vendors: ['jquery'] // 分离第三方库 &#125;&#125;","text":"entry123456789101112131415161718192021/** * @param &#123;String&#125; - String 时 打包为一个文件，默认包名 main.js * @param &#123;Array&#125; - Array 时 webpack会把数组里所有文件打包成一个js文件 * @param &#123;Object&#125; - Object 时 webpack会把对象里的文件分别打包成多个文件 * */module.exports = &#123; entry: './index.js', entry: ['./index.js', './about.js'], entry: &#123; app: './index.js', about: './about.js' &#125;, entry: &#123; app: './index.js', vendors: ['jquery'] // 分离第三方库 &#125;&#125; vendors 第三方库// 待补充 output 指示 webpack 如何去输出、以及在哪里输出、输出的格式等 123456789module.exports = &#123; output: &#123; path: path.resolve(__dirname, 'dist'), // 输出文件的目录 filename: 'js/[name].[chunkhash:8].js', // 打包路径及名称 chunkFilename: 'js/[name].[chunkhash:8].js' // 按需加载 // publicPath：文件输出的公共路径， //... &#125;&#125; resolve 配置模块如何解析 extensions：自动解析确定的扩展,省去你引入组件时写后缀的麻烦， alias：非常重要的一个配置，它可以配置一些短路径， modules：webpack 解析模块时应该搜索的目录， … 123456789module.exports = &#123; resolve: &#123; extensions: ['.js', '.jsx', '.ts', '.tsx', '.scss', '.json', '.css'], alias: &#123; '@': path.resolve(__dirname, 'src') &#125;, modules: [path.resolve(__dirname, 'src'), 'node_modules'] &#125;&#125; module.rules rules：也就是之前的 loaders， test ： 正则表达式，匹配编译的文件， exclude：排除特定条件，如通常会写 node_modules，即把某些目录/文件过滤掉， include：它正好与 exclude 相反， use -loader ：必须要有它，它相当于是一个 test 匹配到的文件对应的解析器，babel-loader、style-loader、sass-loader、url-loader 等等， use - options：它与 loader 配合使用，可以是一个字符串或对象，它的配置可以直接简写在 loader 内一起，它下面还有 presets、plugins 等属性； plugins// 另一篇文章 webpack - plugins 篇 敬请期待 devtool 控制是否生成，以及如何生成 source map 文件，开发环境下更有利于定位问题，默认 false, 当然它的开启，也会影响编译的速度，所以生产环境一定一定记得关闭； 常用的值：cheap-eval-source-map、eval-source-map、cheap-module-eval-source-map、inline-cheap-module-source-map 等等 1devtool: 'eval-source-map' // 原始源代码 webpack-dev-server contentBase ：告诉服务(dev server)在哪里查找文件，默认不指定会在是当期项目根目录， historyApiFallback:可以是 boolean、 object，默认响应的入口文件，包括 404 都会指向这里，object 见下面示例： compress：启用 gzip 压缩， publicPath：它其实就是 output.publicPath，当你改变了它，即会覆盖了 output 的配置， stats： 可以自定控制要显示的编译细节信息， proxy：它其实就是 http-proxy-middleware，可以进行处理一些代理的请求。 123456789101112131415const webpack = require('webpack')module.exports = &#123; devServer: &#123; contentBase:'./assets', port: 1234, open: true, // 自动打开浏览器 compress: true // 服务器压缩 hot: true // 配合 HotModuleReplacementPlugin 使用 //... proxy、hot &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() ]&#125; optimization optimization 是 webpack4 新增的，主要是用来让开发者根据需要自定义一些优化构建打包的策略配置， minimize：true/false,告诉 webpack 是否开启代码最小化压缩， minimizer：自定 js 优化配置，会覆盖默认的配置，结合 UglifyJsPlugin 插件使用， removeEmptyChunks: bool 值，它检测并删除空的块。将设置为 false 将禁用此优化， nodeEnv：它并不是 node 里的环境变量，设置后可以在代码里使用 process.env.NODE_ENV === ‘development’来判断一些逻辑，生产环境 UglifyJsPlugin 会自动删除无用代码， splitChunks ：取代了 CommonsChunkPlugin，自动分包拆分、代码拆分，详细默认配置： 默认配置，只会作用于异步加载的代码块 —— chunks: ‘async’，它有三个值：all,async,initial 12345678910111213141516171819202122232425262728module.exports = &#123; // 优化构建打包的策略配置 optimization: &#123; minimize: true, // 是否开启代码最小化压缩 默认 false //splitChunks 默认配置 splitChunks: &#123; chunks: 'async', minSize: 30000, maxSize: 0, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: '~', name: true, cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, reuseExistingChunk: true &#125; &#125; &#125; &#125;&#125; 配合 UglifyJsPlugin12345678910111213141516171819202122232425262728const UglifyJsPlugin = require('uglifyjs-webpack-plugin')module.exports = &#123; // 优化构建打包的策略配置 optimization: &#123; minimizer: [ new UglifyJsPlugin(&#123; cache: true, // 开启缓存 parallel: true, // 开启多线程编译 sourceMap: true, // 是否sourceMap uglifyOptions: &#123; // 丑化参数 comments: false, warnings: false, compress: &#123; unused: true, dead_code: true, collapse_vars: true, reduce_vars: true &#125;, output: &#123; comments: false &#125; &#125; &#125;) ] &#125;&#125; 参考 webpack4 配置详解之慢嚼细咽","categories":[{"name":"webpack","slug":"webpack","permalink":"https://weifo.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://weifo.github.io/tags/webpack/"}]},{"title":"webpack - 入门篇","slug":"webpack-入门","date":"2019-10-10T14:09:14.000Z","updated":"2020-02-16T13:22:47.303Z","comments":true,"path":"2019/10/10/webpack-入门/","link":"","permalink":"https://weifo.github.io/2019/10/10/webpack-入门/","excerpt":"什么是 webpackwebpack 可以看做是模块打包机：他做的事情是，分析你的项目结构，找到 JavaScript 模块以及其他的一些浏览器不能直接运行的扩展语言（Scss、TypeScript 等），将其打包为合适的格式以供浏览器使用 构建就是把源代码转换成发布到线上可执行的 JavaScript、CSS、HTML 代码，包括以下内容： 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等等 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载 模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件 自动刷新：监听本地源代码的变化，自动构建，刷新浏览器 代码校验：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。 构建其实是工程化、自动化思想在前端开发中的体现。把一系列流程用代码去实现，让代码自动化地执行这一系列复杂的流程。","text":"什么是 webpackwebpack 可以看做是模块打包机：他做的事情是，分析你的项目结构，找到 JavaScript 模块以及其他的一些浏览器不能直接运行的扩展语言（Scss、TypeScript 等），将其打包为合适的格式以供浏览器使用 构建就是把源代码转换成发布到线上可执行的 JavaScript、CSS、HTML 代码，包括以下内容： 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等等 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载 模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件 自动刷新：监听本地源代码的变化，自动构建，刷新浏览器 代码校验：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。 构建其实是工程化、自动化思想在前端开发中的体现。把一系列流程用代码去实现，让代码自动化地执行这一系列复杂的流程。 webpack 的基本概念 入口(entry point): 指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始，webpack 会找出有哪些模块和 library 是入口起点（直接和间接）依赖的。 默认值是 ./src/index.js，然而，可以通过在 webpack 配置中配置 entry 属性，来指定一个不同的入口起点（或者也可以指定多个入口起点）。 出口 output: 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，主输出文件默认为 ./dist/main.js，其他生成文件的默认输出目录是 ./dist loader: 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 注意，loader 能够 import 导入任何类型的模块（例如 .css 文件），这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是有很必要的，因为这可以使开发人员创建出更准确的依赖关系图。 插件 plugins: loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。 模式 mode: 通过选择 development 或 production 之中的一个，来设置 mode 参数，你可以启用相应模式下的 webpack 内置的优化 webpack 构建过程 从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module。 每找到一个 Module， 就会根据配置的 Loader 去找出对应的转换规则。 对 Module 进行转换后，再解析出当前 Module 依赖的 Module。 这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。 最后 Webpack 会把所有 Chunk 转换成文件输出。 在整个流程中 Webpack 会在恰当的时机执行 Plugin 里定义的逻辑。 开发环境和生产环境我们在日常的前端开发工作中，一般都会有两套构建环境：一套开发时使用，一套供线上使用。 development: 用于开发的配置文件，用于定义 webpack dev server 和其他东西 production: 用于生产的配置文件，用于定义 UglifyJSPlugin，sourcemaps 等 简单来说，开发时可能需要打印 debug 信息，包含 sourcemap 文件，而生产环境是用于线上的即代码都是压缩后，运行时不打印 debug 信息等。譬如 axios、antd 等我们的生产环境中需要使用到那么我们应该安装该依赖在生产环境中，而 webpack-dev-server 则是需要安装在开发环境中 平时我们 npm 中安装的文件中有 -S -D, -D 表示我们的依赖是安装在开发环境的，而-S 的是安装依赖在生产环境中。 本文就来带你搭建基本的前端开发环境，前端开发环境需要什么呢？ 构建发布需要的 HTML、CSS、JS、图片等资源 使用 CSS 预处理器，这里使用 less 配置 babel 转码器 =&gt; 使用 es6+ 处理和压缩图片 配置热加载，HMR 以上配置就可以满足前端开发中需要的基本配置。下面是本文打包后的效果图： 搭建基本的开发环境安装123mkdir webpack-dev &amp;&amp; cd webpack-devnpm init -ynpm i webpack webpack-cli -D 添加 scripts生成了 package.json 文件，在文件中添加 123\"scripts\": &#123; \"build\": \"webpack --mode production\" &#125; –mode 模式 (必选，不然会有 WARNING)，是 webpack4 新增的参数选项，默认是 production --mode production 生产环境 提供 uglifyjs-webpack-plugin 代码压缩 不需要定义 new webpack.DefinePlugin({ &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;production&quot;) }) 默认 production 默认开启 NoEmitOnErrorsPlugin -&gt; optimization.noEmitOnErrors, 编译出错时跳过输出，以确保输出资源不包含错误 默认开启 ModuleConcatenationPlugin -&gt; optimization.concatenateModules, webpack3 添加的作用域提升(Scope Hoisting) --mode development 开发环境 使用 eval 构建 module, 提升增量构建速度 不需要定义 new webpack.DefinePlugin({ &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;development&quot;) }) 默认 development 默认开启 NamedModulesPlugin -&gt; optimization.namedModules 使用模块热替换(HMR)时会显示模块的相对路径 添加了 scripts 之后，新建src/index.js，然后执行npm run build ，你就会发现新增了一个 dist 目录，里边存放的是 webpack 构建好的 main.js 文件。 ps npm scripts 使用指南 新建 webpack.config.js 文件要想对 webpack 中增加更多的配置信息，我们需要建立一个 webpack 的配置文件。在根目录下创建 webpack.config.js 后再执行 webpack 命令，webpack 就会使用这个配置文件的配置了 配置中具备以下的基本信息： 12345678module.exports = &#123; entry: '', // 打包入口：指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始 output: '', // 出口 resolve: &#123;&#125;, // 配置解析：配置别名、extensions 自动解析确定的扩展等等 devServer: &#123;&#125;, // 开发服务器：run dev/start 的配置，如端口、proxy等 module: &#123;&#125;, // 模块配置：配置loader（处理非 JavaScript 文件，比如 less、sass、jsx、图片等等）等 plugins: [] // 插件的配置：打包优化、资源管理和注入环境变量&#125; 配置打包入口和出口首先我们往 webpack.config.js 添加点配置信息 123456789101112const path = require('path')module.exports = &#123; // 指定打包入口 entry: './src/index.js', // 打包出口 output: &#123; path: path.resolve(__dirname, 'dist'), // 解析路径为 ./dist filename: 'bundle.js' &#125;&#125; 上面我们定义了打包入口 ./src/index.js，打包出口为 ./dist, 打包的文件夹名字为bundle.js，执行npm run build命令后，index.js 文件会被打包为 bundle.js 文件。此时随便建立一个 html 文件引用这个bundle.js就可以看到你在index.js 写的代码了。 path.resolve([…paths]) 方法会把一个路径或路径片段的序列解析为一个绝对路径。 使用 html-webpack-plugin 创建 html 文件更多情况下我们不希望打包一次，就新建一次 html 文件来引用打包后的文件，这样显得不智能或者说当你打包的文件名修改后，引用路径就会出错。 这个时候我们就可以使用 html-webpack-plugin 插件来将 HTML 引用路径和我们的构建结果关联起来。 1npm install html-webpack-plugin -D 创建文件public/index.html 修改 webpack.config.js 文件 12345678910const HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; //... plugins: [ new HtmlWebpackPlugin(&#123; filename: 'index.html', // 配置输出文件名和路径 template: './public/index.html' // 配置要被编译的html文件 &#125;) ]&#125; 重新执行 npm run build, dist 目录就会多个 index.html 并引入了 bundle.js. 压缩 html 文件修改 webpack.config.js 12345678910111213141516const HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; //... plugins: [ new HtmlWebpackPlugin(&#123; filename: 'index.html', // 配置输出文件名和路径 template: './public/index.html', // 配置要被编译的html文件 hash: true, // 压缩 =&gt; production 模式使用 minify: &#123; removeAttributeQuotes: true, //删除双引号 collapseWhitespace: true //折叠 html 为一行 &#125; &#125;) ]&#125; 打包 css 文件我们希望使用 webpack 来进行构建 css 文件，，为此，需要在配置中引入 loader 来解析和处理 CSS 文件： 1npm install style-loader css-loader -D 新建 src/assets/style/color.css, 修改 webpack.config.js 文件： 123456789101112131415161718192021module.exports = &#123; //... module: &#123; /** * test: 匹配特定条件。一般是提供一个正则表达式或正则表达式的数组 * include: 匹配特定条件。一般是提供一个字符串或者字符串数组 * exclude: 排除特定条件 * and: 必须匹配数组中的所有条件 * or: 匹配数组中任何一个条件, * nor: 必须排除这个条件 */ rules: [ &#123; test: /\\.css$/, include: [path.resolve(__dirname, 'src')], use: ['style-loader', 'css-loader'] &#125; ] &#125; //...&#125; 经由上述两个 loader 的处理后，CSS 代码会转变为 JS， 如果需要单独把 CSS 文件分离出来，我们需要使用 mini-css-extract-plugin 插件 抽取 css 到独立文件, 自动添加前缀1npm i mini-css-extract-plugin postcss-loader autoprefixer -D 我们在写 css 时不免要考虑到浏览器兼容问题，如 transform 属性，需要添加浏览器前缀以适配其他浏览器。故使用到 postcss-loader 这个 loader， 下面则是相关的配置 webpack.config.js 123456789101112131415161718192021222324252627282930const MiniCssExtractPlugin = require('mini-css-extract-plugin')module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.css$/, include: [path.resolve(__dirname, 'src')], use: [ MiniCssExtractPlugin.loader, 'css-loader', &#123; loader: 'postcss-loader', options: &#123; plugins: [require('autoprefixer')] &#125; &#125; ] &#125; ] &#125;, plugins: [ //... new MiniCssExtractPlugin(&#123; filename: '[name].css', chunkFilename: '[id].css' &#125;) ]&#125; 打包 less 文件开发中通常会用到一门预处理语言，这里以less为例，通过less-loader可以打包 less 为 css 文件 1npm install less less-loader -D 新建 src/assets/style/index.less, 并且在 src/index.js 中引入 import &#39;./assets/style/index.less&#39; 配置 webpack.config.js 123456789101112131415161718192021222324const MiniCssExtractPlugin = require('mini-css-extract-plugin')module.exports = &#123; module: &#123; rules: [ // ... &#123; test: /\\.less$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', &#123; loader: 'postcss-loader', options: &#123; plugins: [require('autoprefixer')] // 添加css中的浏览器前缀 &#125; &#125;, 'less-loader' ] &#125; ] &#125; //...&#125; 执打包命令后就可以发现 index.less 中写的样式会和color.css一样被打包进 main.css中。 webpack@v4 升级踩坑: 关于使用 mini-css-extract-plugin 的注意点。 打包图片1npm install file-loader url-loader -D file-loader: 可以用于处理很多类型的文件，它的主要作用是直接输出文件，把构建后的文件路径返回。 url-loader:如果图片较多，会发很多 http 请求，会降低页面性能。url-loader 会将引入的图片编码，生成 dataURl。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此 url-loader 提供了一个 limit 参数，小于 limit 字节的文件会被转为 DataURl，大于 limit 的还会使用 file-loader 进行 copy。 url-loader 可以看作是增强版的 file-loader。 url-loader 把图片编码成 base64 格式写进页面，从而减少服务器请求。 1234567891011121314151617181920module.exports = &#123; module: &#123; rules: [ // ... &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: 'url-loader', options: &#123; outputPath: 'images/', //输出到images文件夹 limit: 500 //是把小于500B的文件打成Base64的格式，写入JS &#125; &#125; ] &#125; ] &#125; //...&#125; url-loader 和 file-loader 是什么关系呢？ 简单地说，url-loader 封装了 file-loader。url-loader 不依赖于 file-loader，即使用 url-loader 时，只需要安装 url-loader 即可，不需要安装 file-loader，因为 url-loader 内置了 file-loader。 通过上面的介绍，我们可以看到，url-loader 工作分两种情况： 文件大小小于 limit 参数，url-loader 将会把文件转为 DataURL； 文件大小大于 limit，url-loader 会调用 file-loader 进行处理，参数也会直接传给 file-loader。因此我们只需要安装 url-loader 即可。 有关 url-loader 和 file-loader 的解析：webpack 之图片引入-增强的 file-loader：url-loader 配置 babelbabel-loaderBabel 是一个让我们能够使用 ES 新特性的 JS 编译工具，我们可以在 webpack 中配置 Babel，以便使用 ES6、ES7 标准来编写 JS 代码。 Babel 7 的相关依赖包需要加上 @babel scope。一个主要变化是 presets 设置由原来的 env 换成了 @babel/preset-env, 可以配置 targets, useBuiltIns 等选项用于编译出兼容目标环境的代码。其中 useBuiltIns 如果设为 &quot;usage&quot;，Babel 会根据实际代码中使用的 ES6/ES7 代码，以及与你指定的 targets，按需引入对应的 polyfill，而无需在代码中直接引入 import &#39;@babel/polyfill&#39;，避免输出的包过大，同时又可以放心使用各种新语法特性。 1npm i babel-loader @babel/core @babel/preset-env -D 笔者这里配的版本号如下 12345&#123; \"babel-loader\": \"^8.0.4\", \"@babel/core\": \"^7.1.2\", \"@babel/preset-env\": \"^7.1.0\"&#125; babel-loader: 用 babel 转换 ES6 代码需要使用到 babel-loader @babel-preset-env： 默认情况下是等于 ES2015 + ES2016 + ES2017，也就是说它对这三个版本的 ES 语法进行转化。 @babel/core：babel 核心库 根目录下新建 .babelrc 文件 1234567891011121314&#123; \"presets\": [ [ \"@babel/preset-env\", &#123; \"modules\": false, \"targets\": &#123; \"browsers\": [\"&gt; 1%\", \"last 2 versions\", \"not ie &lt;= 8\"] &#125;, \"useBuiltIns\": \"usage\" &#125; ] ]&#125; presets 是一堆 plugins 的预设，起到方便的作用。 plugins 是编码转化工具，babel 会根据你配置的插件对代码进行相应的转化。 修改 webpack.config.js 1234567891011121314module.exports = &#123; module: &#123; rules: [ //... &#123; test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader' &#125; &#125; ] &#125;&#125; babel/polyfill 和 transform-runtime Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API ，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转码。 babel-polyfill: 如上述所说，对于新的 API，你可能需要引入 babel-polyfill 来进行兼容 关键点 babel-polyfill 是为了模拟一个完整的 ES2015+环境，旨在用于应用程序而不是库/工具。 babel-polyfill 会污染全局作用域 babel-runtime 的作用： 提取辅助函数。ES6 转码时，babel 会需要一些辅助函数，例如 _extend。babel 默认会将这些辅助函数内联到每一个 js 文件里， babel 提供了 transform-runtime 来将这些辅助函数“搬”到一个单独的模块 babel-runtime 中，这样做能减小项目文件的大小。 提供 polyfill：不会污染全局作用域，但是不支持实例方法如 Array.includes babel-runtime 更像是分散的 polyfill 模块，需要在各自的模块里单独引入，借助 transform-runtime 插件来自动化处理这一切，也就是说你不要在文件开头 import 相关的 polyfill，你只需使用，transform-runtime 会帮你引入。 对于开发应用来说，直接使用上述的按需 polyfill 方案是比较方便的，但如果是开发工具、库的话，这种方案未必适合（babel-polyfill 是通过向全局对象和内置对象的 prototype 上添加方法实现的，会造成全局变量污染）。Babel 提供了另外一种方案 transform-runtime，它在编译过程中只是将需要 polyfill 的代码引入了一个指向 core-js 中对应模块的链接(alias)。关于这两个方案的具体差异和选择，可以自行搜索相关教程，这里不再展开，下面提供一个 transform-runtime 的参考配置方案。 首先安装 runtime 相关依赖 12npm i @babel/plugin-transform-runtime -Dnpm i @babel/runtime -S 修改 .babelrc 1234&#123; //... \"plugins\": [\"@babel/plugin-transform-runtime\"]&#125; 打包前清理源目录文件 clean-webpack-plugin每次打包，都会生成项目的静态资源，随着某些文件的增删，我们的 dist 目录下可能产生一些不再使用的静态资源，webpack 并不会自动判断哪些是需要的资源，为了不让这些旧文件也部署到生产环境上占用空间，所以在 webpack 打包前最好能清理 dist 目录。 1npm install clean-webpack-plugin -D 修改 webpack.config.js 文件 1234const CleanWebpackPlugin = require('clean-webpack-plugin')module.exports = &#123; plugins: [new CleanWebpackPlugin(['dist'])]&#125; 提取公用代码假如你 a.js 和 b.js 都 import 了 c.js 文件，这段代码就冗杂了。为什么要提取公共代码，简单来说，就是减少代码冗余，提高加载速度。 12345678910111213141516171819202122232425262728293031module.exports = &#123; //... optimization: &#123; splitChunks: &#123; cacheGroups: &#123; commons: &#123; // 抽离自己写的公共代码 chunks: 'initial', name: 'common', // 打包后的文件名，任意命名 minChunks: 2, //最小引用2次 minSize: 0 // 只要超出0字节就生成一个新包 &#125;, styles: &#123; name: 'styles', // 抽离公用样式 test: /\\.css$/, chunks: 'all', minChunks: 2, enforce: true &#125;, vendor: &#123; // 抽离第三方插件 test: /node_modules/, // 指定是node_modules下的第三方包 chunks: 'initial', name: 'vendor', // 打包后的文件名，任意命名 // 设置优先级，防止和自定义的公共代码提取时被覆盖，不进行打包 priority: 10 &#125; &#125; &#125; &#125;&#125; hashhash 是干嘛用的？我们每次打包出来的结果可能都是同一个文件，那我上线的时候是不是要替换掉上线的 js，那我怎么知道哪是最新的呢，我们一般会清一下缓存。而 hash 就是为了解决这个问题而存在的 我们此时在改一些 webpack.config.js 的配置 1234567891011121314module.exports = &#123; //... output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].[hash:8].js' &#125;, //... plugins: [ new MiniCssExtractPlugin(&#123; filename: '[name].[hash:8].css', chunkFilename: '[id].[hash:8].css' &#125;) ]&#125; 减少 resolve 的解析，配置别名如果我们可以精简 resolve 配置，让 webpack 在查询模块路径时尽可能快速地定位到需要的模块，不做额外的查询工作，那么 webpack 的构建速度也会快一些 123456789101112131415161718192021module.exports = &#123; resolve: &#123; /** * alias: 别名的配置 * * extensions: 自动解析确定的扩展, * 比如 import 'xxx/theme.css' 可以在extensions 中添加 '.css'， 引入方式则为 import 'xxx/theme' * @default ['.wasm', '.mjs', '.js', '.json'] * * modules 告诉 webpack 解析模块时应该搜索的目录 * 如果你想要添加一个目录到模块搜索目录，此目录优先于 node_modules/ 搜索 * 这样配置在某种程度上可以简化模块的查找，提升构建速度 @default node_modules 优先 */ alias: &#123; '@': path.resolve(__dirname, 'src'), tool$: path.resolve(__dirname, 'src/utils/tool.js') // 给定对象的键后的末尾添加 $，以表示精准匹配 &#125;, extensions: ['.wasm', '.mjs', '.js', '.json', '.jsx'], modules: [path.resolve(__dirname, 'src'), 'node_modules'] &#125;&#125; webpack-dev-serve上面讲到了都是如何打包文件，但是开发中我们需要一个本地服务，这时我们可以使用 webpack-dev-server 在本地开启一个简单的静态服务来进行开发。 webpack-dev-server 是 webpack 官方提供的一个工具，可以基于当前的 webpack 构建配置快速启动一个静态服务。当 mode 为 development 时，会具备 hot reload 的功能，即当源码文件变化时，会即时更新当前页面，以便你看到最新的效果。… 1npm install webpack-dev-server -D package.json 中 scripts 中添加 1&quot;start&quot;: &quot;webpack-dev-server --mode development&quot; 默认开启一个本地服务的窗口 http://localhost:8080/ 便于开发 配置开发服务器我们可以对 webpack-dev-server 做针对性的配置 123456789module.exports = &#123; // 配置开发服务器 devServer: &#123; port: 1234, open: true, // 自动打开浏览器 compress: true // 服务器压缩 //... proxy、hot &#125;&#125; contentBase: 服务器访问的根目录（可用于访问静态资源） port: 端口 open: 自动打开浏览器 模块热替换(hot module replacement)模块热替换(HMR - Hot Module Replacement)功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度： 保留在完全重新加载页面时丢失的应用程序状态。 只更新变更内容，以节省宝贵的开发时间。 调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。 上面我们 npm start 后修改一次文件，页面就会刷新一次。这样就存在很大问题了，比如我们使用 redux, vuex 等插件，页面一刷新那么存放在 redux, vuex 中的东西就会丢失，非常不利于我们的开发。 HMR 配合 webpack-dev-server ，首先我们配置下 webpack.config.js 123456789101112const webpack = require('webpack')module.exports = &#123; devServer: &#123; //... hot: true &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() //... ]&#125; 配置后还不行，因为 webpack 还不知道你要更新哪里, 修改 src/index.js 文件, 添加 123if (module.hot) &#123; module.hot.accept()&#125; 重启服务，npm start 之后，修改引入 index.js 文件后，页面就不会重新刷新了，这便实现了 HMR 但是但是有个问题是，你修改 css/less 等样式文件并未发生改变， what ? HMR 修改样式表 需要借助于 style-loader， 而我们之前用的是 MiniCssExtractPlugin.loader， 这也好办，修改其中一个 rules 就可以了，我们可以试试改 123456789101112131415161718192021module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.less$/, use: [ // MiniCssExtractPlugin.loader, 'style-loader', 'css-loader', &#123; loader: 'postcss-loader', options: &#123; plugins: [require('autoprefixer')] // 添加css中的浏览器前缀 &#125; &#125;, 'less-loader' ] &#125; ] &#125;&#125; 这样我们修改 less 文件就会发现 HMR 已经实现了。 其实，我们可以发现，dev 下配置的 loader 为 style-loader , 而生产环境下则是需要 MiniCssExtractPlugin.loader 这就涉及到了不同环境之间的配置。可以通过 process.env.NODE_ENV 获取当前是开发环境或者是生产环境，然后配置不同的 loader，这里就不做展开了。下一篇文章打算在做一个 react-cli 或者 vue-cli 的配置，将开发环境的配置与生产环境的配置分开为不同的文件。 结语前面讲到的知识都是 webpack 的一些基础的知识，更多的资料可以查询webpack 中文官网，官网讲的比较详细，我这里也是讲最常的配置，也是一篇入门系列的文章，文中涉及的知识点还有很多地方还需要完善，譬如 优化 webpack 的构建速度， 减小打包的体积等等。 学习 webpack 4.0 还需要多实践，多瞎搞，笔者也是刚刚学习 webpack 的配置，不对之处请各位指出。 下一篇文章打算从零配置一个脚手架，以加深自己对 webpack 的理解。 本文产生的代码：webpack-dev 参考 webpack4.x 入门一篇足矣 Webpack4 不深不浅的实践教程 webpack 之 babel 配置和 HMR 使用 webpack 4 和 Babel 7 配置 Vue.js 工程模板 webpack 4 ：从 0 配置到项目搭建 webpack 详解 手写一个 webpack4.0 配置 Webpack 4 教程：从零配置到生产发布（2018） Webpack 揭秘——走向高阶前端的必经之路 珠峰架构师培训公开课 webpack4.0 进阶 webpack 官网","categories":[{"name":"webpack","slug":"webpack","permalink":"https://weifo.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://weifo.github.io/tags/webpack/"}]},{"title":"面试题积累","slug":"随笔-面试","date":"2019-07-16T12:46:54.000Z","updated":"2020-02-16T13:23:05.983Z","comments":true,"path":"2019/07/16/随笔-面试/","link":"","permalink":"https://weifo.github.io/2019/07/16/随笔-面试/","excerpt":"Javascript正则 匹配整数 1234567var str = '102'// 1. ^(-|\\+) 以 - 或者 + 开头// 2. ? 表示出现或者不出现// 3. [1-9] 取值范围，也是首字符的取值范围// 4. \\d*$ ：* 等价于&#123;0,&#125;，表示出现任意次，有可能不出现。var reg = /^(-|\\+)?[1-9]\\d*$/reg.test(str) 用正则把[1,2,3,4]转换成 &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;","text":"Javascript正则 匹配整数 1234567var str = '102'// 1. ^(-|\\+) 以 - 或者 + 开头// 2. ? 表示出现或者不出现// 3. [1-9] 取值范围，也是首字符的取值范围// 4. \\d*$ ：* 等价于&#123;0,&#125;，表示出现任意次，有可能不出现。var reg = /^(-|\\+)?[1-9]\\d*$/reg.test(str) 用正则把[1,2,3,4]转换成 &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39; 1[1, 2, 3, 4].join().replace(/([^,])/g, \"'$1'\") // 逗号结尾的字符分组，加引号 dgfhfgh254bhku289fgdhdy675gfh 输出 [254,289,675] 12345var str = 'dgfhfgh254bhku289fgdhdy675gfh'str.replace(/\\d&#123;3&#125;/g, $1 =&gt; arr.push(+$1)) // 匹配出现3个数字的字符，+$1 转化为整数// question 假如要匹配连续出现的数字呢？ ↓↓↓str.replace(/\\d+/g, $1 =&gt; arr.push(+$1)) // + 匹配至少出现一次的数字 匹配数字范围 12// 限制 1000-2000，整数const reg = /^-?(?:[0-9]&#123;1,3&#125;|1000)$/ 字符串去重，把 aaacabbbccc 变成 abc 1234567var str = 'aaacabbbbcccc'var reg = /(.).*\\1/gstr.replace(reg, '$1')// \\1 表示的引用之前的那个分组 不管它匹配到什么（比如-），\\1都匹配那个同样的具体某个字符。var reg = /(\\w)\\1+/g // 匹配连续出现的字符 匹配一年中的 12 个月 123456var str = '12'var reg = /^(0?[1-9]|1[0-2])$/gconsole.log(reg.test(str))// 首位 0 时，第二位 1-9// 首位 1 时，第二位 0-2 理论补充 非捕获分组 ?: (?:)会作为匹配校验，并出现在匹配结果字符里面，但不作为子匹配返回。 12345var reg1 = /1(2)/var reg2 = /1(?:2)/'12'.match(reg1) // \"12\", \"2\"...'12'.match(reg2) // \"12\", ... 作用域， eventLoop，异步… 经典题 12345678910111213for (var i = 0; i &lt; 5; i++) &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, i * 1000)&#125; // 结果：每一秒输出一个5// settimeout 是异步, 每一秒在任务队列中添加任务。等主线执行完成后再执行任务队列里的任务var =&gt; let // 解决变量作用域// 为for循环头部的let不仅将i绑定到for循环快中，事实上它将其重新绑定到循环体的每一次迭代中，确保上一次迭代结束的值重新被赋值。// setTimeout里面的function()属于一个新的域，通过 var 定义的变量是无法传入到这个函数执行域中的，通过使用 let 来声明块变量，// 这时候变量就能作用于这个块，所以 function就能使用 i 这个变量了 this 的考察 123456789101112function f() &#123; y = function() &#123; x = 2 &#125; return function() &#123; var x = 3 y() console.log(this.x) &#125;.apply(this, arguments)&#125;f() // 2 变量提升 12345678910111213var a = 1function outer() &#123; var a = 2 function inner() &#123; a++ console.log(a) var a = 3 console.log(a) &#125; inner()&#125;outer() // NaN 3 其他 遍历 html 中所有 dom 节点，并计算 dom 节点数 12345678910111213141516var doms = []function getChildren(parent) &#123; if (parent.children.length &gt; 0) &#123; for (let i = 0; i &lt; parent.children.length; i++) &#123; getChildren(parent.children[i]) &#125; &#125; if (parent.nodeType === 1) &#123; // parent.nodeType === 1：节点是一个元素节点 doms.push(parent) &#125;&#125;getChildren(document)console.log(doms) 随机数 123var random = (m, n) =&gt; m + Math.floor(Math.random() * (n - m))random(1, 4) // 产生 1-4 之间的随机数 实现数组乱序 123456789101112function shuffle(array) &#123; let len = array.length let temp while (len) &#123; const i = Math.floor(Math.random() * len--) temp = array[len] array[len] = array[i] array[i] = temp &#125; return array&#125;shuffle([1, 3, 4, 5, 7])","categories":[{"name":"开发随笔","slug":"开发随笔","permalink":"https://weifo.github.io/categories/开发随笔/"}],"tags":[{"name":"面试系列","slug":"面试系列","permalink":"https://weifo.github.io/tags/面试系列/"}]},{"title":"js - 笔试题收集","slug":"随笔-面试2","date":"2019-07-11T11:57:47.000Z","updated":"2020-02-16T13:24:05.085Z","comments":true,"path":"2019/07/11/随笔-面试2/","link":"","permalink":"https://weifo.github.io/2019/07/11/随笔-面试2/","excerpt":"提取 get 请求参数有这样一个 URL：http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如`{a:&#39;1&#39;, b:’2’, c:’’, d:’xxx’, e:undefined}`。 12345678910111213141516171819let str = 'http://item.taobao.com/item.html?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e&amp;a=2'function test(str) &#123; let params = &#123;&#125; const paramsStr = str.replace(/.*\\?/, '') // 提取参数字符串 // [ 'a=1', 'b=2', 'c=', 'd=xxx', 'e' ] paramsStr.split('&amp;').forEach(v =&gt; &#123; d = v.split('=') // [a, 1] [b, 2] [c, ''] [d, xxx] [e] if (d[0] in params) &#123; Array.isArray(params[d[0]]) ? params[d[0]].push(d[1]) : (params[d[0]] = [params[d[0]], d[1]]) &#125; else &#123; params[d[0]] = d[1] &#125; &#125;) return params&#125;console.log(test(str)) // &#123; a: [ '1', '2' ], b: '2', c: '', d: 'xxx', e: undefined &#125; 数组降维","text":"提取 get 请求参数有这样一个 URL：http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如`{a:&#39;1&#39;, b:’2’, c:’’, d:’xxx’, e:undefined}`。 12345678910111213141516171819let str = 'http://item.taobao.com/item.html?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e&amp;a=2'function test(str) &#123; let params = &#123;&#125; const paramsStr = str.replace(/.*\\?/, '') // 提取参数字符串 // [ 'a=1', 'b=2', 'c=', 'd=xxx', 'e' ] paramsStr.split('&amp;').forEach(v =&gt; &#123; d = v.split('=') // [a, 1] [b, 2] [c, ''] [d, xxx] [e] if (d[0] in params) &#123; Array.isArray(params[d[0]]) ? params[d[0]].push(d[1]) : (params[d[0]] = [params[d[0]], d[1]]) &#125; else &#123; params[d[0]] = d[1] &#125; &#125;) return params&#125;console.log(test(str)) // &#123; a: [ '1', '2' ], b: '2', c: '', d: 'xxx', e: undefined &#125; 数组降维 可以使用 Array.prototype.flat() es6+ 123456let arr = [[1, 2], [3, 4]]let newArr = arr.flat() // [1, 2, 3, 4] 默认降维一层// 手写let newArr2 = Array.prototype.concat.apply([], arr) // [1, 2, 3, 4] js 计算 1234567891011121314const arr = [1, 8, 6, 2, 5, 4, 8, 3, 7]function maxArea(arr) &#123; let [start, area] = [0, 0] let end = arr.length - 1 while (start &lt; end) &#123; const h = Math.min(arr[start], arr[end]) const result = h * (end - start) area = result &gt; area ? result : area arr[start] &gt; arr[end] ? end-- : start++ &#125; return area&#125;console.log(maxArea(arr)) // 49 返回 1 到 400 所有自然数中一共出现过多少次“1”，如 1 到 21 一共出现过 13 次“1” 1234567let count = 0for (let num = 1; num &lt;= number; num++) &#123; ;`$&#123;num&#125;`.replace(/1/g, () =&gt; count++)&#125;console.log(count) // 180 正则给定字符串 str，检查其是否包含连续重复的字母（a-zA-Z），包含返回 true，否则返回 false 123456let str = 'adfdsaccsdd'function containsRepeatingLetter(str) &#123; return /([a-zA-Z])\\1/.test(str) // // \\1指代第一个括号的匹配项&#125;console.log(containsRepeatingLetter(str)) // true 在正则表达式中，利用()进行分组，使用斜杠加数字表示引用，\\1 就是引用第一个分组，\\2 就是引用第二个分组。将[a-zA-Z]做为一个分组，然后引用，就可以判断是否有连续重复的字母。 字符串转驼峰例如：border-bottom-color —-&gt; borderBottomColor 1234567891011let str = 'border-bottom-color'function toHump(params) &#123; let newStr = '' params.split('-').forEach((d, i) =&gt; &#123; newStr += i === 0 ? d : `$&#123;d.charAt(0).toUpperCase()&#125;$&#123;d.substring(1)&#125;` &#125;) return newStr&#125;console.log(toHump(str)) // borderBottomColor","categories":[{"name":"开发随笔","slug":"开发随笔","permalink":"https://weifo.github.io/categories/开发随笔/"}],"tags":[{"name":"面试系列","slug":"面试系列","permalink":"https://weifo.github.io/tags/面试系列/"}]},{"title":"页面重绘和回流以及优化","slug":"随笔-重排和重绘","date":"2019-07-10T12:51:52.000Z","updated":"2020-02-16T13:24:20.099Z","comments":true,"path":"2019/07/10/随笔-重排和重绘/","link":"","permalink":"https://weifo.github.io/2019/07/10/随笔-重排和重绘/","excerpt":"重绘 redraw &amp; 重排 reflow浏览器运行机制图： 浏览器的运行机制 1.构建DOM树（parse）： 渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node（包括js生成的标签）生成内容树（Content Tree/DOM Tree）； 2.构建渲染树（construct）：解析对应的CSS样式文件信息（包括js生成的样式和外部css文件），而这些文件信息以及HTML中可见的指令（如），构建渲染树（Rendering Tree/Frame Tree）； 3.布局渲染树（reflow/layout）：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标； 4.绘制渲染树（paint/repaint）：遍历渲染树，使用UI后端层来绘制每个节点。","text":"重绘 redraw &amp; 重排 reflow浏览器运行机制图： 浏览器的运行机制 1.构建DOM树（parse）： 渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node（包括js生成的标签）生成内容树（Content Tree/DOM Tree）； 2.构建渲染树（construct）：解析对应的CSS样式文件信息（包括js生成的样式和外部css文件），而这些文件信息以及HTML中可见的指令（如），构建渲染树（Rendering Tree/Frame Tree）； 3.布局渲染树（reflow/layout）：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标； 4.绘制渲染树（paint/repaint）：遍历渲染树，使用UI后端层来绘制每个节点。 重绘（repaint或redraw）当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。触发重绘的条件：改变元素外观属性。如：color，background-color等。 注意：table及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用table布局页面的原因之一。 重排（重构/回流/reflow）当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。所以，重排必定会引发重绘，但重绘不一定会引发重排。触发重排的条件：任何页面布局和几何属性的改变都会触发重排，比如： 页面渲染初始化；(无法避免) 添加或删除可见的DOM元素； 元素位置的改变，或者使用动画； 元素尺寸的改变——大小，外边距，边框； 浏览器窗口尺寸的变化（resize事件发生时）； 填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变； 读取某些元素属性：（offsetLeft/Top/Height/Width, clientTop/Left/Width/Height, scrollTop/Left/Width/Height, width/height, getComputedStyle(), currentStyle(IE) ) 重绘重排的代价：耗时，导致浏览器卡慢。 优化 浏览器自己的优化：浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。 我们要注意的优化：我们要减少重绘和重排就是要减少对渲染树的操作，则我们可以合并多次的DOM和样式的修改。并减少对style样式的请求。 直接改变元素的className display：none；先设置元素为display：none；然后进行页面布局等操作；设置完成后将元素设置为display：block；这样的话就只引发两次重绘和重排； 不要经常访问浏览器的flush队列属性；如果一定要访问，可以利用缓存。将访问的值存储起来，接下来使用就不会再引发回流； 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘； 将需要多次重排的元素，position属性设为absolute或fixed，元素脱离了文档流，它的变化不会影响到其他元素； 如果需要创建多个DOM节点，可以使用DocumentFragment创建完后一次性的加入document； 尽量不要使用table布局。","categories":[{"name":"开发随笔","slug":"开发随笔","permalink":"https://weifo.github.io/categories/开发随笔/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"https://weifo.github.io/tags/DOM/"}]},{"title":"HTTP - TCP 三次握手四次挥手","slug":"http-TCP","date":"2018-11-21T01:47:17.000Z","updated":"2019-03-18T15:39:40.000Z","comments":true,"path":"2018/11/21/http-TCP/","link":"","permalink":"https://weifo.github.io/2018/11/21/http-TCP/","excerpt":"TCP 的三次握手 HTTP 请求与 TCP 链接之间的关系，在客户端向服务端请求和返回的过程中，是需要去创建一个 TCP connection，因为 HTTP 是不存在链接这样一个概念的，它只有请求和响应这样一个概念，请求和响应都是一个数据包，中间要通过一个传输通道，这个传输通道就是在 TCP 里面创建了一个从客户端发起和服务端接收的一个链接，TCP 链接在创建的时候是有一个三次握手(三次网络传输)这样一个消耗在的。 下面是 TCP 报文格式图： ↓↓↓↓ 有几个字段需要重点介绍下： Seq 序号: sequeence number，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。 确认序号：acknowledgment number，只有 ACK 标志位为 1 时，确认序号字段才有效，Ack=Seq+1。 标志位：共 6 个，即 URG、ACK、PSH、RST、SYN、FIN 等，具体含义如下： URG：紧急指针（urgent pointer）有效。 ACK：确认序号有效。 PSH：接收方应该尽快将这个报文交给应用层。 RST：重置连接。 SYN：发起一个新连接。 FIN：释放一个连接。","text":"TCP 的三次握手 HTTP 请求与 TCP 链接之间的关系，在客户端向服务端请求和返回的过程中，是需要去创建一个 TCP connection，因为 HTTP 是不存在链接这样一个概念的，它只有请求和响应这样一个概念，请求和响应都是一个数据包，中间要通过一个传输通道，这个传输通道就是在 TCP 里面创建了一个从客户端发起和服务端接收的一个链接，TCP 链接在创建的时候是有一个三次握手(三次网络传输)这样一个消耗在的。 下面是 TCP 报文格式图： ↓↓↓↓ 有几个字段需要重点介绍下： Seq 序号: sequeence number，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。 确认序号：acknowledgment number，只有 ACK 标志位为 1 时，确认序号字段才有效，Ack=Seq+1。 标志位：共 6 个，即 URG、ACK、PSH、RST、SYN、FIN 等，具体含义如下： URG：紧急指针（urgent pointer）有效。 ACK：确认序号有效。 PSH：接收方应该尽快将这个报文交给应用层。 RST：重置连接。 SYN：发起一个新连接。 FIN：释放一个连接。 第一次握手 客户端发送一个 TCP 的 SYN 标志位置 1 的包指明客户打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。 简单记忆： 建立连接，等待服务器确认 Sequeence Number = X =&gt; 标识字节流字段为 X SYN = 1 =&gt; 发起一个新连接，序号为 1 第二次握手 服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为 1 同时，将确认序号(Acknowledgement Number)设置为客户的 I S N 加 1 以.即 X+1。 简单记忆： 服务器收到请求后确认联机 Sequeence Number = Y =&gt; 标识字节流字段为 Y acknowledgment number = X + 1 =&gt; 确认序号为 X + 1 SYN = 1 =&gt; 发起一个新连接，序号为 1 ACK = 1 =&gt; 确认序号有效 第三次握手 客户端再次发送确认包(ACK)SYN 标志位为 0,ACK 标志位为 1.并且把服务器发来 ACK 的序号字段+1,放在确定字段中发送给对方.并且在数据段放写 ISN 的+1 简单记忆：检查 ACK 是否正确, 若正确则建立连接。 acknowledgment number = Y + 1 =&gt; 确认序号为 Y + 1 ACK = 1 =&gt; 确认序号有效 TCP 四次挥手TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close()操作即可产生挥手操作。 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？这是因为服务端在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。而关闭连接时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即 close，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送。","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://weifo.github.io/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://weifo.github.io/tags/HTTP/"}]},{"title":"webpack - babel篇","slug":"webpack-babel","date":"2018-10-01T06:23:24.000Z","updated":"2020-02-16T13:25:39.050Z","comments":true,"path":"2018/10/01/webpack-babel/","link":"","permalink":"https://weifo.github.io/2018/10/01/webpack-babel/","excerpt":"Babel 是一个让我们能够使用 ES 新特性的 JS 编译工具，我们可以在 webpack 中配置 Babel，以便使用 ES6、ES7 标准来编写 JS 代码。 本文以当前最新版本的 babel - 7.10 为例， 做 babel 的配置. 相关版本号如下 123456789101112&#123; \"devDependencies\": &#123; \"@babel/core\": \"^7.1.6\", \"@babel/plugin-proposal-decorators\": \"^7.1.6\", \"@babel/plugin-transform-runtime\": \"^7.1.0\", \"@babel/preset-env\": \"^7.1.6\", \"@babel/runtime\": \"^7.1.5\", \"babel-loader\": \"^8.0.4\", \"webpack\": \"^4.26.1\", \"webpack-cli\": \"^3.1.2\" &#125;&#125;","text":"Babel 是一个让我们能够使用 ES 新特性的 JS 编译工具，我们可以在 webpack 中配置 Babel，以便使用 ES6、ES7 标准来编写 JS 代码。 本文以当前最新版本的 babel - 7.10 为例， 做 babel 的配置. 相关版本号如下 123456789101112&#123; \"devDependencies\": &#123; \"@babel/core\": \"^7.1.6\", \"@babel/plugin-proposal-decorators\": \"^7.1.6\", \"@babel/plugin-transform-runtime\": \"^7.1.0\", \"@babel/preset-env\": \"^7.1.6\", \"@babel/runtime\": \"^7.1.5\", \"babel-loader\": \"^8.0.4\", \"webpack\": \"^4.26.1\", \"webpack-cli\": \"^3.1.2\" &#125;&#125; babel-loader 和 @babel/core建立基本的 webpack 配置文件 1234567891011mkdir webpack-babel =&gt; cd webpack-babel =&gt; yarn init -y // 初始化npm i yarn -g // 安装了yarn可以忽略yarn add webpack webpack-cli -D// package.json 中添加：\"scripts\": &#123; \"start\": \"webpack --mode development\", \"build\": \"webpack --mode production\"&#125;yarn add babel-loader @babel/core -D yarn : 和 npm 几乎一样，本文使用 yarn 安装… babel-loader: 转义 js 文件代码的 loader @babel/core：babel 核心库 根目录下添加 webpack.config.js 123456789101112131415161718const path = require('path')module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].[hash:8].js' &#125;, module: &#123; rules: [ &#123; test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader' &#125; // options 在 .babelrc 定义 &#125; ] &#125;&#125; src/index.js 123456789101112const func = () =&gt; &#123; console.log('hello webpack')&#125;func()class User &#123; constructor() &#123; console.log('new User') &#125;&#125;const user = new User() 执行 yarn build 后就可以打包成功，打包后的代码是压缩后的。而 yarn start 后的代码是未压缩的。为了使代码可读性高一点，我们可以在webpack.config.js添加： 1234module.exports = &#123; //... devtool: true&#125; @babel-preset-env打包后我们可以发现箭头函数并未转化为 ES5 语法！ 查阅 babel plugins 文档，如果要转义箭头函数，需要使用到 @babel/plugin-transform-arrow-functions 这个插件同理转义 class 需要使用 @babel/plugin-transform-classes 1yarn add @babel/plugin-transform-arrow-functions @babel/plugin-transform-classes -D 根目录下建立 .babelrc 文件： 123456&#123; \"plugins\": [ \"@babel/plugin-transform-arrow-functions\", \"@babel/plugin-transform-classes\" ]&#125; yarn build 之后可以看出 箭头函数和类都被转义了。 但是假如你再使用 async await 之类的 es6 语法，你还得一个个添加，这是不实际的。 @babel-preset-env 就整合了这些语法转义插件： 123456789Using plugins:transform-template-literals &#123;&#125;transform-literals &#123;&#125;transform-function-name &#123;&#125;transform-arrow-functions &#123;&#125;transform-block-scoped-functions &#123;&#125;transform-classes &#123;&#125;transform-object-super &#123;&#125;//... 使用如下： 1yarn add @babel-preset-env -D .babelrc 123&#123; \"presets\": [\"@babel/preset-env\"]&#125; @babel/polyfill Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API ，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转码。 这样就导致了一些新的 API 老版浏览器不兼容。如上述所说，对于新的 API，你可能需要引入 @babel-polyfill 来进行兼容 1yarn add @babel-polyfill -D 修改 weboack.config.js 123module.exports = &#123; entry: ['@babel-polyfill', './src/index.js']&#125; yarn build 发现文件体积大了很多，因为上面的代码表示将 @babel-polyfill 的代码也打包进去了。 当然这不是我们希望的，如何按需编译呢？ 我们可以这么做： index.js 123456789101112131415161718import '@babel/polyfill' // 引入const func = () =&gt; &#123; console.log('hello webpack')&#125;func()class User &#123; constructor() &#123; console.log('new User') &#125;&#125;const user = new User()new Promise(resolve =&gt; console.log('promise'))Array.from('foo') 还原 webpack.config.js 123module.exports = &#123; entry: './src/index.js'&#125; 修改 .babelrc 123&#123; \"presets\": [[\"@babel/preset-env\", &#123; \"useBuiltIns\": \"usage\" &#125;]]&#125; yarn build 后发现我们的代码体积就变得很小了！ @babel/runtime 和 @babel/plugin-transform-runtime babel-polyfill 会污染全局作用域, 如引入 Array.prototype.includes 修改了 Array 的原型，除此外还有 String… babel-polyfill 引入新的对象： Promise、WeakMap 等 这也不是我们希望出现的。 @babel/runtime 的作用： 提取辅助函数。ES6 转码时，babel 会需要一些辅助函数，例如 _extend。babel 默认会将这些辅助函数内联到每一个 js 文件里， babel 提供了 transform-runtime 来将这些辅助函数“搬”到一个单独的模块 babel-runtime 中，这样做能减小项目文件的大小。 提供 polyfill：不会污染全局作用域，但是不支持实例方法如 Array.includes @transform-runtime 的作用： babel-runtime 更像是分散的 polyfill 模块，需要在各自的模块里单独引入，借助 transform-runtime 插件来自动化处理这一切，也就是说你不要在文件开头 import 相关的 polyfill，你只需使用，transform-runtime 会帮你引入。 12yarn add @babel/runtime-corejs2yarn add @babel/plugin-transform-runtime -D 修改 .babelrc 1234&#123; \"presets\": [\"@babel/preset-env\"], \"plugins\": [[\"@babel/plugin-transform-runtime\", &#123; \"corejs\": 2 &#125;]]&#125; index.js 移除 import &#39;@babel/polyfill&#39; @babel/plugin-proposal-decorators添加装饰器模式的支持 1yarn add @babel/plugin-proposal-decorators -D index.js 1234567891011function annotation(target) &#123; target.annotated = true&#125;@annotationclass User &#123; constructor() &#123; console.log('new User') &#125;&#125;//... .babelrc 1234567&#123; \"presets\": [\"@babel/preset-env\"], \"plugins\": [ [\"@babel/plugin-proposal-decorators\", &#123; \"decoratorsBeforeExport\": true &#125;], [\"@babel/plugin-transform-runtime\", &#123; \"corejs\": 2 &#125;] ]&#125;","categories":[{"name":"webpack","slug":"webpack","permalink":"https://weifo.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://weifo.github.io/tags/webpack/"}]}]}