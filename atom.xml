<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>weifo</title>
  
  <subtitle>选择你所爱的，爱你所选择的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://weifo.github.io/"/>
  <updated>2022-06-07T21:50:16.400Z</updated>
  <id>https://weifo.github.io/</id>
  
  <author>
    <name>weifo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue Keep-alive中的钩子函数</title>
    <link href="https://weifo.github.io/2022/05/05/keep-alive/"/>
    <id>https://weifo.github.io/2022/05/05/keep-alive/</id>
    <published>2022-05-05T00:06:00.000Z</published>
    <updated>2022-06-07T21:50:16.400Z</updated>
    
    <content type="html"><![CDATA[<p>–</p><p>说到Vue的钩子函数，可能很多人只停留在一些很简单常用的钩子(<code>created</code>,<code>mounted</code>)，而且对于里面的区别，什么时候该用什么钩子，并没有仔细的去研究过，且Vue的生命周期在面试中也算是比较高频的考点，那么该如何回答这类问题，让人有眼前一亮的感觉呢…</p><hr><h2 id="Vue-Router导航守卫："><a href="#Vue-Router导航守卫：" class="headerlink" title="Vue-Router导航守卫："></a>Vue-Router导航守卫：</h2><p>有的时候，我们需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。</p><p>为此我们有很多种方法可以植入路由的导航过程：<strong>全局的, 单个路由独享的, 或者组件级的</strong>,推荐优先阅读<a href="https://link.juejin.cn?target=https%3A%2F%2Frouter.vuejs.org%2Fzh%2Fguide%2Fadvanced%2Fnavigation-guards.html" title="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html" target="_blank" rel="noopener">路由文档</a></p><h3 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h3><p>vue-router全局有三个守卫：</p><ol><li>router.beforeEach 全局前置守卫 进入路由之前</li><li>router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用</li><li>router.afterEach 全局后置钩子 进入路由之后</li></ol><p><strong>使用方法</strong>：</p><pre><code>    // main.js 入口文件    import router from &apos;./router&apos;; // 引入路由    router.beforeEach((to, from, next) =&gt; {       next();    });    router.beforeResolve((to, from, next) =&gt; {      next();    });    router.afterEach((to, from) =&gt; {      console.log(&apos;afterEach 全局后置钩子&apos;);    });复制代码</code></pre><h4 id="to-from-next-这三个参数："><a href="#to-from-next-这三个参数：" class="headerlink" title="to,from,next 这三个参数："></a>to,from,next 这三个参数：</h4><p>to和from是<strong>将要进入和将要离开的路由对象</strong>,路由对象指的是平时通过this.$route获取到的路由对象。</p><p><strong>next:Function</strong> 这个参数是个函数，且<strong>必须调用，否则不能进入路由</strong>(页面空白)。</p><ul><li><p>next() 进入该路由。</p></li><li><p>next(false): 取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)。</p></li><li><p>next 跳转新路由，当前的导航被中断，重新开始一个新的导航。</p><pre><code>  我们可以这样跳转：next(&apos;path地址&apos;)或者next({path:&apos;&apos;})或者next({name:&apos;&apos;})  且允许设置诸如 replace: true、name: &apos;home&apos; 之类的选项  以及你用在router-link或router.push的对象选项。复制代码</code></pre></li></ul><h3 id="路由独享守卫"><a href="#路由独享守卫" class="headerlink" title="路由独享守卫"></a>路由独享守卫</h3><p>如果你不想全局配置守卫的话，你可以为某些路由单独配置守卫：</p><pre><code>    const router = new VueRouter({      routes: [        {          path: &apos;/foo&apos;,          component: Foo,          beforeEnter: (to, from, next) =&gt; {             // 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖            // ...          }        }      ]    })复制代码</code></pre><h3 id="路由组件内的守卫："><a href="#路由组件内的守卫：" class="headerlink" title="路由组件内的守卫："></a>路由组件内的守卫：</h3><ol><li>beforeRouteEnter 进入路由前</li><li>beforeRouteUpdate (2.2) 路由复用同一个组件时</li><li>beforeRouteLeave 离开当前路由时</li></ol><p><strong>文档中的介绍：</strong></p><pre><code>  beforeRouteEnter (to, from, next) {    // 在路由独享守卫后调用 不！能！获取组件实例 `this`，组件实例还没被创建  },  beforeRouteUpdate (to, from, next) {    // 在当前路由改变，但是该组件被复用时调用 可以访问组件实例 `this`    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。  },  beforeRouteLeave (to, from, next) {    // 导航离开该组件的对应路由时调用，可以访问组件实例 `this`  }复制代码</code></pre><p><strong>beforeRouteEnter访问this</strong></p><p>因为钩子在组件实例还没被创建的时候调用，所以不能获取组件实例 <code>this</code>，可以通过传一个回调给<code>next</code>来访问组件实例 。</p><p>但是<strong>回调的执行时机在mounted后面</strong>,所以在我看来这里对this的访问意义不太大，可以放在<code>created</code>或者<code>mounted</code>里面。</p><pre><code>    beforeRouteEnter (to, from, next) {    console.log(&apos;在路由独享守卫后调用&apos;);      next(vm =&gt; {        // 通过 `vm` 访问组件实例`this` 执行回调的时机在mounted后面，      })    }复制代码</code></pre><p><strong>beforeRouteLeave：</strong></p><p>导航离开该组件的对应路由时调用，我们用它来禁止用户离开，比如还未保存草稿，或者在用户离开前，将<code>setInterval</code>销毁，防止离开之后，定时器还在调用。</p><pre><code>    beforeRouteLeave (to, from , next) {      if (文章保存) {        next(); // 允许离开或者可以跳到别的路由 上面讲过了      } else {        next(false); // 取消离开      }    }复制代码</code></pre><h3 id="关于钩子的一些知识："><a href="#关于钩子的一些知识：" class="headerlink" title="关于钩子的一些知识："></a>关于钩子的一些知识：</h3><h4 id="路由钩子函数的错误捕获"><a href="#路由钩子函数的错误捕获" class="headerlink" title="路由钩子函数的错误捕获"></a>路由钩子函数的错误捕获</h4><p>如果我们在全局守卫/路由独享守卫/组件路由守卫的钩子函数中有错误，可以这样捕获：</p><pre><code>    router.onError(callback =&gt; {     // 2.4.0新增 并不常用，了解一下就可以了       console.log(callback, &apos;callback&apos;);    });复制代码</code></pre><p>在路由文档中还有更多的<a href="https://link.juejin.cn?target=https%3A%2F%2Frouter.vuejs.org%2Fzh%2Fapi%2F%23router-%25E5%25AE%259E%25E4%25BE%258B%25E6%2596%25B9%25E6%25B3%2595" title="https://router.vuejs.org/zh/api/#router-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">实例方法</a>：动态添加路由等，有兴趣可以了解一下。</p><h4 id="跳转死循环，页面永远空白"><a href="#跳转死循环，页面永远空白" class="headerlink" title="跳转死循环，页面永远空白"></a>跳转死循环，页面永远空白</h4><p>我了解到的，很多人会碰到这个问题，来看一下这段伪代码：</p><pre><code>    router.beforeEach((to, from, next) =&gt; {      if(登录){         next()      }else{          next({ name: &apos;login&apos; });       }    });复制代码</code></pre><p>看逻辑貌似是对的，但是当我们跳转到<code>login</code>之后，因为此时还是未登录状态，所以会一直跳转到<code>login</code>然后死循环，页面一直是空白的，所以：我们需要把判断条件稍微改一下。</p><pre><code>    if(登录 || to.name === &apos;login&apos;){ next() } // 登录，或者将要前往login页面的时候，就允许进入路由复制代码</code></pre><h4 id="全局后置钩子的跳转："><a href="#全局后置钩子的跳转：" class="headerlink" title="全局后置钩子的跳转："></a>全局后置钩子的跳转：</h4><p>文档中提到因为router.afterEach不接受<code>next</code>函数所以也不会改变导航本身，意思就是只能当成一个钩子来使用，但是我自己在试的时候发现，我们可以通过这种形式来实现跳转：</p><pre><code>    // main.js 入口文件    import router from &apos;./router&apos;; // 引入路由    router.afterEach((to, from) =&gt; {      if (未登录 &amp;&amp; to.name !== &apos;login&apos;) {        router.push({ name: &apos;login&apos; }); // 跳转login      }    });复制代码</code></pre><p>额，通过router.beforeEach 也完全可以实现且更好，我就骚一下。</p><h3 id="完整的路由导航解析流程-不包括其他生命周期-："><a href="#完整的路由导航解析流程-不包括其他生命周期-：" class="headerlink" title="完整的路由导航解析流程(不包括其他生命周期)："></a>完整的路由导航解析流程(不包括其他生命周期)：</h3><ol><li>触发进入其他路由。</li><li>调用要离开路由的组件守卫<code>beforeRouteLeave</code></li><li>调用局前置守卫：<code>beforeEach</code></li><li>在重用的组件里调用 <code>beforeRouteUpdate</code></li><li>调用路由独享守卫 <code>beforeEnter</code>。</li><li>解析异步路由组件。</li><li>在将要进入的路由组件中调用<code>beforeRouteEnter</code></li><li>调用全局解析守卫 <code>beforeResolve</code></li><li>导航被确认。</li><li>调用全局后置钩子的 <code>afterEach</code> 钩子。</li><li>触发DOM更新(<code>mounted</code>)。</li><li>执行<code>beforeRouteEnter</code> 守卫中传给 next 的回调函数</li></ol><hr><h2 id="你不知道的keep-alive-我猜你不知道"><a href="#你不知道的keep-alive-我猜你不知道" class="headerlink" title="你不知道的keep-alive[我猜你不知道]"></a>你不知道的keep-alive[我猜你不知道]</h2><p>在开发Vue项目的时候，大部分组件是没必要多次渲染的，所以Vue提供了一个内置组件<code>keep-alive</code>来<strong>缓存组件内部状态，避免重新渲染</strong>，<a href="https://link.juejin.cn?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fapi%2F%23keep-alive" title="https://cn.vuejs.org/v2/api/#keep-alive" target="_blank" rel="noopener">文档在这里</a>。</p><blockquote><p>文档：和 <code>&lt;transition&gt;</code>相似，<code>&lt;keep-alive&gt;</code> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。</p></blockquote><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><p><strong>缓存动态组件：</strong></p><p><code>&lt;keep-alive&gt;</code>包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们，此种方式并无太大的实用意义。</p><pre><code>    &lt;!-- 基本 --&gt;    &lt;keep-alive&gt;      &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;    &lt;/keep-alive&gt;    &lt;!-- 多个条件判断的子组件 --&gt;    &lt;keep-alive&gt;      &lt;comp-a v-if=&quot;a &gt; 1&quot;&gt;&lt;/comp-a&gt;      &lt;comp-b v-else&gt;&lt;/comp-b&gt;    &lt;/keep-alive&gt;复制代码</code></pre><p><strong>缓存路由组件：</strong></p><p>使用<code>keep-alive</code>可以将所有路径匹配到的路由组件都缓存起来，包括路由组件里面的组件，<code>keep-alive</code>大多数使用场景就是这种。</p><pre><code>    &lt;keep-alive&gt;        &lt;router-view&gt;&lt;/router-view&gt;    &lt;/keep-alive&gt;复制代码</code></pre><h3 id="生命周期钩子："><a href="#生命周期钩子：" class="headerlink" title="生命周期钩子："></a>生命周期钩子：</h3><p>这篇既然是Vue钩子函数的专场，那肯定要扣题呀~</p><p>在被<code>keep-alive</code>包含的组件/路由中，会多出两个生命周期的钩子:<code>activated</code> 与 <code>deactivated</code>。</p><blockquote><p>文档：在 2.2.0 及其更高版本中，activated 和 deactivated 将会在 树内的<strong>所有嵌套组件</strong>中触发。</p></blockquote><p><strong>activated在组件第一次渲染时会被调用，之后在每次缓存组件被激活时调用</strong>。</p><p><strong>activated调用时机：</strong></p><p>第一次进入缓存路由/组件，在<code>mounted</code>后面，<code>beforeRouteEnter</code>守卫传给 next 的回调函数之前调用：</p><pre><code>    beforeMount=&gt; 如果你是从别的路由/组件进来(组件销毁destroyed/或离开缓存deactivated)=&gt;    mounted=&gt; activated 进入缓存组件 =&gt; 执行 beforeRouteEnter回调复制代码</code></pre><p>因为组件被缓存了，<strong>再次进入缓存路由/组件时，不会触发这些钩子</strong>：</p><pre><code>    // beforeCreate created beforeMount mounted 都不会触发。复制代码</code></pre><p>所以之后的调用时机是：</p><pre><code>    组件销毁destroyed/或离开缓存deactivated =&gt; activated 进入当前缓存组件     =&gt; 执行 beforeRouteEnter回调    // 组件缓存或销毁，嵌套组件的销毁和缓存也在这里触发复制代码</code></pre><p><strong>deactivated：组件被停用(离开路由)时调用</strong></p><p><strong>使用了<code>keep-alive</code>就不会调用<code>beforeDestroy</code>(组件销毁前钩子)和<code>destroyed</code>(组件销毁)，因为组件没被销毁，被缓存起来了</strong>。</p><p>这个钩子可以看作<code>beforeDestroy</code>的替代，如果你缓存了组件，要在组件销毁的的时候做一些事情，你可以放在这个钩子里。</p><p>如果你离开了路由，会依次触发：</p><pre><code>    组件内的离开当前路由钩子beforeRouteLeave =&gt;  路由前置守卫 beforeEach =&gt;    全局后置钩子afterEach =&gt; deactivated 离开缓存组件 =&gt; activated 进入缓存组件(如果你进入的也是缓存路由)    // 如果离开的组件没有缓存的话 beforeDestroy会替换deactivated     // 如果进入的路由也没有缓存的话  全局后置钩子afterEach=&gt;销毁 destroyed=&gt; beforeCreate等复制代码</code></pre><p>那么，如果我只是想缓存其中几个路由/组件，那该怎么做？</p><h3 id="缓存你想缓存的路由："><a href="#缓存你想缓存的路由：" class="headerlink" title="缓存你想缓存的路由："></a>缓存你想缓存的路由：</h3><h4 id="Vue2-1-0之前"><a href="#Vue2-1-0之前" class="headerlink" title="Vue2.1.0之前:"></a>Vue2.1.0之前:</h4><p>想实现类似的操作，你可以：</p><ol><li><p>配置一下路由元信息</p></li><li><p>创建两个<code>keep-alive</code>标签</p></li><li><p>使用<code>v-if</code>通过路由元信息判断缓存哪些路由。</p><pre><code> &lt;keep-alive&gt;     &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;         &lt;!--这里是会被缓存的路由--&gt;     &lt;/router-view&gt; &lt;/keep-alive&gt; &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;     &lt;!--因为用的是v-if 所以下面还要创建一个未缓存的路由视图出口--&gt; &lt;/router-view&gt; //router配置 new Router({   routes: [     {       path: &apos;/&apos;,       name: &apos;home&apos;,       component: Home,       meta: {         keepAlive: true // 需要被缓存       }     },     {       path: &apos;/:id&apos;,       name: &apos;edit&apos;,       component: Edit,       meta: {         keepAlive: false // 不需要被缓存       }     }   ] });复制代码</code></pre></li></ol><h4 id="Vue2-1-0版本之后："><a href="#Vue2-1-0版本之后：" class="headerlink" title="Vue2.1.0版本之后："></a>Vue2.1.0版本之后：</h4><p>使用路由元信息的方式，要多创建一个<code>router-view</code>标签，并且每个路由都要配置一个元信息，是可以实现我们想要的效果，但是过于繁琐了点。</p><p>幸运的是在Vue2.1.0之后，Vue新增了两个属性配合<code>keep-alive</code>来有条件地缓存 路由/组件。</p><p><strong>新增属性：</strong></p><ul><li><code>include</code>：匹配的 路由/组件 会被缓存</li><li><code>exclude</code>：匹配的 路由/组件 不会被缓存</li></ul><p><code>include</code>和<code>exclude</code>支持三种方式来有条件的缓存路由：采用逗号分隔的字符串形式，正则形式，数组形式。</p><p>正则和数组形式，必须采用<code>v-bind</code>形式来使用。</p><p><strong>缓存组件的使用方式</strong>：</p><pre><code>    &lt;!-- 逗号分隔字符串 --&gt;    &lt;keep-alive include=&quot;a,b&quot;&gt;      &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;    &lt;/keep-alive&gt;    &lt;!-- 正则表达式 (使用 `v-bind`) --&gt;    &lt;keep-alive :include=&quot;/a|b/&quot;&gt;      &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;    &lt;/keep-alive&gt;    &lt;!-- 数组 (使用 `v-bind`) --&gt;    &lt;keep-alive :include=&quot;[&apos;a&apos;, &apos;b&apos;]&quot;&gt;      &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;    &lt;/keep-alive&gt;复制代码</code></pre><p><strong>但更多场景中，我们会使用<code>keep-alive</code>来缓存路由</strong>：</p><pre><code>&lt;keep-alive include=&apos;a&apos;&gt;    &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;复制代码</code></pre><p><strong>匹配规则：</strong></p><ol><li><strong>首先匹配组件的name选项</strong>，如果<code>name</code>选项不可用。</li><li>则匹配它的<strong>局部注册名称</strong>。 (父组件 <code>components</code> 选项的键值)</li><li><strong>匿名组件，不可匹配</strong>。</li></ol><p>比如路由组件没有<code>name</code>选项，并且没有注册的组件名。</p><ol start="4"><li>只能匹配当前被包裹的组件，<strong>不能匹配更下面嵌套的子组件</strong>。</li></ol><p>比如用在路由上，只能匹配路由组件的<code>name</code>选项，不能匹配路由组件里面的嵌套组件的<code>name</code>选项。</p><ol start="5"><li>文档：<code>&lt;keep-alive&gt;</code><strong>不会在函数式组件中正常工作</strong>，因为它们没有缓存实例。</li><li><strong><code>exclude</code>的优先级大于<code>include</code></strong></li></ol><p>也就是说：当<code>include</code>和<code>exclude</code>同时存在时，<code>exclude</code>生效，<code>include</code>不生效。</p><pre><code>  &lt;keep-alive include=&quot;a,b&quot; exclude=&quot;a&quot;&gt;    &lt;!--只有a不被缓存--&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/keep-alive&gt;复制代码</code></pre><p><strong>当组件被<code>exclude</code>匹配，该组件将不会被缓存，不会调用<code>activated</code> 和 <code>deactivated</code></strong>。</p><hr><h2 id="组件生命周期钩子："><a href="#组件生命周期钩子：" class="headerlink" title="组件生命周期钩子："></a>组件生命周期钩子：</h2><p>关于组件的生命周期，是时候放出这张图片了：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/21/164bbf610b61f3cd~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt></p><p>这张图片已经讲得很清楚了，很多人这部分也很清楚了，大部分生命周期并不会用到，这里提一下几点：</p><ol><li><p><strong>ajax请求最好放在<code>created</code>里面</strong>，因为此时已经可以访问<code>this</code>了，请求到数据就可以直接放在<code>data</code>里面。</p><p>这里也碰到过几次，面试官问：ajax请求应该放在哪个生命周期。</p></li><li><p><strong>关于dom的操作要放在<code>mounted</code>里面</strong>，在<code>mounted</code>前面访问dom会是<code>undefined</code>。</p></li><li><p>每次进入/离开组件都要做一些事情，用什么钩子：</p></li></ol><ul><li><p>不缓存：</p><p>进入的时候可以用<code>created</code>和<code>mounted</code>钩子，离开的时候用<code>beforeDestory</code>和<code>destroyed</code>钩子,<code>beforeDestory</code>可以访问<code>this</code>，<code>destroyed</code>不可以访问<code>this</code>。</p></li><li><p>缓存了组件：</p><p>缓存了组件之后，再次进入组件不会触发<code>beforeCreate</code>、<code>created</code> 、<code>beforeMount</code>、 <code>mounted</code>，<strong>如果你想每次进入组件都做一些事情的话，你可以放在<code>activated</code>进入缓存组件的钩子中</strong>。</p><p>同理：离开缓存组件的时候，<code>beforeDestroy</code>和<code>destroyed</code>并不会触发，可以使用<code>deactivated</code>离开缓存组件的钩子来代替。</p></li></ul><hr><h2 id="触发钩子的完整顺序："><a href="#触发钩子的完整顺序：" class="headerlink" title="触发钩子的完整顺序："></a>触发钩子的完整顺序：</h2><p>将路由导航、<code>keep-alive</code>、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件：</p><ol><li><code>beforeRouteLeave</code>:路由组件的组件离开路由前钩子，可取消路由离开。</li><li><code>beforeEach</code>: 路由全局前置守卫，可用于登录验证、全局路由loading等。</li><li><code>beforeEnter</code>: 路由独享守卫</li><li><code>beforeRouteEnter</code>: 路由组件的组件进入路由前钩子。</li><li><code>beforeResolve</code>:<a href="https://link.juejin.cn?target=https%3A%2F%2Frouter.vuejs.org%2Fzh%2Fguide%2Fadvanced%2Fnavigation-guards.html%23%25E5%2585%25A8%25E5%25B1%2580%25E8%25A7%25A3%25E6%259E%2590%25E5%25AE%2588%25E5%258D%25AB" title="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E8%A7%A3%E6%9E%90%E5%AE%88%E5%8D%AB" target="_blank" rel="noopener">路由全局解析守卫</a></li><li><code>afterEach</code>:路由全局后置钩子</li><li><code>beforeCreate</code>:组件生命周期，不能访问<code>this</code>。</li><li><code>created</code>:组件生命周期，可以访问<code>this</code>，不能访问dom。</li><li><code>beforeMount</code>:组件生命周期</li><li><code>deactivated</code>: 离开缓存组件a，或者触发a的<code>beforeDestroy</code>和<code>destroyed</code>组件销毁钩子。</li><li><code>mounted</code>:访问/操作dom。</li><li><code>activated</code>:进入缓存组件，进入a的嵌套子组件(如果有的话)。</li><li>执行beforeRouteEnter回调函数next。</li></ol><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Vue提供了很多钩子，但很多钩子我们几乎不会用到，只有清楚这些钩子函数的触发顺序以及背后的一些限制等，这样我们才能够正确的使用这些钩子，希望看了本文的同学，能对这些钩子有更加清晰的认识，使用起来更加得心应手。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;–&lt;/p&gt;
&lt;p&gt;说到Vue的钩子函数，可能很多人只停留在一些很简单常用的钩子(&lt;code&gt;created&lt;/code&gt;,&lt;code&gt;mounted&lt;/code&gt;)，而且对于里面的区别，什么时候该用什么钩子，并没有仔细的去研究过，且Vue的生命周期在面试中也算是比较高频的考
      
    
    </summary>
    
      <category term="Vue" scheme="https://weifo.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://weifo.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>设计模式简介</title>
    <link href="https://weifo.github.io/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/"/>
    <id>https://weifo.github.io/2022/05/03/设计模式简介/</id>
    <published>2022-05-03T06:56:03.000Z</published>
    <updated>2022-06-07T21:48:49.784Z</updated>
    
    <content type="html"><![CDATA[<hr><p>设计模式代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。</p><h3 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h3><ul><li><strong>S – Single Responsibility Principle 单一职责原则</strong><ul><li>一个程序只做好一件事</li><li>如果功能过于复杂就拆分开，每个部分保持独立</li></ul></li><li><strong>O – OpenClosed Principle 开放/封闭原则</strong><ul><li>对扩展开放，对修改封闭</li><li>增加需求时，扩展新代码，而非修改已有代码</li></ul></li><li>L – Liskov Substitution Principle 里氏替换原则<ul><li>子类能覆盖父类</li><li>父类能出现的地方子类就能出现</li></ul></li><li>I – Interface Segregation Principle 接口隔离原则<ul><li>保持接口的单一独立</li><li>类似单一职责原则，这里更关注接口</li></ul></li><li>D – Dependency Inversion Principle 依赖倒转原则<ul><li>面向接口编程，依赖于抽象而不依赖于具体</li><li>使用方只关注接口而不关注具体类的实现</li></ul></li></ul><h5 id="SO体现较多，举个栗子：（比如Promise）"><a href="#SO体现较多，举个栗子：（比如Promise）" class="headerlink" title="SO体现较多，举个栗子：（比如Promise）"></a>SO体现较多，举个栗子：（比如Promise）</h5><ul><li>单一职责原则：每个then中的逻辑只做好一件事</li><li>开放封闭原则（对扩展开放，对修改封闭）：如果新增需求，扩展then</li></ul><h5 id="再举个栗子：-此例来源-守候-改善代码的各方面问题"><a href="#再举个栗子：-此例来源-守候-改善代码的各方面问题" class="headerlink" title="再举个栗子：(此例来源-守候-改善代码的各方面问题)"></a>再举个栗子：(此例来源-<a href="https://juejin.im/post/6844903597092651015#comment" title="https://juejin.im/post/6844903597092651015#comment" target="_blank" rel="noopener">守候-改善代码的各方面问题</a>)</h5><pre><code>//checkType(&apos;165226226326&apos;,&apos;mobile&apos;)//result：falselet checkType=function(str, type) {    switch (type) {        case &apos;email&apos;:            return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str)        case &apos;mobile&apos;:            return /^1[3|4|5|7|8][0-9]{9}$/.test(str);        case &apos;tel&apos;:            return /^(0\d{2,3}-\d{7,8})(-\d{1,4})?$/.test(str);        default:            return true;    }}复制代码</code></pre><p>有以下两个问题：</p><ul><li>如果想添加其他规则就得在函数里面增加 case 。添加一个规则就修改一次！这样违反了开放-封闭原则（对扩展开放，对修改关闭）。而且这样也会导致整个 API 变得臃肿，难维护。</li><li>比如A页面需要添加一个金额的校验，B页面需要一个日期的校验，但是金额的校验只在A页面需要，日期的校验只在B页面需要。如果一直添加 case 。就是导致A页面把只在B页面需要的校验规则也添加进去，造成不必要的开销。B页面也同理。</li></ul><p>建议的方式是给这个 API 增加一个扩展的接口:</p><pre><code>let checkType=(function(){    let rules={        email(str){            return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str);        },        mobile(str){            return /^1[3|4|5|7|8][0-9]{9}$/.test(str);        }    };    //暴露接口    return {        //校验        check(str, type){            return rules[type]?rules[type](str):false;        },        //添加规则        addRule(type,fn){            rules[type]=fn;        }    }})();//调用方式//使用mobile校验规则console.log(checkType.check(&apos;188170239&apos;,&apos;mobile&apos;));//添加金额校验规则checkType.addRule(&apos;money&apos;,function (str) {    return /^[0-9]+(.[0-9]{2})?$/.test(str)});//使用金额校验规则console.log(checkType.check(&apos;18.36&apos;,&apos;money&apos;));复制代码</code></pre><p>此例更详细内容请查看-&gt; <a href="https://juejin.im/post/6844903597092651015#comment" title="https://juejin.im/post/6844903597092651015#comment" target="_blank" rel="noopener">守候i-重构-改善代码的各方面问题</a></p><h2 id="设计模式分类（23种设计模式）"><a href="#设计模式分类（23种设计模式）" class="headerlink" title="设计模式分类（23种设计模式）"></a>设计模式分类（23种设计模式）</h2><ul><li>创建型<ul><li>单例模式</li><li>原型模式</li><li>工厂模式</li><li>抽象工厂模式</li><li>建造者模式</li></ul></li><li>结构型<ul><li>适配器模式</li><li>装饰器模式</li><li>代理模式</li><li>外观模式</li><li>桥接模式</li><li>组合模式</li><li>享元模式</li></ul></li><li>行为型<ul><li>观察者模式</li><li>迭代器模式</li><li>策略模式</li><li>模板方法模式</li><li>职责链模式</li><li>命令模式</li><li>备忘录模式</li><li>状态模式</li><li>访问者模式</li><li>中介者模式</li><li>解释器模式</li></ul></li></ul><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。</p><pre><code>class Product {    constructor(name) {        this.name = name    }    init() {        console.log(&apos;init&apos;)    }    fun() {        console.log(&apos;fun&apos;)    }}class Factory {    create(name) {        return new Product(name)    }}// uselet factory = new Factory()let p = factory.create(&apos;p1&apos;)p.init()p.fun()复制代码</code></pre><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li>如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择</li><li>将new操作简单封装，遇到new的时候就应该考虑是否用工厂模式；</li><li>需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性</li></ul><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>创建对象的过程可能很复杂，但我们只需要关心创建结果。</li><li>构造函数和创建者分离, 符合“开闭原则”</li><li>一个调用者想创建一个对象，只要知道其名称就可以了。</li><li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>添加新产品时，需要编写新的具体产品类,一定程度上增加了系统的复杂度</li><li>考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度</li></ul><h5 id="什么时候不用"><a href="#什么时候不用" class="headerlink" title="什么时候不用"></a>什么时候不用</h5><p>当被应用到错误的问题类型上时,这一模式会给应用程序引入大量不必要的复杂性.除非为创建对象提供一个接口是我们编写的库或者框架的一个设计上目标,否则我会建议使用明确的构造器,以避免不必要的开销。</p><p>由于对象的创建过程被高效的抽象在一个接口后面的事实,这也会给依赖于这个过程可能会有多复杂的单元测试带来问题。</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><ul><li><p>曾经我们熟悉的JQuery的$()就是一个工厂函数，它根据传入参数的不同创建元素或者去寻找上下文中的元素，创建成相应的jQuery对象</p><p>class jQuery {</p><pre><code>constructor(selector) {    super(selector)}add() {}</code></pre><p>  // 此处省略若干API<br>}</p><p>window.$ = function(selector) {</p><pre><code>return new jQuery(selector)</code></pre><p>}</p></li></ul><pre><code>复制代码</code></pre><ul><li>vue 的异步组件</li></ul><p>在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。例如：</p><pre><code>Vue.component(&apos;async-example&apos;, function (resolve, reject) {  setTimeout(function () {    // 向 `resolve` 回调传递组件定义    resolve({      template: &apos;&lt;div&gt;I am async!&lt;/div&gt;&apos;    })  }, 1000)})复制代码</code></pre><hr><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>一个类只有一个实例，并提供一个访问它的全局访问点。</p><pre><code> class LoginForm {    constructor() {        this.state = &apos;hide&apos;    }    show() {        if (this.state === &apos;show&apos;) {            alert(&apos;已经显示&apos;)            return        }        this.state = &apos;show&apos;        console.log(&apos;登录框显示成功&apos;)    }    hide() {        if (this.state === &apos;hide&apos;) {            alert(&apos;已经隐藏&apos;)            return        }        this.state = &apos;hide&apos;        console.log(&apos;登录框隐藏成功&apos;)    } } LoginForm.getInstance = (function () {     let instance     return function () {        if (!instance) {            instance = new LoginForm()        }        return instance     } })()let obj1 = LoginForm.getInstance()obj1.show()let obj2 = LoginForm.getInstance()obj2.hide()console.log(obj1 === obj2)复制代码</code></pre><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>划分命名空间，减少全局变量</li><li>增强模块性，把自己的代码组织在一个全局变量名下，放在单一位置，便于维护</li><li>且只会实例化一次。简化了代码的调试和维护</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>由于单例模式提供的是一种单点访问，所以它有可能导致模块间的强耦合 从而不利于单元测试。无法单独测试一个调用了来自单例的方法的类，而只能把它与那个单例作为一个单元一起测试。</li></ul><h4 id="场景例子"><a href="#场景例子" class="headerlink" title="场景例子"></a>场景例子</h4><ul><li>定义命名空间和实现分支型方法</li><li>登录框</li><li>vuex 和 redux中的store</li></ul><hr><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>将一个类的接口转化为另外一个接口，以满足用户需求，使类之间接口不兼容问题通过适配器得以解决。</p><pre><code>class Plug {  getName() {    return &apos;iphone充电头&apos;;  }}class Target {  constructor() {    this.plug = new Plug();  }  getName() {    return this.plug.getName() + &apos; 适配器Type-c充电头&apos;;  }}let target = new Target();target.getName(); // iphone充电头 适配器转Type-c充电头复制代码</code></pre><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>可以让任何两个没有关联的类一起运行。</li><li>提高了类的复用。</li><li>适配对象，适配库，适配数据</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>额外对象的创建，非直接调用，存在一定的开销（且不像代理模式在某些功能点上可实现性能优化)</li><li>如果没必要使用适配器模式的话，可以考虑重构，如果使用的话，尽量把文档完善</li></ul><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><ul><li>整合第三方SDK</li><li><p>封装旧接口</p><p>// 自己封装的ajax， 使用方式如下<br>ajax({</p><pre><code>url: &apos;/getData&apos;,type: &apos;Post&apos;,dataType: &apos;json&apos;,data: {    test: 111}</code></pre><p>}).done(function() {})<br>// 因为历史原因，代码中全都是：<br>// $.ajax({….})</p><p>// 做一层适配器<br>var $ = {</p><pre><code>ajax: function (options) {    return ajax(options)}</code></pre><p>}<br>复制代码</p></li><li><p>vue的computed</p><p><template></template></p><pre><code>&lt;div id=&quot;example&quot;&gt;    &lt;p&gt;Original message: &quot;{{ message }}&quot;&lt;/p&gt;  &lt;!-- Hello --&gt;    &lt;p&gt;Computed reversed message: &quot;{{ reversedMessage }}&quot;&lt;/p&gt;  &lt;!-- olleH --&gt;&lt;/div&gt;</code></pre><p></p><script type="text/javascript">    export default {        name: 'demo',        data() {            return {                message: 'Hello'            }        },        computed: {            reversedMessage: function() {                return this.message.split('').reverse().join('')            }        }    }</script><p>复制代码</p></li></ul><h5 id="原有data-中的数据不满足当前的要求，通过计算属性的规则来适配成我们需要的格式，对原有数据并没有改变，只改变了原有数据的表现形式"><a href="#原有data-中的数据不满足当前的要求，通过计算属性的规则来适配成我们需要的格式，对原有数据并没有改变，只改变了原有数据的表现形式" class="headerlink" title="原有data 中的数据不满足当前的要求，通过计算属性的规则来适配成我们需要的格式，对原有数据并没有改变，只改变了原有数据的表现形式"></a>原有data 中的数据不满足当前的要求，通过计算属性的规则来适配成我们需要的格式，对原有数据并没有改变，只改变了原有数据的表现形式</h5><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p>适配器与代理模式相似</p><ul><li>适配器模式： 提供一个不同的接口（如不同版本的插头）</li><li>代理模式： 提供一模一样的接口</li></ul><hr><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><ul><li>动态地给某个对象添加一些额外的职责，，是一种实现继承的替代方案</li><li><p>在不改变原对象的基础上，通过对其进行包装扩展，使原有对象可以满足用户的更复杂需求，而不会影响从这个类中派生的其他对象</p><p>class Cellphone {</p><pre><code>create() {    console.log(&apos;生成一个手机&apos;)}</code></pre><p>}<br>class Decorator {</p><pre><code>constructor(cellphone) {    this.cellphone = cellphone}create() {    this.cellphone.create()    this.createShell(cellphone)}createShell() {    console.log(&apos;生成手机壳&apos;)}</code></pre><p>}<br>// 测试代码<br>let cellphone = new Cellphone()<br>cellphone.create()</p><p>console.log(‘————‘)<br>let dec = new Decorator(cellphone)<br>dec.create()<br>复制代码</p></li></ul><h4 id="场景例子-1"><a href="#场景例子-1" class="headerlink" title="场景例子"></a>场景例子</h4><ul><li>比如现在有4 种型号的自行车，我们为每种自行车都定义了一个单</li></ul><p>独的类。现在要给每种自行车都装上前灯、尾 灯和铃铛这3 种配件。如果使用继承的方式来给 每种自行车创建子类，则需要 4×3 = 12 个子类。 但是如果把前灯、尾灯、铃铛这些对象动态组 合到自行车上面，则只需要额外增加3 个类</p><ul><li>ES7 Decorator <a href="https://link.juejin.cn?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fdecorator" title="http://es6.ruanyifeng.com/#docs/decorator" target="_blank" rel="noopener">阮一峰</a></li><li>core-decorators</li></ul><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul><li>装饰类和被装饰类都只关心自身的核心业务，实现了解耦。</li><li>方便动态的扩展功能，且提供了比继承更多的灵活性。</li></ul><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ul><li>多层装饰比较复杂。</li><li>常常会引入许多小对象，看起来比较相似，实际功能大相径庭，从而使得我们的应用程序架构变得复杂起来</li></ul><hr><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>是为一个对象提供一个代用品或占位符，以便控制对它的访问</p><blockquote><p>假设当A 在心情好的时候收到花，小明表白成功的几率有</p></blockquote><p>60%，而当A 在心情差的时候收到花，小明表白的成功率无限趋近于0。 小明跟A 刚刚认识两天，还无法辨别A 什么时候心情好。如果不合时宜地把花送给A，花 被直接扔掉的可能性很大，这束花可是小明吃了7 天泡面换来的。 但是A 的朋友B 却很了解A，所以小明只管把花交给B，B 会监听A 的心情变化，然后选 择A 心情好的时候把花转交给A，代码如下：</p><pre><code>let Flower = function() {}let xiaoming = {  sendFlower: function(target) {    let flower = new Flower()    target.receiveFlower(flower)  }}let B = {  receiveFlower: function(flower) {    A.listenGoodMood(function() {      A.receiveFlower(flower)    })  }}let A = {  receiveFlower: function(flower) {    console.log(&apos;收到花&apos;+ flower)  },  listenGoodMood: function(fn) {    setTimeout(function() {      fn()    }, 1000)  }}xiaoming.sendFlower(B)复制代码</code></pre><h4 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h4><ul><li><p>HTML元 素事件代理</p><p><ul id="ul"><br>  <li>1</li><br>  <li>2</li><br>  <li>3</li><br></ul><br><script><br>  let ul = document.querySelector(‘#ul’);<br>  ul.addEventListener(‘click’, event =&gt; {</p><pre><code>console.log(event.target);</code></pre><p>  });<br></script><br>复制代码</p></li><li><p>ES6 的 proxy <a href="https://link.juejin.cn?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fproxy" title="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">阮一峰Proxy</a></p></li><li>jQuery.proxy()方法</li></ul><h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><ul><li>代理模式能将代理对象与被调用对象分离，降低了系统的耦合度。代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用</li><li>代理对象可以扩展目标对象的功能；通过修改代理对象就可以了，符合开闭原则；</li></ul><h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><p>处理请求速度可能有差别，非直接访问存在开销</p><h4 id="不同点-1"><a href="#不同点-1" class="headerlink" title="不同点"></a>不同点</h4><p>装饰者模式实现上和代理模式类似</p><ul><li>装饰者模式： 扩展功能，原有功能不变且可直接使用</li><li>代理模式： 显示原有功能，但是经过限制之后的</li></ul><hr><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>为子系统的一组接口提供一个一致的界面，定义了一个高层接口，这个接口使子系统更加容易使用</p><ol><li><p>兼容浏览器事件绑定</p><p>let addMyEvent = function (el, ev, fn) {</p><pre><code>if (el.addEventListener) {    el.addEventListener(ev, fn, false)} else if (el.attachEvent) {    el.attachEvent(&apos;on&apos; + ev, fn)} else {    el[&apos;on&apos; + ev] = fn}</code></pre><p>};<br>复制代码</p></li><li><p>封装接口</p><p>let myEvent = {</p><pre><code>// ...stop: e =&gt; {    e.stopPropagation();    e.preventDefault();}</code></pre><p>};<br>复制代码</p></li></ol><h4 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h4><ul><li>设计初期，应该要有意识地将不同的两个层分离，比如经典的三层结构，在数据访问层和业务逻辑层、业务逻辑层和表示层之间建立外观Facade</li><li>在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观Facade可以提供一个简单的接口，减少他们之间的依赖。</li><li>在维护一个遗留的大型系统时，可能这个系统已经很难维护了，这时候使用外观Facade也是非常合适的，为系系统开发一个外观Facade类，为设计粗糙和高度复杂的遗留代码提供比较清晰的接口，让新系统和Facade对象交互，Facade与遗留代码交互所有的复杂工作。</li></ul><p>参考： 大话设计模式</p><h4 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h4><ul><li>减少系统相互依赖。</li><li>提高灵活性。</li><li>提高了安全性</li></ul><h4 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h4><ul><li>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</li></ul><hr><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使它们能够自动更新自己，当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。</p><ul><li>发布 &amp; 订阅</li><li><p>一对多</p><p>// 主题 保存状态，状态变化之后触发所有观察者对象<br>class Subject {<br>  constructor() {</p><pre><code>this.state = 0this.observers = []</code></pre><p>  }<br>  getState() {</p><pre><code>return this.state</code></pre><p>  }<br>  setState(state) {</p><pre><code>this.state = statethis.notifyAllObservers()</code></pre><p>  }<br>  notifyAllObservers() {</p><pre><code>this.observers.forEach(observer =&gt; {  observer.update()})</code></pre><p>  }<br>  attach(observer) {</p><pre><code>this.observers.push(observer)</code></pre><p>  }<br>}</p><p>// 观察者<br>class Observer {<br>  constructor(name, subject) {</p><pre><code>this.name = namethis.subject = subjectthis.subject.attach(this)</code></pre><p>  }<br>  update() {</p><pre><code>console.log(`${this.name} update, state: ${this.subject.getState()}`)</code></pre><p>  }<br>}</p><p>// 测试<br>let s = new Subject()<br>let o1 = new Observer(‘o1’, s)<br>let o2 = new Observer(‘02’, s)</p><p>s.setState(12)<br>复制代码</p></li></ul><h4 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h4><ul><li><p>DOM事件</p><p>document.body.addEventListener(‘click’, function() {</p><pre><code>console.log(&apos;hello world!&apos;);</code></pre><p>});<br>document.body.click()<br>复制代码</p></li><li><p>vue 响应式</p></li></ul><h4 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h4><ul><li>支持简单的广播通信，自动通知所有已经订阅过的对象</li><li>目标对象与观察者之间的抽象耦合关系能单独扩展以及重用</li><li>增加了灵活性</li><li>观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。</li></ul><h4 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h4><p>过度使用会导致对象与对象之间的联系弱化，会导致程序难以跟踪维护和理解</p><hr><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>允许一个对象在其内部状态改变的时候改变它的行为，对象看起来似乎修改了它的类</p><pre><code>// 状态 （弱光、强光、关灯）class State {    constructor(state) {        this.state = state    }    handle(context) {        console.log(`this is ${this.state} light`)        context.setState(this)    }}class Context {    constructor() {        this.state = null    }    getState() {        return this.state    }    setState(state) {        this.state = state    }}// test let context = new Context()let weak = new State(&apos;weak&apos;)let strong = new State(&apos;strong&apos;)let off = new State(&apos;off&apos;)// 弱光weak.handle(context)console.log(context.getState())// 强光strong.handle(context)console.log(context.getState())// 关闭off.handle(context)console.log(context.getState())复制代码</code></pre><h4 id="场景-4"><a href="#场景-4" class="headerlink" title="场景"></a>场景</h4><ul><li>一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为</li><li>一个操作中含有大量的分支语句，而且这些分支语句依赖于该对象的状态</li></ul><h4 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h4><ul><li>定义了状态与行为之间的关系，封装在一个类里，更直观清晰，增改方便</li><li>状态与状态间，行为与行为间彼此独立互不干扰</li><li>用对象代替字符串来记录当前状态，使得状态的切换更加一目了然</li></ul><h4 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h4><ul><li>会在系统中定义许多状态类</li><li>逻辑分散</li></ul><hr><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p><pre><code>class Iterator {    constructor(conatiner) {        this.list = conatiner.list        this.index = 0    }    next() {        if (this.hasNext()) {            return this.list[this.index++]        }        return null    }    hasNext() {        if (this.index &gt;= this.list.length) {            return false        }        return true    }}class Container {    constructor(list) {        this.list = list    }    getIterator() {        return new Iterator(this)    }}// 测试代码let container = new Container([1, 2, 3, 4, 5])let iterator = container.getIterator()while(iterator.hasNext()) {  console.log(iterator.next())}复制代码</code></pre><h4 id="场景例子-2"><a href="#场景例子-2" class="headerlink" title="场景例子"></a>场景例子</h4><ul><li>Array.prototype.forEach</li><li>jQuery中的$.each()</li><li>ES6 Iterator</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>访问一个聚合对象的内容而无需暴露它的内部表示。</li><li>为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对于集合内部结果常常变化各异，不想暴露其内部结构的话，但又想让客户代码透明的访问其中的元素，可以使用迭代器模式</p><hr><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p><pre><code>class Color {    constructor(name){        this.name = name    }}class Shape {    constructor(name,color){        this.name = name        this.color = color     }    draw(){        console.log(`${this.color.name} ${this.name}`)    }}//测试let red = new Color(&apos;red&apos;)let yellow = new Color(&apos;yellow&apos;)let circle = new Shape(&apos;circle&apos;, red)circle.draw()let triangle = new Shape(&apos;triangle&apos;, yellow)triangle.draw()复制代码</code></pre><h4 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h4><ul><li>有助于独立地管理各组成部分， 把抽象化与实现化解耦</li><li>提高可扩充性</li></ul><h4 id="缺点-8"><a href="#缺点-8" class="headerlink" title="缺点"></a>缺点</h4><ul><li>大量的类将导致开发成本的增加，同时在性能方面可能也会有所减少。</li></ul><hr><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><ul><li>将对象组合成树形结构，以表示“整体-部分”的层次结构。</li><li><p>通过对象的多态表现，使得用户对单个对象和组合对象的使用具有一致性。</p><p>class TrainOrder {</p><pre><code>create () {    console.log(&apos;创建火车票订单&apos;)}</code></pre><p>}<br>class HotelOrder {</p><pre><code>create () {    console.log(&apos;创建酒店订单&apos;)}</code></pre><p>}</p><p>class TotalOrder {</p><pre><code>constructor () {    this.orderList = []}addOrder (order) {    this.orderList.push(order)    return this}create () {    this.orderList.forEach(item =&gt; {        item.create()    })    return this}</code></pre><p>}<br>// 可以在购票网站买车票同时也订房间<br>let train = new TrainOrder()<br>let hotel = new HotelOrder()<br>let total = new TotalOrder()<br>total.addOrder(train).addOrder(hotel).create()<br>复制代码</p></li></ul><h4 id="场景-5"><a href="#场景-5" class="headerlink" title="场景"></a>场景</h4><ul><li>表示对象-整体层次结构</li><li>希望用户忽略组合对象和单个对象的不同，用户将统一地使用组合结构中的所有对象（方法）</li></ul><h4 id="缺点-9"><a href="#缺点-9" class="headerlink" title="缺点"></a>缺点</h4><p>如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起。</p><hr><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>原型模式（prototype）是指用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><pre><code>class Person {  constructor(name) {    this.name = name  }  getName() {    return this.name  }}class Student extends Person {  constructor(name) {    super(name)  }  sayHello() {    console.log(`Hello， My name is ${this.name}`)  }}let student = new Student(&quot;xiaoming&quot;)student.sayHello()复制代码</code></pre><p>原型模式，就是创建一个共享的原型，通过拷贝这个原型来创建新的类，用于创建重复的对象，带来性能上的提升。</p><hr><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换</p><pre><code>&lt;html&gt;&lt;head&gt;    &lt;title&gt;策略模式-校验表单&lt;/title&gt;    &lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;form id = &quot;registerForm&quot; method=&quot;post&quot; action=&quot;http://xxxx.com/api/register&quot;&gt;        用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt;        密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;        手机号码：&lt;input type=&quot;text&quot; name=&quot;phoneNumber&quot;&gt;        &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;    &lt;/form&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        // 策略对象        const strategies = {          isNoEmpty: function (value, errorMsg) {            if (value === &apos;&apos;) {              return errorMsg;            }          },          isNoSpace: function (value, errorMsg) {            if (value.trim() === &apos;&apos;) {              return errorMsg;            }          },          minLength: function (value, length, errorMsg) {            if (value.trim().length &lt; length) {              return errorMsg;            }          },          maxLength: function (value, length, errorMsg) {            if (value.length &gt; length) {              return errorMsg;            }          },          isMobile: function (value, errorMsg) {            if (!/^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|17[7]|18[0|1|2|3|5|6|7|8|9])\d{8}$/.test(value)) {              return errorMsg;            }                          }        }        // 验证类        class Validator {          constructor() {            this.cache = []          }          add(dom, rules) {            for(let i = 0, rule; rule = rules[i++];) {              let strategyAry = rule.strategy.split(&apos;:&apos;)              let errorMsg = rule.errorMsg              this.cache.push(() =&gt; {                let strategy = strategyAry.shift()                strategyAry.unshift(dom.value)                strategyAry.push(errorMsg)                return strategies[strategy].apply(dom, strategyAry)              })            }          }          start() {            for(let i = 0, validatorFunc; validatorFunc = this.cache[i++];) {              let errorMsg = validatorFunc()              if (errorMsg) {                return errorMsg              }            }          }        }        // 调用代码        let registerForm = document.getElementById(&apos;registerForm&apos;)        let validataFunc = function() {          let validator = new Validator()          validator.add(registerForm.userName, [{            strategy: &apos;isNoEmpty&apos;,            errorMsg: &apos;用户名不可为空&apos;          }, {            strategy: &apos;isNoSpace&apos;,            errorMsg: &apos;不允许以空白字符命名&apos;          }, {            strategy: &apos;minLength:2&apos;,            errorMsg: &apos;用户名长度不能小于2位&apos;          }])          validator.add(registerForm.password, [ {            strategy: &apos;minLength:6&apos;,            errorMsg: &apos;密码长度不能小于6位&apos;          }])          validator.add(registerForm.phoneNumber, [{            strategy: &apos;isMobile&apos;,            errorMsg: &apos;请输入正确的手机号码格式&apos;          }])          return validator.start()        }        registerForm.onsubmit = function() {          let errorMsg = validataFunc()          if (errorMsg) {            alert(errorMsg)            return false          }        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;复制代码</code></pre><h4 id="场景例子-3"><a href="#场景例子-3" class="headerlink" title="场景例子"></a>场景例子</h4><ul><li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的’行为’，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li><li>一个系统需要动态地在几种算法中选择一种。</li><li>表单验证</li></ul><h4 id="优点-9"><a href="#优点-9" class="headerlink" title="优点"></a>优点</h4><ul><li>利用组合、委托、多态等技术和思想，可以有效的避免多重条件选择语句</li><li>提供了对开放-封闭原则的完美支持，将算法封装在独立的strategy中，使得它们易于切换，理解，易于扩展</li><li>利用组合和委托来让Context拥有执行算法的能力，这也是继承的一种更轻便的代替方案</li></ul><h4 id="缺点-10"><a href="#缺点-10" class="headerlink" title="缺点"></a>缺点</h4><ul><li>会在程序中增加许多策略类或者策略对象</li><li>要使用策略模式，必须了解所有的strategy，必须了解各个strategy之间的不同点，这样才能选择一个合适的strategy</li></ul><hr><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式</p><pre><code>let examCarNum = 0         // 驾考车总数/* 驾考车对象 */class ExamCar {    constructor(carType) {        examCarNum++        this.carId = examCarNum        this.carType = carType ? &apos;手动档&apos; : &apos;自动档&apos;        this.usingState = false    // 是否正在使用    }    /* 在本车上考试 */    examine(candidateId) {        return new Promise((resolve =&gt; {            this.usingState = true            console.log(`考生- ${ candidateId } 开始在${ this.carType }驾考车- ${ this.carId } 上考试`)            setTimeout(() =&gt; {                this.usingState = false                console.log(`%c考生- ${ candidateId } 在${ this.carType }驾考车- ${ this.carId } 上考试完毕`, &apos;color:#f40&apos;)                resolve()                       // 0~2秒后考试完毕            }, Math.random() * 2000)        }))    }}/* 手动档汽车对象池 */ManualExamCarPool = {    _pool: [],                  // 驾考车对象池    _candidateQueue: [],        // 考生队列    /* 注册考生 ID 列表 */    registCandidates(candidateList) {        candidateList.forEach(candidateId =&gt; this.registCandidate(candidateId))    },    /* 注册手动档考生 */    registCandidate(candidateId) {        const examCar = this.getManualExamCar()    // 找一个未被占用的手动档驾考车        if (examCar) {            examCar.examine(candidateId)           // 开始考试，考完了让队列中的下一个考生开始考试              .then(() =&gt; {                  const nextCandidateId = this._candidateQueue.length &amp;&amp; this._candidateQueue.shift()                  nextCandidateId &amp;&amp; this.registCandidate(nextCandidateId)              })        } else this._candidateQueue.push(candidateId)    },    /* 注册手动档车 */    initManualExamCar(manualExamCarNum) {        for (let i = 1; i &lt;= manualExamCarNum; i++) {            this._pool.push(new ExamCar(true))        }    },    /* 获取状态为未被占用的手动档车 */    getManualExamCar() {        return this._pool.find(car =&gt; !car.usingState)    }}ManualExamCarPool.initManualExamCar(3)          // 一共有3个驾考车ManualExamCarPool.registCandidates([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])  // 10个考生来考试复制代码</code></pre><h4 id="场景例子-4"><a href="#场景例子-4" class="headerlink" title="场景例子"></a>场景例子</h4><ul><li>文件上传需要创建多个文件实例的时候</li><li>如果一个应用程序使用了大量的对象，而这些大量的对象造成了很大的存储开销时就应该考虑使用享元模式</li></ul><h4 id="优点-10"><a href="#优点-10" class="headerlink" title="优点"></a>优点</h4><ul><li>大大减少对象的创建，降低系统的内存，使效率提高。</li></ul><h4 id="缺点-11"><a href="#缺点-11" class="headerlink" title="缺点"></a>缺点</h4><ul><li>提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，</li></ul><h2 id="不应该随着内部状态的变化而变化，否则会造成系统的混乱"><a href="#不应该随着内部状态的变化而变化，否则会造成系统的混乱" class="headerlink" title="不应该随着内部状态的变化而变化，否则会造成系统的混乱"></a>不应该随着内部状态的变化而变化，否则会造成系统的混乱</h2><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法和封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。</p><pre><code>class Beverage {    constructor({brewDrink, addCondiment}) {        this.brewDrink = brewDrink        this.addCondiment = addCondiment    }    /* 烧开水，共用方法 */    boilWater() { console.log(&apos;水已经煮沸=== 共用&apos;) }    /* 倒杯子里，共用方法 */    pourCup() { console.log(&apos;倒进杯子里===共用&apos;) }    /* 模板方法 */    init() {        this.boilWater()        this.brewDrink()        this.pourCup()        this.addCondiment()    }}/* 咖啡 */const coffee = new Beverage({     /* 冲泡咖啡，覆盖抽象方法 */     brewDrink: function() { console.log(&apos;冲泡咖啡&apos;) },     /* 加调味品，覆盖抽象方法 */     addCondiment: function() { console.log(&apos;加点奶和糖&apos;) }})coffee.init() 复制代码</code></pre><h4 id="场景例子-5"><a href="#场景例子-5" class="headerlink" title="场景例子"></a>场景例子</h4><ul><li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现</li><li>子类中公共的行为应被提取出来并集中到一个公共父类中的避免代码重复</li></ul><h4 id="优点-11"><a href="#优点-11" class="headerlink" title="优点"></a>优点</h4><ul><li>提取了公共代码部分，易于维护</li></ul><h4 id="缺点-12"><a href="#缺点-12" class="headerlink" title="缺点"></a>缺点</h4><ul><li>增加了系统复杂度，主要是增加了的抽象类和类间联系</li></ul><hr><h3 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h3><p>使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止</p><pre><code>// 请假审批，需要组长审批、经理审批、总监审批class Action {    constructor(name) {        this.name = name        this.nextAction = null    }    setNextAction(action) {        this.nextAction = action    }    handle() {        console.log( `${this.name} 审批`)        if (this.nextAction != null) {            this.nextAction.handle()        }    }}let a1 = new Action(&quot;组长&quot;)let a2 = new Action(&quot;经理&quot;)let a3 = new Action(&quot;总监&quot;)a1.setNextAction(a2)a2.setNextAction(a3)a1.handle()复制代码</code></pre><h4 id="场景例子-6"><a href="#场景例子-6" class="headerlink" title="场景例子"></a>场景例子</h4><ul><li>JS 中的事件冒泡</li><li>作用域链</li><li>原型链</li></ul><h4 id="优点-12"><a href="#优点-12" class="headerlink" title="优点"></a>优点</h4><ul><li>降低耦合度。它将请求的发送者和接收者解耦。</li><li>简化了对象。使得对象不需要知道链的结构</li><li>增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任</li><li>增加新的请求处理类很方便。</li></ul><h4 id="缺点-13"><a href="#缺点-13" class="headerlink" title="缺点"></a>缺点</h4><ul><li>不能保证某个请求一定会被链中的节点处理，这种情况可以在链尾增加一个保底的接受者节点来处理这种即将离开链尾的请求。</li><li>使程序中多了很多节点对象，可能再一次请求的过程中，大部分的节点并没有起到实质性的作用。他们的作用仅仅是让请求传递下去，从性能当面考虑，要避免过长的职责链到来的性能损耗。</li></ul><hr><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。</p><pre><code>// 接收者类class Receiver {    execute() {      console.log(&apos;接收者执行请求&apos;)    }  }// 命令者class Command {      constructor(receiver) {        this.receiver = receiver    }    execute () {            console.log(&apos;命令&apos;);        this.receiver.execute()    }}// 触发者class Invoker {       constructor(command) {        this.command = command    }    invoke() {           console.log(&apos;开始&apos;)        this.command.execute()    }}// 仓库const warehouse = new Receiver();   // 订单    const order = new Command(warehouse);  // 客户const client = new Invoker(order);      client.invoke()复制代码</code></pre><h4 id="优点-13"><a href="#优点-13" class="headerlink" title="优点"></a>优点</h4><ul><li>对命令进行封装，使命令易于扩展和修改</li><li>命令发出者和接受者解耦，使发出者不需要知道命令的具体执行过程即可执行</li></ul><h4 id="缺点-14"><a href="#缺点-14" class="headerlink" title="缺点"></a>缺点</h4><ul><li>使用命令模式可能会导致某些系统有过多的具体命令类。</li></ul><hr><h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。</p><pre><code>//备忘类class Memento{    constructor(content){        this.content = content    }    getContent(){        return this.content    }}// 备忘列表class CareTaker {    constructor(){        this.list = []    }    add(memento){        this.list.push(memento)    }    get(index){        return this.list[index]    }}// 编辑器class Editor {    constructor(){        this.content = null    }    setContent(content){        this.content = content    }    getContent(){     return this.content    }    saveContentToMemento(){        return new Memento(this.content)    }    getContentFromMemento(memento){        this.content = memento.getContent()    }}//测试代码let editor = new Editor()let careTaker = new CareTaker()editor.setContent(&apos;111&apos;)editor.setContent(&apos;222&apos;)careTaker.add(editor.saveContentToMemento())editor.setContent(&apos;333&apos;)careTaker.add(editor.saveContentToMemento())editor.setContent(&apos;444&apos;)console.log(editor.getContent()) //444editor.getContentFromMemento(careTaker.get(1))console.log(editor.getContent()) //333editor.getContentFromMemento(careTaker.get(0))console.log(editor.getContent()) //222复制代码</code></pre><h4 id="场景例子-7"><a href="#场景例子-7" class="headerlink" title="场景例子"></a>场景例子</h4><ul><li>分页控件</li><li>撤销组件</li></ul><h4 id="优点-14"><a href="#优点-14" class="headerlink" title="优点"></a>优点</h4><ul><li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态</li></ul><h4 id="缺点-15"><a href="#缺点-15" class="headerlink" title="缺点"></a>缺点</h4><ul><li>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</li></ul><hr><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p>解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的 相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知 中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者 模式使网状的多对多关系变成了相对简单的一对多关系（类似于观察者模式，但是单向的，由中介者统一管理。）</p><pre><code>class A {    constructor() {        this.number = 0    }    setNumber(num, m) {        this.number = num        if (m) {            m.setB()        }    }}class B {    constructor() {        this.number = 0    }    setNumber(num, m) {        this.number = num        if (m) {            m.setA()        }    }}class Mediator {    constructor(a, b) {        this.a = a        this.b = b    }    setA() {        let number = this.b.number        this.a.setNumber(number * 10)    }    setB() {        let number = this.a.number        this.b.setNumber(number / 10)    }}let a = new A()let b = new B()let m = new Mediator(a, b)a.setNumber(10, m)console.log(a.number, b.number)b.setNumber(10, m)console.log(a.number, b.number)复制代码</code></pre><h4 id="场景例子-8"><a href="#场景例子-8" class="headerlink" title="场景例子"></a>场景例子</h4><ul><li>系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象</li><li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</li></ul><h4 id="优点-15"><a href="#优点-15" class="headerlink" title="优点"></a>优点</h4><ul><li>使各对象之间耦合松散，而且可以独立地改变它们之间的交互</li><li>中介者和对象一对多的关系取代了对象之间的网状多对多的关系</li><li>如果对象之间的复杂耦合度导致维护很困难，而且耦合度随项目变化增速很快，就需要中介者重构代码</li></ul><h4 id="缺点-16"><a href="#缺点-16" class="headerlink" title="缺点"></a>缺点</h4><ul><li>系统中会新增一个中介者对象，因 为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介 者对象自身往往就是一个难以维护的对象。</li></ul><hr><h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><p>给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。</p><p>此例来自<a href="https://link.juejin.cn?target=https%3A%2F%2Fxin-tan.com%2Fpassages%2F2019-01-25-interpreter-pattern%2F%23_3-%25E5%25A4%259A%25E8%25AF%25AD%25E8%25A8%2580%25E5%25AE%259E%25E7%258E%25B0" title="https://xin-tan.com/passages/2019-01-25-interpreter-pattern/#_3-%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener">心谭博客</a></p><pre><code>class Context {    constructor() {      this._list = []; // 存放 终结符表达式      this._sum = 0; // 存放 非终结符表达式(运算结果)    }    get sum() {      return this._sum;    }    set sum(newValue) {      this._sum = newValue;    }    add(expression) {      this._list.push(expression);    }    get list() {      return [...this._list];    }  }  class PlusExpression {    interpret(context) {      if (!(context instanceof Context)) {        throw new Error(&quot;TypeError&quot;);      }      context.sum = ++context.sum;    }  }  class MinusExpression {    interpret(context) {      if (!(context instanceof Context)) {        throw new Error(&quot;TypeError&quot;);      }      context.sum = --context.sum;    }  }  /** 以下是测试代码 **/  const context = new Context();  // 依次添加: 加法 | 加法 | 减法 表达式  context.add(new PlusExpression());  context.add(new PlusExpression());  context.add(new MinusExpression());  // 依次执行: 加法 | 加法 | 减法 表达式  context.list.forEach(expression =&gt; expression.interpret(context));  console.log(context.sum);复制代码</code></pre><h4 id="优点-16"><a href="#优点-16" class="headerlink" title="优点"></a>优点</h4><ul><li>易于改变和扩展文法。</li><li>由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法</li></ul><h4 id="缺点-17"><a href="#缺点-17" class="headerlink" title="缺点"></a>缺点</h4><ul><li>执行效率较低，在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度慢</li><li>对于复杂的文法比较难维护</li></ul><hr><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><pre><code>// 访问者  class Visitor {    constructor() {}    visitConcreteElement(ConcreteElement) {        ConcreteElement.operation()    }}// 元素类  class ConcreteElement{    constructor() {    }    operation() {       console.log(&quot;ConcreteElement.operation invoked&quot;);      }    accept(visitor) {        visitor.visitConcreteElement(this)    }}// clientlet visitor = new Visitor()let element = new ConcreteElement()element.accept(visitor)复制代码</code></pre><h4 id="场景例子-9"><a href="#场景例子-9" class="headerlink" title="场景例子"></a>场景例子</h4><ul><li>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作</li><li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。</li></ul><h4 id="优点-17"><a href="#优点-17" class="headerlink" title="优点"></a>优点</h4><ul><li>符合单一职责原则</li><li>优秀的扩展性</li><li>灵活性</li></ul><h4 id="缺点-18"><a href="#缺点-18" class="headerlink" title="缺点"></a>缺点</h4><ul><li>具体元素对访问者公布细节，违反了迪米特原则</li><li>违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</li><li>具体元素变更比较困难</li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;设计模式代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。&lt;/p&gt;
&lt;p&gt;设计模式是一套被反复使用的、多数人知晓的
      
    
    </summary>
    
      <category term="Interview" scheme="https://weifo.github.io/categories/Interview/"/>
    
    
      <category term="Interview" scheme="https://weifo.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks使用案例学习</title>
    <link href="https://weifo.github.io/2022/03/03/react%20hooks1/"/>
    <id>https://weifo.github.io/2022/03/03/react hooks1/</id>
    <published>2022-03-03T01:58:42.000Z</published>
    <updated>2022-03-06T12:10:25.444Z</updated>
    
    <content type="html"><![CDATA[<h3 id="清除-effect"><a href="#清除-effect" class="headerlink" title="清除 effect"></a><strong>清除 effect</strong></h3><p>通常，组件卸载时需要清除 effect 创建的诸如订阅或计时器 ID 等资源。要实现这一点，useEffect 函数需返回一个清除函数。也就是说，要想在组件销毁的时候搞一些事情，需要useEffect 末尾返回一个函数，在这个函数里面可以写具体销毁的内容。</p><p>看下面的例子，在当前页面里面，页面的标题是’测试title’，当切换到其他页面时，页面的标题变成‘正式title’。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDocumentTitle</span>(<span class="params">title</span>) </span>&#123;</span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = title;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'销毁1————————————————'</span>);</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">'正式title'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;, [title]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">CheckboxDemo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">useDocumentTitle(<span class="string">'测试title'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="监听页面大小变化，网络是否断开"><a href="#监听页面大小变化，网络是否断开" class="headerlink" title="监听页面大小变化，网络是否断开"></a><strong>监听页面大小变化，网络是否断开</strong></h3><p>效果：在组件调用 useWindowSize 时，可以拿到页面大小，并且在浏览器缩放时自动触发组件更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    innerHeight: <span class="built_in">window</span>.innerHeight,</span><br><span class="line">    innerWidth: <span class="built_in">window</span>.innerWidth,</span><br><span class="line">    outerHeight: <span class="built_in">window</span>.outerHeight,</span><br><span class="line">    outerWidth: <span class="built_in">window</span>.outerWidth,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useWindowSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> [windowSize, setWindowSize] = useState(getSize());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setWindowSize(getSize());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, handleResize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'resize'</span>, handleResize);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="keyword">return</span> windowSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> windowSize = useWindowSize();</span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>页面宽度&#123;windowSize.innerWidth&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态注入-css"><a href="#动态注入-css" class="headerlink" title="动态注入 css"></a><strong>动态注入 css</strong></h2><p>效果：在页面注入一段 class，并且当组件销毁时，移除这个 class。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> className = useCss(&#123;</span><br><span class="line">color: <span class="string">"red"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span>&gt;</span>Text.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>实现：可以看到，Hooks 方便的地方是在组件销毁时移除副作用，所以我们可以安心的利用 Hooks 做一些副作用。注入 css 自然不必说了，而销毁 css 只要找到注入的那段引用进行销毁即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;清除-effect&quot;&gt;&lt;a href=&quot;#清除-effect&quot; class=&quot;headerlink&quot; title=&quot;清除 effect&quot;&gt;&lt;/a&gt;&lt;strong&gt;清除 effect&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;通常，组件卸载时需要清除 effect 创建的诸如
      
    
    </summary>
    
      <category term="React" scheme="https://weifo.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://weifo.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>react-redux</title>
    <link href="https://weifo.github.io/2020/02/10/react-redux/"/>
    <id>https://weifo.github.io/2020/02/10/react-redux/</id>
    <published>2020-02-10T14:42:05.000Z</published>
    <updated>2020-03-15T13:18:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="rudux"><a href="#rudux" class="headerlink" title="rudux"></a>rudux</h2><p><code>redux</code> 运行流程图：<br><img src="https://user-gold-cdn.xitu.io/2018/9/12/165c9daf60abdbd6?w=638&amp;h=479&amp;f=jpeg&amp;s=21322" alt></p><p>简单概述：<strong>click</strong> -&gt; <strong>store.dispatch(action)</strong> -&gt; <strong>reduer</strong> -&gt; <strong>newState</strong> -&gt; <strong>viewUpdate</strong></p><p><strong>react-readux</strong> 中 通过 <strong>connect</strong> 链接组件和 <strong>redux</strong> , <strong>this.props.dispatch()</strong> 调用</p><p>后面将会讲到…</p><p><code>redux</code> 依赖包也是十分的简洁<br><img src="https://user-gold-cdn.xitu.io/2018/9/14/165d8c900fb1fcd4?w=280&amp;h=295&amp;f=png&amp;s=14746" alt><br>先来个<code>demo</code></p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> redux = <span class="built_in">require</span>(<span class="string">'redux'</span>)</span><br><span class="line"><span class="keyword">const</span> createStore = redux.createStore</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> types = &#123;</span><br><span class="line">  UPDATE_NAME: <span class="string">'UPDATE_NAME'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultStore = &#123;</span><br><span class="line">  user: <span class="string">'tom'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * reducer 纯函数 接收一个state,返回一个新的state</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">state</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>action [type] 必选参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="variable">newState</span></span></span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params">state = defaultStore, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, payload &#125; = action</span><br><span class="line">  <span class="keyword">let</span> res = <span class="built_in">Object</span>.assign(&#123;&#125;, defaultStore)</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> types.UPDATE_NAME:</span><br><span class="line">      res.user = payload.name</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(getUser)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * listener</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dispatch(action) action</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: types.UPDATE_NAME,</span><br><span class="line">  payload: &#123;</span><br><span class="line">    name: <span class="string">'大帅哥'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//@log &#123; name: '大帅哥' &#125;</span></span><br></pre></td></tr></table></figure><ol><li>用户发出 <code>action</code> 【<code>store.dispatch(action)</code>】</li><li><code>Store</code> 自动调用 <code>Reducer</code> , 返回新的 <code>state</code> 【<code>let nextState = getUser(previousState, action)</code>】</li><li><code>State</code> 一旦有变化，<code>Store</code> 就会调用监听函数 【<code>store.subscribe(listener)</code>】</li></ol><p>运行过程如下：<br><img src="https://user-gold-cdn.xitu.io/2018/9/15/165d8e7f3f6d9205?w=635&amp;h=931&amp;f=png&amp;s=95651" alt></p><h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p><code>Store</code> 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 <code>Store</code><br>常用方法：</p><ul><li>store.dispatch() ：分发 action 较为常用</li><li>store.subscribe() : state 发生变化后立即执行</li><li>store.getState() : 获取 store 中存着的 state</li></ul><h3 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h3><p><a href="https://github.com/reduxjs/redux/blob/master/src/createStore.js" target="_blank" rel="noopener">createStore</a> 如其名，创建 <code>store</code> 下面是该方法的部分源码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>reducer 函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any&#125;</span> </span>[preloadedState] The initial state</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>[enhancer] The store enhancer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Store&#125;</span></span></span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> preloadedState === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    enhancer = preloadedState</span><br><span class="line">    preloadedState = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    dispatch, <span class="comment">// 分发 action</span></span><br><span class="line">    subscribe, <span class="comment">// 监听器</span></span><br><span class="line">    getState, <span class="comment">// 获取 store 的 state 值</span></span><br><span class="line">    replaceReducer,</span><br><span class="line">    [$$observable]: observable <span class="comment">// 供Redux内部使用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>preloadedState</code>: 初始化的<code>initialState</code>，第二个参数不是<code>Object</code>,而是<code>Function</code>，<code>createStore</code>会认为你忽略了<code>preloadedState</code>而传入了一个<code>enhancer</code></li><li><code>createStore</code>会返回<code>enhancer(createStore)(reducer, preloadedState)</code>的调用结果，这是常见高阶函数的调用方式。在这个调用中<code>enhancer</code>接受<code>createStore</code>作为参数，对<code>createStore</code>的能力进行增强，并返回增强后的<code>createStore</code></li></ul><h3 id="dispatch-action"><a href="#dispatch-action" class="headerlink" title="dispatch(action)"></a>dispatch(action)</h3><p><code>diapatch</code> 是 store 对象的方法，主要用来分发 <code>action</code> ,</p><blockquote><p>redux 规定 action 一定要包含一个 type 属性，且 type 属性也要唯一</p></blockquote><p>dispatch 是 store 非常核心的一个方法，也是我们在应用中最常使用的方法，下面是 dispatch 的源码 ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(action)) &#123;</span><br><span class="line">    <span class="comment">// 校验了action是否为一个原生js对象</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Actions must be plain objects. '</span> + <span class="string">'Use custom middleware for async actions.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> action.type === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="comment">// action对象是否包含了必要的type字段</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Actions may not have an undefined "type" property. '</span> + <span class="string">'Have you misspelled a constant?'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">    <span class="comment">// 判断当前是否处于某个action分发过程中, 主要是为了避免在reducer中分发action</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Reducers may not dispatch actions.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    isDispatching = <span class="literal">true</span></span><br><span class="line">    currentState = currentReducer(currentState, action)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isDispatching = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> listeners = (currentListeners = nextListeners)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> listener = listeners[i]</span><br><span class="line">    listener()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在一系列检查完毕后，若均没有问题，将当前的状态和action传给当前reducer，用于生成新的state</span></span><br><span class="line">  <span class="keyword">return</span> action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reducer-amp-amp-store-replaceReducer"><a href="#reducer-amp-amp-store-replaceReducer" class="headerlink" title="reducer &amp;&amp; store.replaceReducer"></a>reducer &amp;&amp; store.replaceReducer</h3><p>Redux 中负责响应 action 并修改数据的角色就是<code>reducer</code>，<code>reducer</code>的本质实际上是一个函数<br>replaceReducer:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc </span>替换当前的reducer的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceReducer</span>(<span class="params">nextReducer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> nextReducer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the nextReducer to be a function.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  currentReducer = nextReducer</span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: ActionTypes.REPLACE &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>replaceReducer 使用场景：</p><ul><li>当你的程序要进行代码分割的时候</li><li>当你要动态的加载不同的 reducer 的时候</li><li>当你要实现一个实时 reloading 机制的时候</li></ul><h3 id="中间件-middleware"><a href="#中间件-middleware" class="headerlink" title="中间件 middleware"></a>中间件 middleware</h3><p>以上介绍了 redux 的实现流的过程，应用场景无非于</p><p>button – click –&gt; <code>disptch</code> – action –&gt; <code>reducer</code> – newState –&gt; <code>view</code></p><p>但是这种实现方式是基于同步的方式的，日常开发中当然少不了 http 这些异步请求，这种情况下必须等到服务器数据返回后才重新渲染 view, 显然某些时候回阻塞页面的展示。</p><p>举例来说，要添加日志功能，把 <code>Action</code> 和 <code>State</code> 打印出来，可以对 store.dispatch 进行如下改造。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> next = store.dispatch</span><br><span class="line">store.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatchAndLog</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'dispatching'</span>, action)</span><br><span class="line">  next(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，对 store.dispatch 进行了重定义，在发送 Action 前后添加了打印功能。这就是中间件的雏形。</p><p>中间件就是一个函数，对 store.dispatch 方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。</p><h3 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h3><p>Redux 提供了<code>applyMiddleware</code>来装载<code>middleware</code>：<br>它是 Redux 的原生方法，<strong>作用是将所有中间件组成一个数组，依次执行。</strong>下面是它的源码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;...Function&#125;</span> <span class="variable">middlewares</span></span></span></span><br><span class="line"><span class="comment"> * returns &#123;Function&#125; A store enhancer applying the middleware</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...middlewares</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> store = createStore(...args)</span><br><span class="line">    <span class="keyword">let</span> dispatch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">`Dispatching while constructing your middleware is not allowed. `</span> +</span><br><span class="line">          <span class="string">`Other middleware would not be applied to this dispatch.`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有中间件被放进了一个数组 chain，然后嵌套执行，最后执行 store.dispatch。可以看到，中间件内部（middlewareAPI）可以拿到<code>getState</code>和<code>dispatch</code>这两个方法</p><p><code>compose</code> 实际上是函数式编程中的组合，接收多个函数体并且将其组合成一个新的函数，例如<code>compose</code> 后 [fn1, fn2…] 依次从右到左嵌套执行函数 而<code>compose</code>用于<code>applyMiddleware</code> 也是为了组合中间件<br><strong>dispatch = compose(…chain)(store.dispatch)</strong><br>==&gt;<br><strong>dispatch=fn1(fn2(fn3(store.dispatch)))</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;...Function&#125;</span> </span>funcs The functions to compose.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Function&#125;</span> </span>A function obtained by composing the argument functions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> a(b(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a>redux-thunk</h3><p>上面的中间件的介绍可以知道<br>redux 通过 <code>applyMiddleware</code> 来装载中间件，通过 compose 方法可以组合函数</p><p>异步的问题可以通过 <code>redux-thunk</code> 解决，用法也不难 react 组件中使用相关如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置 redux 加上这个...</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware, compose &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(getUser, compose(applyMiddleware(thunk)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// react 中使用</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"></span><br><span class="line">handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.props.dispatch(<span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> axios.get(<span class="string">'https://randomuser.me/api/'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        type: types.CHANGE_ARRAY,</span><br><span class="line">        payload: &#123;</span><br><span class="line">          name: res.data.results[<span class="number">0</span>].name.title</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: state.demo.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps)(Demo)</span><br></pre></td></tr></table></figure><blockquote><p>处理异步的还有很多插件 如 redux-soga 等，楼主并未实践过，所以不做延伸…</p></blockquote><h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p>下面是在 react 中使用的代码的雏形：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> defaultState = &#123;</span><br><span class="line">  count: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reducer</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demoReducer</span>(<span class="params">state = defaultState, action = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, payload &#125; = action</span><br><span class="line">  <span class="keyword">const</span> res = <span class="built_in">Object</span>.assign(&#123;&#125;, state)</span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">'changeCount'</span>) &#123;</span><br><span class="line">    res.count = payload.count</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Store </span>存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。</span></span><br><span class="line"><span class="comment"> * combineReducers(&#123; ...reducers &#125;) 可以组合多个reducer</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  demoReducer,</span><br><span class="line">  <span class="built_in">window</span>.devToolsExtension &amp;&amp; <span class="built_in">window</span>.devToolsExtension() <span class="comment">// 配置redux 开发工具</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 根元素下配置下 Provider</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 组件中使用</span></span><br><span class="line"><span class="regexp">import &#123; connect &#125; from 'react-redux'</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/use</span></span><br><span class="line"><span class="regexp">this.dispatch(&#123;</span></span><br><span class="line"><span class="regexp">  type: 'changeCount',</span></span><br><span class="line"><span class="regexp">  payload: &#123;</span></span><br><span class="line"><span class="regexp">    count: 22</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const mapStateToProps = (state, props) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return &#123;</span></span><br><span class="line"><span class="regexp">    name: state.demo.name</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default connect(mapStateToProps)(Demo)</span></span><br></pre></td></tr></table></figure><h3 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps"></a>mapStateToProps</h3><ul><li>用于建立组件跟 store 的 state 的映射关系作为一个函数，它可以传入两个参数，结果一定要返回一个 object</li><li>传入<code>mapStateToProps</code>之后，会订阅 store 的状态改变，在每次 store 的 state 发生变化的时候，都会被调用</li><li>如果写了第二个参数 props，那么当 props 发生变化的时候，mapStateToProps 也会被调用</li></ul><h3 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps"></a>mapDispatchToProps</h3><ul><li><code>mapDispatchToProps</code>用于建立组件跟 store.dispatch 的映射关系</li><li>可以是一个 object，也可以传入函数</li><li>如果<code>mapDispatchToProps</code>是一个函数，它可以传入 dispatch,props,定义 UI 组件如何发出 action，实际上就是要调用 dispatch 这个方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面中使用...</span></span><br><span class="line"><span class="keyword">this</span>.props.changeName()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">&#123; changeName &#125; = (dispatch, props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> bindActionCreators(</span><br><span class="line">    &#123;</span><br><span class="line">      changeName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          type: types.UPDATE_NAME,</span><br><span class="line">          payload: &#123;</span><br><span class="line">            name: <span class="string">'大大大'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    dispatch</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapDispatchToProps)(App)</span><br></pre></td></tr></table></figure><h2 id="模块化配置"><a href="#模块化配置" class="headerlink" title="模块化配置"></a>模块化配置</h2><p>下面的配置仅供参考。实现的功能：</p><ul><li>整合 <code>action</code>、<code>types</code>、<code>reducer</code> 到一个文件</li><li>根据开发/生成环境配置不同的 <code>redux</code> 中间件(开发环境配置 <code>dev-tools</code> )</li><li>支持装饰器模式</li><li><code>redux</code> 热加载配置（这里面顺便将 <code>react</code> 热加载配置也加上了）</li></ul><p>注意：项目基于 <code>create-react-app</code> <code>eject</code> 后的配置改造实现的。下面用了别名 @ ，需要改下 <code>webpack</code> 的配置，如果你配置不成功。详情可以看我的 <code>github</code> 上面有源码. <a href="https://github.com/gershonv/react-demo" target="_blank" rel="noopener">链接入口</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install redux react-redux redux-thunk --save</span><br><span class="line">npm install redux-devtools-extension react-hot-loader -D</span><br><span class="line">npm install @babel/plugin-proposal-decorators -D</span><br></pre></td></tr></table></figure><p>相关文件夹如图：<br><img src="https://user-gold-cdn.xitu.io/2018/12/11/1679c389904fbb55?w=368&amp;h=300&amp;f=png&amp;s=16726" alt></p><h4 id="models-demo-js"><a href="#models-demo-js" class="headerlink" title="models/demo.js"></a>models/demo.js</h4><p>demo 模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types</span></span><br><span class="line"><span class="keyword">const</span> ADD_COUNT = <span class="string">'ADD_COUNT'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// actions</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addCount = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: ADD_COUNT &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// state</span></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  count: <span class="number">11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> demoReducer = <span class="function">(<span class="params">state = defaultState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ADD_COUNT:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">count</span>: ++state.count &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> demoReducer</span><br></pre></td></tr></table></figure><h4 id="models-index-js"><a href="#models-index-js" class="headerlink" title="models/index.js"></a>models/index.js</h4><p>模块的导出口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> demo <span class="keyword">from</span> <span class="string">'./demo'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> combineReducers(&#123;</span><br><span class="line">  demo</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="redux-index-js"><a href="#redux-index-js" class="headerlink" title="redux/index.js"></a>redux/index.js</h4><p><code>redux</code> 仓库的总出口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span></span><br><span class="line"><span class="keyword">import</span> &#123; compose, createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; composeWithDevTools &#125; <span class="keyword">from</span> <span class="string">'redux-devtools-extension'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">'./models'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> storeEnhancers</span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">  storeEnhancers = compose(thunk)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  storeEnhancers = compose(composeWithDevTools(applyMiddleware(thunk)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> configureStore = <span class="function">(<span class="params">initialState = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> store = createStore(rootReducer, initialState, storeEnhancers)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">module</span>.hot &amp;&amp; process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="comment">// Enable Webpack hot module replacement for reducers</span></span><br><span class="line">    <span class="built_in">module</span>.hot.accept(<span class="string">'./models'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'replacing reducer...'</span>)</span><br><span class="line">      <span class="keyword">const</span> nextRootReducer = <span class="built_in">require</span>(<span class="string">'./models'</span>).default</span><br><span class="line">      store.replaceReducer(nextRootReducer)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> store</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> configureStore()</span><br></pre></td></tr></table></figure><h4 id="src-index-js"><a href="#src-index-js" class="headerlink" title="src/index.js"></a>src/index.js</h4><p>react 项目的入口配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> &#123; AppContainer &#125; <span class="keyword">from</span> <span class="string">'react-hot-loader'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'@/redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> render = <span class="function"><span class="params">Component</span> =&gt;</span> &#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;AppContainer&gt;</span><br><span class="line">      &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;Component /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>AppContainer&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render(App)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">'./App'</span>, () =&gt; &#123;</span><br><span class="line">    render(App)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="App-jsx"><a href="#App-jsx" class="headerlink" title="App.jsx"></a>App.jsx</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; addCount &#125; <span class="keyword">from</span> <span class="string">'@/redux/models/demo'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">'antd'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">  count: state.demo.count</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">@connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  &#123; addCount &#125;</span><br><span class="line">)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReduxTest</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.count&#125;</span><br><span class="line">        &lt;Button type=<span class="string">"primary"</span> onClick=&#123;<span class="keyword">this</span>.props.addCount&#125;&gt;</span><br><span class="line">          Click</span><br><span class="line">        &lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;hr /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default ReduxTest</span></span><br></pre></td></tr></table></figure><h4 id="babelrc"><a href="#babelrc" class="headerlink" title=".babelrc"></a>.babelrc</h4><p>配置 babel 装饰器模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"react-app"</span>],</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    [<span class="string">"@babel/plugin-proposal-decorators"</span>, &#123; <span class="string">"legacy"</span>: <span class="literal">true</span> &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vscode 装饰器模式如果有报警的话，可以根目录下新建 <code>jsconfig.json</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="string">"experimentalDecorators"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">"baseUrl"</span>: <span class="string">"./"</span>,</span><br><span class="line">    <span class="string">"paths"</span>: &#123;</span><br><span class="line">      <span class="string">"@/*"</span>: [</span><br><span class="line">        <span class="string">"src/*"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"jsx"</span>: <span class="string">"react"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"exclude"</span>: [</span><br><span class="line">    <span class="string">"node_modules"</span>,</span><br><span class="line">    <span class="string">"build"</span>,</span><br><span class="line">    <span class="string">"config"</span>,</span><br><span class="line">    <span class="string">"scripts"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="noopener">阮一峰 redux 入门教程</a></li><li>配置文件可以看我的 github : <a href="https://github.com/gershonv/react-demo" target="_blank" rel="noopener">react-demo</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;rudux&quot;&gt;&lt;a href=&quot;#rudux&quot; class=&quot;headerlink&quot; title=&quot;rudux&quot;&gt;&lt;/a&gt;rudux&lt;/h2&gt;&lt;p&gt;&lt;code&gt;redux&lt;/code&gt; 运行流程图：&lt;br&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/12/165c9daf60abdbd6?w=638&amp;amp;h=479&amp;amp;f=jpeg&amp;amp;s=21322&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;简单概述：&lt;strong&gt;click&lt;/strong&gt; -&amp;gt; &lt;strong&gt;store.dispatch(action)&lt;/strong&gt; -&amp;gt; &lt;strong&gt;reduer&lt;/strong&gt; -&amp;gt; &lt;strong&gt;newState&lt;/strong&gt; -&amp;gt; &lt;strong&gt;viewUpdate&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;react-readux&lt;/strong&gt; 中 通过 &lt;strong&gt;connect&lt;/strong&gt; 链接组件和 &lt;strong&gt;redux&lt;/strong&gt; , &lt;strong&gt;this.props.dispatch()&lt;/strong&gt; 调用&lt;/p&gt;
&lt;p&gt;后面将会讲到…&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redux&lt;/code&gt; 依赖包也是十分的简洁&lt;br&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/14/165d8c900fb1fcd4?w=280&amp;amp;h=295&amp;amp;f=png&amp;amp;s=14746&quot; alt&gt;&lt;br&gt;先来个&lt;code&gt;demo&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="https://weifo.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://weifo.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>react - hooks(v16.7)</title>
    <link href="https://weifo.github.io/2020/02/08/react-hooks/"/>
    <id>https://weifo.github.io/2020/02/08/react-hooks/</id>
    <published>2020-02-08T07:30:32.000Z</published>
    <updated>2020-03-15T13:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文不做概念性的解析，旨在实操 <code>hooks</code>，相关资源可以自行谷歌。以下提供相关参考资料：</p><ul><li><a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">Introducing Hooks</a></li><li><a href="https://juejin.im/post/5be409696fb9a049b13db042" target="_blank" rel="noopener">理解 React Hooks</a></li><li><a href="https://juejin.im/post/5bffc271e51d454dca3547b1#heading-0" target="_blank" rel="noopener">React Hooks 实用指南</a> - 大都借鉴这篇文章</li><li><a href="https://juejin.im/post/5bd53d6a51882528382d8108" target="_blank" rel="noopener">Hooks 一览</a></li></ul><a id="more"></a><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><blockquote><p><code>useState</code> 可以让您的函数组件也具备类组件的 <code>state</code> 功能。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@state </span>- state的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@setState </span>- 更新state的函数, 接受一个参数值来更新 state</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> [state, setState] = useState(initialState)</span><br></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Base</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Base</span></span><br></pre></td></tr></table></figure><p>值得注意的是，<code>state</code> 是对象的话， <code>setState</code> 接收什么参数，就更新对象下的所有属性，而不是更新单个属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [info, setInfo] = useState(&#123;</span><br><span class="line">    name: <span class="string">'guodada'</span>,</span><br><span class="line">    age: <span class="number">22</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;name: &#123;info.name&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;age: &#123;info.age&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setInfo(&#123; <span class="attr">name</span>: <span class="string">'Sam'</span> &#125;)&#125;&gt;setInfo&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>click button</code> =&gt; <code>info = { name: &#39;Sam&#39; }</code>，<code>age</code> 丢失。</p><p>根据业务需求，我们可以在函数组件中使用多个 <code>useState</code>，这里不再进行演示。</p><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p><code>Effect Hook</code>: 它与 <code>React Class</code> 中的 <code>componentDidMount</code>，<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 具有相同的用途。模拟的是生命周期</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@didUpdate </span>- function</span></span><br><span class="line"><span class="comment"> * @[] - 参数2为数组，不加参数或者不写的话任何state 的变化都会执行 didUpdate 函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">useEffect(didUpdate, [])</span><br></pre></td></tr></table></figure><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span> times`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span> times`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;You clicked &#123;<span class="keyword">this</span>.state.count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;</span></span><br><span class="line"><span class="regexp">          Click me</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>添加第二个参数进行控制<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> [count2, setCount2] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'run useEffect'</span>)</span><br><span class="line">  &#125;, [count])  <span class="comment">// 只有count 变化时才执行这个 useEffect 函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/</span>button&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count2&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount2(count2 + 1)&#125;&gt;Click me&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><blockquote><p><code>useReducer</code> 是 <code>useState</code> 的代提方案。当你有一些更负责的数据时可以使用它。（组件本地的redux）</p></blockquote><p>使用语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@state </span>=&gt; your state</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dispatch</span></span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param <span class="type">&#123;state&#125;</span> </span></span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@param <span class="type">&#123;action&#125;</span>  </span></span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState)</span><br></pre></td></tr></table></figure><h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TestUseReducer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(</span><br><span class="line">    (state, action) =&gt; &#123;</span><br><span class="line">      <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'update'</span>:</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">name</span>: action.payload &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">return</span> state</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">''</span> &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleNameChange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="string">'update'</span>, <span class="attr">payload</span>: e.target.value &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;你好：&#123;state.name&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input onChange=&#123;handleNameChange&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class App extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div className="App"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h1&gt;Hello&lt;/</span>h1&gt;</span><br><span class="line">        &lt;h2&gt;Start editing to see some magic happen!&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &lt;TestUseReducer /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App</span></span><br></pre></td></tr></table></figure><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><blockquote><p><code>useCallback</code> 和 <code>useMemo</code> 有些相似。它接收一个内联函数和一个数组，它返回的是一个记忆化版本的函数。</p></blockquote><p>使用语法如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> computeExpensiveValue(a), [a])</span><br></pre></td></tr></table></figure><h3 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, useCallback &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TestUseCallback</span>(<span class="params">&#123; num &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> memoizedCallback = useCallback(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'这里监听 num 值的更新重新做一些操作和计算'</span>)</span><br><span class="line">      num.forEach(<span class="function"><span class="params">item</span> =&gt;</span> item++ )</span><br><span class="line">      <span class="keyword">return</span> num</span><br><span class="line">    &#125;,</span><br><span class="line">    [num]</span><br><span class="line">  )</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'记忆 num &gt; '</span>, memoizedCallback())</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'原始 num &gt; '</span>, num)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> num1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> num2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">num</span>: num1, <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">        count: state.count + <span class="number">1</span></span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChangeNum = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: num2 &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; num &#125; = <span class="keyword">this</span>.state</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">        &lt;h1&gt;Hello&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h2&gt;Start editing to see some magic happen!&lt;/</span>h2&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleChangeNum&#125;&gt;修改传入的Num值&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;TestUseCallback num=&#123;num&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App</span></span><br></pre></td></tr></table></figure><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TestUseRef</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    inputEl.current.focus() <span class="comment">// 设置useRef返回对象的值</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;TestUseRef&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input ref=&#123;inputEl&#125; type="text" /</span>&gt;</span><br><span class="line">        &lt;button onClick=&#123;onButtonClick&#125;&gt;input聚焦&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default TestUseRef</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文不做概念性的解析，旨在实操 &lt;code&gt;hooks&lt;/code&gt;，相关资源可以自行谷歌。以下提供相关参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://reactjs.org/docs/hooks-intro.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Introducing Hooks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5be409696fb9a049b13db042&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;理解 React Hooks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5bffc271e51d454dca3547b1#heading-0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React Hooks 实用指南&lt;/a&gt; - 大都借鉴这篇文章&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5bd53d6a51882528382d8108&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hooks 一览&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="React" scheme="https://weifo.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://weifo.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>react - 生命周期</title>
    <link href="https://weifo.github.io/2020/02/05/react-LifeCycle/"/>
    <id>https://weifo.github.io/2020/02/05/react-LifeCycle/</id>
    <published>2020-02-05T13:20:13.000Z</published>
    <updated>2020-03-15T13:09:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="v16-3"><a href="#v16-3" class="headerlink" title="v16.3+"></a>v16.3+</h2><ul><li>Mounting<ul><li>constructor(props)</li><li>static getDerivedStateFromProps(props, state)</li><li>render()</li><li>componentDidMount()</li></ul></li><li>Updating<ul><li>static getDerivedStateFromProps()</li><li>shouldComponentUpdate(nextProps, nextState)</li><li>render()</li><li>getSnapshotBeforeUpdate(prevProps, prevState)</li><li>componentDidUpdate(prevProps, prevState, snapshot)</li></ul></li></ul><a id="more"></a><h3 id="constructor-props"><a href="#constructor-props" class="headerlink" title="constructor(props)"></a>constructor(props)</h3><p>React 组件的构造函数在安装之前被调用。在为 React.Component 子类实现构造函数时，应该在任何其他语句之前调用 <code>super(props)</code>。<br>否则，<code>this.props</code> 将在构造函数中未定义，这可能导致错误。</p><p>Avoid copying props into state! This is a common mistake:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line"> <span class="keyword">super</span>(props)</span><br><span class="line"> <span class="comment">// Don't do this!</span></span><br><span class="line"> <span class="keyword">this</span>.state = &#123; <span class="attr">color</span>: props.color &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="static-getDerivedStateFromProps-nextProps-prevState"><a href="#static-getDerivedStateFromProps-nextProps-prevState" class="headerlink" title="static getDerivedStateFromProps(nextProps, prevState)"></a>static getDerivedStateFromProps(nextProps, prevState)</h3><p><code>props / state</code> 改变时触发，需要返回一个对象或者 <code>null</code>，相当于 <code>setState</code></p><ul><li>demo</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevState)&#123;</span><br><span class="line">  <span class="keyword">if</span> (nextProps.sum !== prevState.sum) <span class="keyword">return</span> &#123; <span class="attr">sum</span>: nextProps.sum &#125; <span class="comment">// 类似于 setState(&#123; sum: nextProps.sum &#125;)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">  <span class="comment">// don't do this</span></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">num</span>: <span class="number">12</span> &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a>componentDidMount()</h3><p>组件挂载后。</p><h3 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)"></a>shouldComponentUpdate(nextProps, nextState)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState)</span><br></pre></td></tr></table></figure><p>return true / false 来决定是否重新 render</p><h3 id="getSnapshotBeforeUpdate-prevProps-prevState"><a href="#getSnapshotBeforeUpdate-prevProps-prevState" class="headerlink" title="getSnapshotBeforeUpdate(prevProps, prevState)"></a>getSnapshotBeforeUpdate(prevProps, prevState)</h3><p>相当于 <code>componentWillUpdate</code></p><h3 id="componentDidUpdate-prevProps-prevState-snapshot"><a href="#componentDidUpdate-prevProps-prevState-snapshot" class="headerlink" title="componentDidUpdate(prevProps, prevState, snapshot)"></a>componentDidUpdate(prevProps, prevState, snapshot)</h3><p>更新后 - 这里谨慎使用 setState()</p><h2 id="v16-3-以下"><a href="#v16-3-以下" class="headerlink" title="v16.3 以下"></a>v16.3 以下</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 挂载数据：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example </span>constructor =&gt; componentWillMount =&gt; render =&gt; componentDidMount</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数据变化：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example </span>props change: componentWillReceiveProps =&gt; shouldComponentUpdate =&gt; componentWillUpdate =&gt; render =&gt; componentDidUpdate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example </span>state change: shouldComponentUpdate =&gt; componentWillUpdate =&gt; componentDidUpdate</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifeCycle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>() <span class="comment">// 声明constructor时必须调用super方法</span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      subNum: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'01 constructor'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'02 componentWillMount'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'04 componentDidMount'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'05 componentWillReceiveProps'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'06 shouldComponentUpdate'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 记得要返回true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUpdate(nextProps, nextState) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'07 componentWillUpdate'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'08 componentDidUpdate'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'09 componentWillUnmount'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeState = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">      subNum: ++prevState.subNum</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.changeState&#125;&gt;change state&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h2&gt;&#123;this.state.subNum&#125;&lt;/</span>h2&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class App extends Component &#123;</span></span><br><span class="line"><span class="regexp">  state = &#123;</span></span><br><span class="line"><span class="regexp">    num: 1</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  changeProps = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ this.setState((prevState, props) =&gt; (&#123;&#125;))</span></span><br><span class="line"><span class="regexp">    this.setState(prevState =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">      num: ++prevState.num</span></span><br><span class="line"><span class="regexp">    &#125;))</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.changeProps&#125;&gt;change props&lt;/</span>button&gt;</span><br><span class="line">        &lt;hr /&gt;</span><br><span class="line">        &lt;LifeCycle num=&#123;<span class="keyword">this</span>.state.num&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;v16-3&quot;&gt;&lt;a href=&quot;#v16-3&quot; class=&quot;headerlink&quot; title=&quot;v16.3+&quot;&gt;&lt;/a&gt;v16.3+&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Mounting&lt;ul&gt;
&lt;li&gt;constructor(props)&lt;/li&gt;
&lt;li&gt;static getDerivedStateFromProps(props, state)&lt;/li&gt;
&lt;li&gt;render()&lt;/li&gt;
&lt;li&gt;componentDidMount()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Updating&lt;ul&gt;
&lt;li&gt;static getDerivedStateFromProps()&lt;/li&gt;
&lt;li&gt;shouldComponentUpdate(nextProps, nextState)&lt;/li&gt;
&lt;li&gt;render()&lt;/li&gt;
&lt;li&gt;getSnapshotBeforeUpdate(prevProps, prevState)&lt;/li&gt;
&lt;li&gt;componentDidUpdate(prevProps, prevState, snapshot)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="React" scheme="https://weifo.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://weifo.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>react-context</title>
    <link href="https://weifo.github.io/2020/02/03/react-context/"/>
    <id>https://weifo.github.io/2020/02/03/react-context/</id>
    <published>2020-02-03T01:58:42.000Z</published>
    <updated>2020-03-15T13:08:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p><code>Context</code> 设计目的是为共享那些被认为对于一个组件树而言是“全局”的数据，你可以看做为 <code>redux</code>，因为 <code>redux</code> 也是通过这个东东实现的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 创建 context</span></span><br><span class="line"><span class="comment"> * 2. 根组件 App 包裹 MyContext.Provider</span></span><br><span class="line"><span class="comment"> * 3. App =&gt; Father =&gt; Child =&gt; MyContext.Consumer =&gt; context.age 取出结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> MyContext = React.createContext()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Child = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;MyContext.Consumer&gt;&#123;(&#123; age &#125;) =&gt; <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>My age is &#123;age&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;&lt;<span class="regexp">/MyContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const Father = () =&gt; &lt;Child /</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;MyContext.Provider value=&#123;&#123; <span class="attr">age</span>: <span class="number">22</span> &#125;&#125;&gt;</span><br><span class="line">        &lt;Father /&gt;</span><br><span class="line">      &lt;<span class="regexp">/MyContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h2><h3 id="React-createContext"><a href="#React-createContext" class="headerlink" title="React.createContext"></a>React.createContext</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Provider, Consumer &#125; = React.createContext(defaultValue)</span><br></pre></td></tr></table></figure><p>创建一对 { <code>Provider</code>, <code>Consumer</code> }。当 React 渲染 <code>context</code> 组件 <code>Consumer</code> 时，它将从组件树的上层中最接近的匹配的 <code>Provider</code> 读取当前的 <code>context</code> 值。</p><h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Provider value=&#123;<span class="comment">/* some value */</span>&#125;&gt;</span><br></pre></td></tr></table></figure><p>React 组件允许 <code>Consumers</code> 订阅 <code>context</code> 的改变。<br>接收一个 <code>value</code> 属性传递给 <code>Provider</code> 的后代 <code>Consumers</code>。一个 <code>Provider</code> 可以联系到多个 <code>Consumers</code>。Providers 可以被嵌套以覆盖组件树内更深层次的值。</p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Consumer&gt;</span><br><span class="line">  &#123;value =&gt; <span class="comment">/* render something based on the context value */</span>&#125;</span><br><span class="line">&lt;<span class="regexp">/Consumer&gt;</span></span><br></pre></td></tr></table></figure><p>一个可以订阅 <code>context</code> 变化的 React 组件。</p><p>注意，<code>MyContext.Consumer</code> 使用的是 <code>render props</code> 这种模式，<code>render props</code> 模式指的是让 <code>prop</code> 可以是一个 <code>render</code> 函数</p><h2 id="父子耦合"><a href="#父子耦合" class="headerlink" title="父子耦合"></a>父子耦合</h2><p>经常需要从组件树中某个深度嵌套的组件中更新 <code>context</code>。在这种情况下，可以通过 <code>context</code> 向下传递一个函数，以允许 <code>Consumer</code> 更新 <code>context</code> ：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyContext = React.createContext()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Child = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;MyContext.Consumer&gt;</span><br><span class="line">     &#123;ctx =&gt; (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;My age is &#123;ctx.age&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;ctx.changeAge&#125;&gt;changeAge&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>MyContext.Consumer&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Father = <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    age: <span class="number">22</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  changeAge = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">      age: ++prevState.age</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;MyContext.Provider value=&#123;&#123;</span><br><span class="line">        age: <span class="keyword">this</span>.state.age,</span><br><span class="line">        changeAge: <span class="keyword">this</span>.changeAge</span><br><span class="line">      &#125;&#125;&gt;</span><br><span class="line">        &lt;Father /&gt;</span><br><span class="line">      &lt;<span class="regexp">/MyContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App</span></span><br></pre></td></tr></table></figure><h2 id="作用于多个上下文"><a href="#作用于多个上下文" class="headerlink" title="作用于多个上下文"></a>作用于多个上下文</h2><p>为了保持 <code>context</code> 快速进行二次渲染， <code>React</code> 需要使每一个 <code>Consumer</code> 在组件树中成为一个单独的节点。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyContext = React.createContext()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> UserContext = React.createContext()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Child = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;MyContext.Consumer&gt;</span><br><span class="line">    &#123;ctx =&gt; (</span><br><span class="line">      &lt;UserContext.Consumer&gt;</span><br><span class="line">        &#123;user =&gt; (</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">            &lt;p&gt;My name is &#123;user.name&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;p&gt;My age is &#123;ctx.age&#125;&lt;/</span>p&gt;</span><br><span class="line">            &lt;button onClick=&#123;ctx.changeAge&#125;&gt;changeAge&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">          &lt;/</span>div&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;<span class="regexp">/UserContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">    )&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>MyContext.Consumer&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Father = <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    age: <span class="number">22</span>,</span><br><span class="line">    name: <span class="string">'郭大大'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeAge = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">      age: ++prevState.age</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;MyContext.Provider</span><br><span class="line">        value=&#123;&#123;</span><br><span class="line">          age: <span class="keyword">this</span>.state.age,</span><br><span class="line">          changeAge: <span class="keyword">this</span>.changeAge</span><br><span class="line">        &#125;&#125;&gt;</span><br><span class="line">        &lt;UserContext.Provider value=&#123;&#123; <span class="attr">name</span>: <span class="keyword">this</span>.state.name &#125;&#125;&gt;</span><br><span class="line">          &lt;Father /&gt;</span><br><span class="line">        &lt;<span class="regexp">/UserContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>MyContext.Provider&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><p>如果两个或者多个上下文的值经常被一起使用，也许你需要考虑你自己渲染属性的组件提供给它们。</p><h2 id="在生命周期方法中访问-Context"><a href="#在生命周期方法中访问-Context" class="headerlink" title="在生命周期方法中访问 Context"></a>在生命周期方法中访问 Context</h2><p>在生命周期方法中从上下文访问值是一种相对常见的用例。而不是将上下文添加到每个生命周期方法中，只需要将它作为一个 <code>props</code> 传递，然后像通常使用 <code>props</code> 一样去使用它。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyContext = React.createContext()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.props.ctx) </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; age, changeAge &#125; = <span class="keyword">this</span>.props.ctx</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;My age is &#123;age&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;changeAge&#125;&gt;changeAge&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const Father = props =&gt; (</span></span><br><span class="line"><span class="regexp">  &lt;MyContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">    &#123;ctx =&gt; &lt;Child &#123;...props&#125; ctx=&#123;ctx&#125; /</span>&gt;&#125;</span><br><span class="line">  &lt;<span class="regexp">/MyContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class App extends Component &#123;</span></span><br><span class="line"><span class="regexp">  state = &#123;</span></span><br><span class="line"><span class="regexp">    age: 22</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  changeAge = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    this.setState(prevState =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">      age: ++prevState.age</span></span><br><span class="line"><span class="regexp">    &#125;))</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;MyContext.Provider</span></span><br><span class="line"><span class="regexp">        value=&#123;&#123;</span></span><br><span class="line"><span class="regexp">          age: this.state.age,</span></span><br><span class="line"><span class="regexp">          changeAge: this.changeAge</span></span><br><span class="line"><span class="regexp">        &#125;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Father /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/MyContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App</span></span><br></pre></td></tr></table></figure><h2 id="转发-Refs"><a href="#转发-Refs" class="headerlink" title="转发 Refs"></a>转发 Refs</h2><p>一个关于渲染属性API的问题是 <code>refs</code> 不会自动的传递给被封装的元素。为了解决这个问题，使用 <code>React.forwardRef</code>：</p><ul><li>fancy-button.js</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FancyButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  focus() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 context 传递当前的 "theme" 给 FancyButton.</span></span><br><span class="line"><span class="comment">// 使用 forwardRef 传递 refs 给 FancyButton 也是可以的.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">  &lt;ThemeContext.Consumer&gt;</span><br><span class="line">    &#123;theme =&gt; (</span><br><span class="line">      &lt;FancyButton &#123;...props&#125; theme=&#123;theme&#125; ref=&#123;ref&#125; /&gt;</span><br><span class="line">    )&#125;</span><br><span class="line">  &lt;<span class="regexp">/ThemeContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">))</span></span><br></pre></td></tr></table></figure><ul><li>app.js</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> FancyButton <span class="keyword">from</span> <span class="string">'./fancy-button'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ref = React.createRef()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ref属性将指向 FancyButton 组件,</span></span><br><span class="line"><span class="comment">// ThemeContext.Consumer 没有包裹它</span></span><br><span class="line"><span class="comment">// 这意味着我们可以调用 FancyButton 的方法就像这样 ref.current.focus()</span></span><br><span class="line">&lt;FancyButton ref=&#123;ref&#125; onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">  Click me!</span><br><span class="line">&lt;<span class="regexp">/FancyButton&gt;</span></span><br></pre></td></tr></table></figure><h2 id="尽量减少使用-context"><a href="#尽量减少使用-context" class="headerlink" title="尽量减少使用 context"></a>尽量减少使用 context</h2><p>因为 <code>context</code> 使用 <code>reference identity</code> 确定何时重新渲染，在 <code>Consumer</code> 中，当一个 <code>Provider</code> 的父节点重新渲染的时候，有一些问题可能触发意外的渲染。例如下面的代码，所有的 <code>Consumner</code> 在 <code>Provider</code> 重新渲染之时，每次都将重新渲染，因为一个新的对象总是被创建对应 <code>Provider</code> 里的 value</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Provider value=&#123;&#123;<span class="attr">something</span>: <span class="string">'something'</span>&#125;&#125;&gt;</span><br><span class="line">        &lt;Toolbar /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>为了防止这样, 提升 <code>value</code> 到父节点的 <code>state</code> 里:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: &#123;<span class="attr">something</span>: <span class="string">'something'</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Provider value=&#123;<span class="keyword">this</span>.state.value&#125;&gt;</span><br><span class="line">        &lt;Toolbar /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>React context的局限性：</p><ol><li>在组件树中，如果中间某一个组件 ShouldComponentUpdate returning false 了，会阻碍 context 的正常传值，导致子组件无法获取更新。</li><li>组件本身 extends React.PureComponent 也会阻碍 context 的更新。</li><li>Context 应该是唯一不可变的</li><li>组件只在初始化的时候去获取 Context</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简单使用&quot;&gt;&lt;a href=&quot;#简单使用&quot; class=&quot;headerlink&quot; title=&quot;简单使用&quot;&gt;&lt;/a&gt;简单使用&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Context&lt;/code&gt; 设计目的是为共享那些被认为对于一个组件树而言是“全局”的数据，你可以看做为 &lt;code&gt;redux&lt;/code&gt;，因为 &lt;code&gt;redux&lt;/code&gt; 也是通过这个东东实现的。&lt;/p&gt;
&lt;figure class=&quot;highlight jsx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; React, &amp;#123; Component &amp;#125; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;react&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * 1. 创建 context&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * 2. 根组件 App 包裹 MyContext.Provider&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * 3. App =&amp;gt; Father =&amp;gt; Child =&amp;gt; MyContext.Consumer =&amp;gt; context.age 取出结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; MyContext = React.createContext()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Child = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;MyContext.Consumer&amp;gt;&amp;#123;(&amp;#123; age &amp;#125;) =&amp;gt; &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;My age is &amp;#123;age&amp;#125;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&amp;#125;&amp;lt;&lt;span class=&quot;regexp&quot;&gt;/MyContext.Consumer&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;const Father = () =&amp;gt; &amp;lt;Child /&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Component&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  render() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;MyContext.Provider value=&amp;#123;&amp;#123; &lt;span class=&quot;attr&quot;&gt;age&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;22&lt;/span&gt; &amp;#125;&amp;#125;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;Father /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;&lt;span class=&quot;regexp&quot;&gt;/MyContext.Provider&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;    )&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;export default App&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="React" scheme="https://weifo.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://weifo.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>react 入门</title>
    <link href="https://weifo.github.io/2020/02/02/react-basic/"/>
    <id>https://weifo.github.io/2020/02/02/react-basic/</id>
    <published>2020-02-02T15:03:29.000Z</published>
    <updated>2020-03-15T12:52:04.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react@16/umd/react.development.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react-dom@16/umd/react-dom.development.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 生产环境中不建议使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/babel-standalone@6.15.0/babel.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span></span><br><span class="line">);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>react.min.js - React 的核心库</li><li>react-dom.min.js - 提供与 DOM 相关的功能</li><li>babel.min.js - Babel 可以将 ES6 代码转为 ES5 代码</li></ul><a id="more"></a><h2 id="使用-create-react-app-快速构建-React-开发环境"><a href="#使用-create-react-app-快速构建-React-开发环境" class="headerlink" title="使用 create-react-app 快速构建 React 开发环境"></a>使用 create-react-app 快速构建 React 开发环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g create-react-app</span><br><span class="line">create-react-app my-app</span><br><span class="line">npm run eject</span><br></pre></td></tr></table></figure><p><code>TodoList</code><br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            list: [],</span><br><span class="line">            inputValue: <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">this</span>.handleBtnClick = <span class="keyword">this</span>.handleBtnClick.bind(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleChange(e) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            inputValue: e.target.value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleBtnClick() &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(</span><br><span class="line">            &#123;</span><br><span class="line">                list: [...this.state.list, <span class="keyword">this</span>.state.inputValue],</span><br><span class="line">                inputValue: <span class="string">''</span></span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleItemClick(index) &#123;</span><br><span class="line">        <span class="keyword">let</span> list = [...this.state.list]</span><br><span class="line">        list.splice(index, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            list</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;input value=&#123;<span class="keyword">this</span>.state.inputValue&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125;/&gt;</span><br><span class="line">                    &lt;button onClick=&#123;<span class="keyword">this</span>.handleBtnClick&#125; className=<span class="string">'btn'</span>&gt;add&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;/</span>div&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">this</span>.state.list.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> (</span><br><span class="line">                                &lt;li key=&#123;index&#125; onClick=&#123;<span class="keyword">this</span>.handleItemClick.bind(<span class="keyword">this</span>, index)&#125;&gt;&#123;item&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">                            )</span></span><br><span class="line"><span class="regexp">                        &#125;)</span></span><br><span class="line"><span class="regexp">                    &#125;</span></span><br><span class="line"><span class="regexp">                &lt;/u</span>l&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default TodoList</span></span><br></pre></td></tr></table></figure></p><p>组件化<br><code>todoList</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> TodoItem <span class="keyword">from</span> <span class="string">'./TodoItem'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            list: [],</span><br><span class="line">            inputValue: <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">this</span>.handleBtnClick = <span class="keyword">this</span>.handleBtnClick.bind(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleChange(e) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            inputValue: e.target.value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleBtnClick() &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(</span><br><span class="line">            &#123;</span><br><span class="line">                list: [...this.state.list, <span class="keyword">this</span>.state.inputValue],</span><br><span class="line">                inputValue: <span class="string">''</span></span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleItemClick(index) &#123;</span><br><span class="line">        <span class="keyword">let</span> list = [...this.state.list]</span><br><span class="line">        list.splice(index, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;list&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;input value=&#123;<span class="keyword">this</span>.state.inputValue&#125; onChange=&#123;<span class="keyword">this</span>.handleChange&#125;/&gt;</span><br><span class="line">                    &lt;button onClick=&#123;<span class="keyword">this</span>.handleBtnClick&#125; className=<span class="string">'btn'</span>&gt;add&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;/</span>div&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">this</span>.state.list.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">                            <span class="comment">// return (</span></span><br><span class="line">                            <span class="comment">//     &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemClick.bind(this, index)&#125;&gt;&#123;item&#125;&lt;/li&gt;</span></span><br><span class="line">                            <span class="comment">// )</span></span><br><span class="line">                            <span class="keyword">return</span> (</span><br><span class="line">                                &lt;TodoItem</span><br><span class="line">                                    key=&#123;index&#125;</span><br><span class="line">                                    content=&#123;item&#125;</span><br><span class="line">                                    index=&#123;index&#125;</span><br><span class="line">                                    <span class="keyword">delete</span>=&#123;<span class="keyword">this</span>.handleItemClick.bind(<span class="keyword">this</span>, index)&#125;</span><br><span class="line">                                /&gt;</span><br><span class="line">                            )</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> TodoList</span><br></pre></td></tr></table></figure><p><code>todoItem</code><br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">TodoItem</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">     <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.handleDelete = <span class="keyword">this</span>.handleDelete.bind(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 子组件想要和父组件通信，要调用父组件传递过来的方法</span></span><br><span class="line">     handleDelete(index) &#123;</span><br><span class="line">        <span class="keyword">this</span>.props.delete(index)</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 父组件通过属性的形式向子组件传递参数</span></span><br><span class="line">    <span class="comment">// 子组件通过props接受父组件传递过来的参数</span></span><br><span class="line">     render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;li onClick=&#123;<span class="keyword">this</span>.handleDelete&#125;&gt;&#123;<span class="keyword">this</span>.props.content&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"> export default TodoItem</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 生产环境中不建议使用 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;example&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;text/babel&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ReactDOM.render(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;Hello, world!&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;javascript&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&#39;example&#39;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;react.min.js - React 的核心库&lt;/li&gt;
&lt;li&gt;react-dom.min.js - 提供与 DOM 相关的功能&lt;/li&gt;
&lt;li&gt;babel.min.js - Babel 可以将 ES6 代码转为 ES5 代码&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="React" scheme="https://weifo.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://weifo.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>git 实用指南</title>
    <link href="https://weifo.github.io/2020/01/23/git-command/"/>
    <id>https://weifo.github.io/2020/01/23/git-command/</id>
    <published>2020-01-23T13:30:04.000Z</published>
    <updated>2020-03-15T13:17:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="commit-规范速查"><a href="#commit-规范速查" class="headerlink" title="commit 规范速查"></a>commit 规范速查</h2><ul><li><code>feat</code>：新功能（feature）</li><li><code>fix</code>：修补 bug</li><li><code>docs</code>：文档（documentation）</li><li><code>style</code>： 格式（不影响代码运行的变动）</li><li><code>refactor</code>：重构（即不是新增功能，也不是修改 bug 的代码变动）</li><li><code>test</code>：增加测试</li><li><code>chore</code>：构建过程或辅助工具的变动</li><li><p><code>revert</code>: 撤销以前的 commit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revert: feat(pencil): add <span class="string">'graphiteWidth'</span> option</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h2 id="本地创建、连接远程仓库"><a href="#本地创建、连接远程仓库" class="headerlink" title="本地创建、连接远程仓库"></a>本地创建、连接远程仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建并连接远程仓库</span></span><br><span class="line">mkdir git-demo</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> git-demo/</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接远程仓库</span></span><br><span class="line">git remote add origin https://github.com/gershonv/git-demo.git</span><br></pre></td></tr></table></figure><h2 id="新建文件并推向远端"><a href="#新建文件并推向远端" class="headerlink" title="新建文件并推向远端"></a>新建文件并推向远端</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 a.js</span></span><br><span class="line">touch a.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加到暂存区（见下文）</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># commit 记录（见下文）</span></span><br><span class="line">git commit -m <span class="string">'feat: 新增 a.js 文件'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推向远端 master 分支（见下文）</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><ul><li>git add<ul><li><code>git add [file1 file2 file3...]</code>: 添加多个文件</li><li><code>git add .</code> : 暂存所有文件</li></ul></li></ul><h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><p><img src="https://user-gold-cdn.xitu.io/2019/1/8/1682b86ab859defb?w=505&amp;h=412&amp;f=png&amp;s=45734" alt></p><p>M - 被修改，A - 被添加，D - 被删除，R - 重命名，?? - 未被跟踪</p><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><h3 id="撤销-git-add"><a href="#撤销-git-add" class="headerlink" title="撤销 git add"></a>撤销 git add</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建 b.js 文件</span></span><br><span class="line">touch b.js</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git statis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销 git add</span></span><br><span class="line">git reset head b.js</span><br></pre></td></tr></table></figure><ul><li><code>git reset head</code> : 如果后面什么都不跟的话 就是上一次 add 里面的全部撤销了</li><li><code>git reset head file</code>: 对某个文件进行撤销了</li></ul><h3 id="撤销本地修改"><a href="#撤销本地修改" class="headerlink" title="撤销本地修改"></a>撤销本地修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改文件</span></span><br><span class="line">vim a.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入数据</span></span><br><span class="line"><span class="built_in">shift</span> + i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存退出</span></span><br><span class="line"><span class="built_in">shift</span> + : wq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入暂存区</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'refactor: 修改 a.js 文件'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销修改</span></span><br><span class="line">git checkout -- a.js</span><br></pre></td></tr></table></figure><h3 id="撤销-git-commit"><a href="#撤销-git-commit" class="headerlink" title="撤销 git commit"></a>撤销 git commit</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 commit 记录</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置到某个节点。</span></span><br><span class="line">git reset --hard ea794cf0dcf934b594</span><br></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h3 id="新建分支并推向远程"><a href="#新建分支并推向远程" class="headerlink" title="新建分支并推向远程"></a>新建分支并推向远程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建并切换本地分支</span></span><br><span class="line">git checkout -b dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到远程</span></span><br><span class="line">git push origin dev</span><br></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开发完 dev 分支后</span></span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并 dev 分支到主分支</span></span><br><span class="line">git merge dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有分支 远程+本地</span></span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">git push origin -d dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地分支</span></span><br><span class="line">git checkout master</span><br><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;commit-规范速查&quot;&gt;&lt;a href=&quot;#commit-规范速查&quot; class=&quot;headerlink&quot; title=&quot;commit 规范速查&quot;&gt;&lt;/a&gt;commit 规范速查&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;feat&lt;/code&gt;：新功能（feature）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fix&lt;/code&gt;：修补 bug&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docs&lt;/code&gt;：文档（documentation）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;style&lt;/code&gt;： 格式（不影响代码运行的变动）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;refactor&lt;/code&gt;：重构（即不是新增功能，也不是修改 bug 的代码变动）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;test&lt;/code&gt;：增加测试&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chore&lt;/code&gt;：构建过程或辅助工具的变动&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;revert&lt;/code&gt;: 撤销以前的 commit&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;revert: feat(pencil): add &lt;span class=&quot;string&quot;&gt;&#39;graphiteWidth&#39;&lt;/span&gt; option&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="开发工具" scheme="https://weifo.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Git" scheme="https://weifo.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>HTTP - 缓存机制</title>
    <link href="https://weifo.github.io/2020/01/23/http-cache/"/>
    <id>https://weifo.github.io/2020/01/23/http-cache/</id>
    <published>2020-01-23T01:23:23.000Z</published>
    <updated>2020-03-15T13:17:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存实现的步骤"><a href="#缓存实现的步骤" class="headerlink" title="缓存实现的步骤"></a>缓存实现的步骤</h2><ul><li>首先是当用户请求资源时，会判断是否有缓存，如果没有，则会向原服务器请求资源。</li><li>如果有缓存，则会进入强缓存的范畴，判断缓存是否新鲜<ul><li>如果缓存新鲜，则会直接返回缓存副本给客户端。</li><li>如果缓存不新鲜了，则表示强缓存失败，将会进入到<strong>协商缓存</strong>。</li></ul></li><li>协商缓存将判断是否存在 <code>Etag</code> 和 <code>Last-Modified</code> 首部<ul><li>如果未发生变化，则表示命中了协商缓存，会重定向到缓存副本，将资源返回给客户端</li><li>否则的话表示协商缓存未命中，服务器会返回新的资源。</li></ul></li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/11/4/166de9f3ae4b1f20?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><blockquote><p>服务端告知客户端缓存时间后，由客户端判断并决定是否使用缓存。</p></blockquote><p>强缓存是通过 <code>Expires</code> 首部或 <code>Cache-Control: max-age</code> 来实现的。</p><ul><li><code>Expires</code>: 响应头，代表该资源的过期时间。</li><li><code>Cache-Control</code>: 请求/响应头，缓存控制字段，精确控制缓存策略。</li></ul><a id="more"></a><p><code>server.js</code> - demo</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line">http</span><br><span class="line">  .createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'text/javascript'</span>,</span><br><span class="line">      <span class="string">'Conche-Control'</span>: <span class="string">'max-age=2000, public'</span> <span class="comment">// 缓存时间 2000s；public: 资源允许被中间服务器缓存</span></span><br><span class="line">    &#125;)</span><br><span class="line">    response.end(<span class="string">"console.log('script loaded')"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(<span class="number">3301</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'http://127.0.0.1:3301'</span>)</span><br></pre></td></tr></table></figure><h3 id="Expires-HTTP-1-0"><a href="#Expires-HTTP-1-0" class="headerlink" title="Expires(HTTP/1.0)"></a>Expires(HTTP/1.0)</h3><p><code>Expires</code> 和 <code>Cache-Control: max-age</code> 都是用来标识资源的过期时间的首部。</p><p>由于 <code>expires</code> 是一个绝对时间，如果人为的更改时间，会对缓存的有效期造成影响，使缓存有效期的设置失去意义。因此在 <code>http1.1</code> 中我们有了 <code>expires</code> 的完全替代首部 <code>cache-control：max-age</code></p><h3 id="Cache-Control-HTTP-1-1"><a href="#Cache-Control-HTTP-1-1" class="headerlink" title="Cache-Control(HTTP/1.1)"></a>Cache-Control(HTTP/1.1)</h3><p>除了可以设置 <code>max-age</code> 相对过期时间以外，还可以设置成如下几种值：</p><ul><li><p><code>public</code>，资源允许被中间服务器缓存。</p><blockquote><p>浏览器请求服务器时，如果缓存时间没到，中间服务器直接返回给浏览器内容，而不必请求源服务器。</p></blockquote></li><li><p><code>private</code>，资源不允许被中间代理服务器缓存</p><blockquote><p>浏览器请求服务器时，中间服务器都要把浏览器的请求透传给服务器。</p></blockquote></li><li><p><code>no-cache</code>，浏览器不做缓存检查。</p><blockquote><p>每次访问资源，浏览器都要向服务器询问，如果文件没变化，服务器只告诉浏览器继续使用缓存（304）。</p></blockquote></li><li><p><code>no-store</code>，浏览器和中间代理服务器都不能缓存资源。</p><blockquote><p>每次访问资源，浏览器都必须请求服务器，并且，服务器不去检查文件是否变化，而是直接返回完整的资源。</p></blockquote></li><li><code>must-revalidate</code>，可以缓存，但是使用之前必须先向源服务器确认。</li><li><code>proxy-revalidate</code>，要求缓存服务器针对缓存资源向源服务器进行确认。</li><li><code>s-maxage</code>：缓存服务器对资源缓存的最大时间。</li></ul><p><code>Cache-Control</code> 对缓存的控制粒度更细，包括缓存代理服务器的缓存控制。</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><blockquote><p>由服务端决定并告知客户端是否使用缓存。</p></blockquote><p>协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。<br>协商缓存是通过请求头 <code>Last-Modified</code> 或 <code>Etag</code> 来实现的。</p><ul><li><code>Last-Modified</code> 标识的是文档最后修改时间</li><li><code>Etag</code> 则是以文档内容来进行编码的。</li></ul><h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><blockquote><p>响应头，资源最近修改时间，由服务器告诉浏览器。</p></blockquote><p><code>Last-Modified</code> （上次修改时间）主要配合 <code>If-Modified-Since</code> 或者 <code>If-Unmodified-Since</code> 使用， 对比上次修改时间以验证资源是否需要更新</p><p>If-Modified-Since: 请求头</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/4/166de151763c87aa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><ul><li>首次请求资源时，服务器在返回资源的同时，会在 <code>Response Headers</code> 中写入 <code>Last-Modified</code> 首部，表示该资源在服务器上的最后修改时间。</li><li>当再次请求该资源时，会在 <code>Request Headers</code> 中写入 <code>If-Modified-Since</code> 首部，此时的 <code>If-Modified-Since</code> 的值是首次请求资源时所返回的 <code>Last-Modified</code> 的值。</li><li>服务器接收到请求后，会根据 <code>If-Modified-Since</code> 的值判断资源在该日期之后是否发生过变化。</li><li>如果没有，则会返回 <code>304 Not Modified</code>;如果变化了，则会返回变化过后的资源，同时更新 <code>Last-Modified</code> 的值。</li></ul><ol><li><p>资源未更新 network 面板截图<br><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e75620b00e06?w=848&amp;h=520&amp;f=png&amp;s=224745" alt></p></li><li><p>资源发生更新 network 面板截图<br><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e7991fe685a1?w=935&amp;h=484&amp;f=png&amp;s=245226" alt><br>可以看到 <code>Last-Modified</code> 和 <code>If-Modified-Since</code> 标识的时间不一样</p></li></ol><ul><li><code>server.js</code> - demo</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line">http</span><br><span class="line">  .createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'text/javascript'</span>,</span><br><span class="line">      <span class="string">'Conche-Control'</span>: <span class="string">'max-age=2000, public'</span>, <span class="comment">// 缓存时间 2000s；public: 资源允许被中间服务器缓存</span></span><br><span class="line">      <span class="string">'Last-Modified'</span>: <span class="string">'123'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    response.end(<span class="string">"console.log('script loaded')"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(<span class="number">3301</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'http://127.0.0.1:3301'</span>)</span><br></pre></td></tr></table></figure><h3 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h3><blockquote><p>响应头，资源标识，由服务器告诉浏览器。</p></blockquote><p><code>Etag</code> 和 <code>If-None-Match</code> 配合使用， （文件内容对比）对比资源的签名来决定是否使用缓存。</p><ul><li><code>server.js</code> - demo</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line">http</span><br><span class="line">  .createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> etag = request.headers[<span class="string">'if-none-match'</span>]</span><br><span class="line">    <span class="keyword">if</span> (etag === <span class="string">'777'</span>) &#123;</span><br><span class="line">      response.writeHead(<span class="number">304</span>, &#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'text/javascript'</span>,</span><br><span class="line">        <span class="string">'Cache-Control'</span>: <span class="string">'max-age=120, no-cache'</span>, <span class="comment">// 缓存时间 120s；no-cache: 浏览器不做缓存检查</span></span><br><span class="line">        <span class="string">'Last-Modified'</span>: <span class="string">'123'</span>,</span><br><span class="line">        Etag: <span class="string">'777'</span></span><br><span class="line">      &#125;)</span><br><span class="line">      response.end()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// etag change</span></span><br><span class="line">      response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'text/javascript'</span>,</span><br><span class="line">        <span class="string">'Conche-Control'</span>: <span class="string">'max-age=120, no-cache'</span>, <span class="comment">// 缓存时间 120s；no-cache: 浏览器不做缓存检查</span></span><br><span class="line">        <span class="string">'Last-Modified'</span>: <span class="string">'123'</span>,</span><br><span class="line">        Etag: <span class="string">'777'</span></span><br><span class="line">      &#125;)</span><br><span class="line">      response.end(<span class="string">"console.log('script loaded')"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .listen(<span class="number">3301</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'http://127.0.0.1:3301'</span>)</span><br></pre></td></tr></table></figure><h2 id="总结与缓存方案"><a href="#总结与缓存方案" class="headerlink" title="总结与缓存方案"></a>总结与缓存方案</h2><p><img src="https://user-gold-cdn.xitu.io/2018/8/13/16531214dfa218be?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><ol><li>服务器和浏览器约定资源过期时间 <code>Cache-Control: expires=xxx</code></li><li>服务器告诉浏览器资源上次修改时间 <code>Last-Modified</code></li><li>增加相对时间的控制 <code>Cache-Control: max-age=xxx</code></li><li>增加文件内容对比，引入<code>Etag</code></li></ol><p>缓存优先级</p><blockquote><p><code>Pragma</code> &gt; <code>Cache-Control</code> &gt; <code>Expires</code> &gt; <code>ETag</code> &gt; <code>Last-Modified</code></p></blockquote><p>参考与相关链接：</p><ul><li><a href="https://juejin.im/post/5bdeabbbe51d4505466cd741#heading-25" target="_blank" rel="noopener">浅谈 HTTP 缓存</a></li><li><a href="https://juejin.im/post/5b3c87386fb9a04f9a5cb037#heading-0" target="_blank" rel="noopener">面试精选之 http 缓存</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缓存实现的步骤&quot;&gt;&lt;a href=&quot;#缓存实现的步骤&quot; class=&quot;headerlink&quot; title=&quot;缓存实现的步骤&quot;&gt;&lt;/a&gt;缓存实现的步骤&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;首先是当用户请求资源时，会判断是否有缓存，如果没有，则会向原服务器请求资源。&lt;/li&gt;
&lt;li&gt;如果有缓存，则会进入强缓存的范畴，判断缓存是否新鲜&lt;ul&gt;
&lt;li&gt;如果缓存新鲜，则会直接返回缓存副本给客户端。&lt;/li&gt;
&lt;li&gt;如果缓存不新鲜了，则表示强缓存失败，将会进入到&lt;strong&gt;协商缓存&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;协商缓存将判断是否存在 &lt;code&gt;Etag&lt;/code&gt; 和 &lt;code&gt;Last-Modified&lt;/code&gt; 首部&lt;ul&gt;
&lt;li&gt;如果未发生变化，则表示命中了协商缓存，会重定向到缓存副本，将资源返回给客户端&lt;/li&gt;
&lt;li&gt;否则的话表示协商缓存未命中，服务器会返回新的资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/11/4/166de9f3ae4b1f20?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;强缓存&quot;&gt;&lt;a href=&quot;#强缓存&quot; class=&quot;headerlink&quot; title=&quot;强缓存&quot;&gt;&lt;/a&gt;强缓存&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;服务端告知客户端缓存时间后，由客户端判断并决定是否使用缓存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;强缓存是通过 &lt;code&gt;Expires&lt;/code&gt; 首部或 &lt;code&gt;Cache-Control: max-age&lt;/code&gt; 来实现的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Expires&lt;/code&gt;: 响应头，代表该资源的过期时间。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Cache-Control&lt;/code&gt;: 请求/响应头，缓存控制字段，精确控制缓存策略。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="HTTP" scheme="https://weifo.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="https://weifo.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>ES6 - Map 和 Set</title>
    <link href="https://weifo.github.io/2020/01/21/es6-map&amp;set/"/>
    <id>https://weifo.github.io/2020/01/21/es6-map&amp;set/</id>
    <published>2020-01-21T01:07:08.000Z</published>
    <updated>2020-03-15T13:17:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Map-和-Set"><a href="#Map-和-Set" class="headerlink" title="Map 和 Set"></a>Map 和 Set</h2><p>JavaScript 的默认对象表示方式<code>{}</code>可以视为其他语言中的<code>Map</code>或<code>Dictionary</code>的数据结构，即一组键值对。</p><p>但是 JavaScript 的对象有个小问题，就是键必须是字符串。但实际上 Number 或者其他数据类型作为键也是非常合理的。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><code>Map</code>是一组键值对的结构，具有极快的查找速度。</p><p>举个例子，假设要根据同学的名字查找对应的成绩，如果用<code>Array</code>实现，需要两个<code>Array</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line"><span class="keyword">var</span> scores = [<span class="number">95</span>, <span class="number">75</span>, <span class="number">85</span>]</span><br></pre></td></tr></table></figure><p>给定一个名字，要查找对应的成绩，就先要在 names 中找到对应的位置，再从 scores 取出对应的成绩，Array 越长，耗时越长。</p><p>如果用 Map 实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用 JavaScript 写一个 Map 如下：</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'Michael'</span>, <span class="number">95</span>], [<span class="string">'Bob'</span>, <span class="number">75</span>], [<span class="string">'Tracy'</span>, <span class="number">85</span>]])</span><br><span class="line">m.get(<span class="string">'Michael'</span>) <span class="comment">// 95</span></span><br></pre></td></tr></table></figure><p>初始化<code>Map</code>需要一个二维数组，或者直接初始化一个空<code>Map</code>。<code>Map</code>具有以下方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>() <span class="comment">// 空Map</span></span><br><span class="line">m.set(<span class="string">'Adam'</span>, <span class="number">67</span>) <span class="comment">// 添加新的key-value</span></span><br><span class="line">m.set(<span class="string">'Bob'</span>, <span class="number">59</span>)</span><br><span class="line">m.has(<span class="string">'Adam'</span>) <span class="comment">// 是否存在key 'Adam': true</span></span><br><span class="line">m.get(<span class="string">'Adam'</span>) <span class="comment">// 67</span></span><br><span class="line">m.delete(<span class="string">'Adam'</span>) <span class="comment">// 删除key 'Adam'</span></span><br><span class="line">m.get(<span class="string">'Adam'</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>由于一个 key 只能对应一个 value，所以，多次对一个 key 放入 value，后面的值会把前面的值冲掉：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">m.set(<span class="string">'Adam'</span>, <span class="number">67</span>)</span><br><span class="line">m.set(<span class="string">'Adam'</span>, <span class="number">88</span>)</span><br><span class="line">m.get(<span class="string">'Adam'</span>) <span class="comment">// 88</span></span><br></pre></td></tr></table></figure><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><code>Set</code>和<code>Map</code>类似，也是一组 key 的集合，但不存储 value。由于 key 不能重复，所以，<strong>在<code>Set</code>中，没有重复的 key。</strong></p><p>要创建一个<code>Set</code>，需要提供一个<code>Array</code>作为输入，或者直接创建一个空<code>Set</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>() <span class="comment">// 空Set</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 含1, 2, 3</span></span><br></pre></td></tr></table></figure><p>重复元素在<code>Set</code>中自动被过滤：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">'3'</span>])</span><br><span class="line">s <span class="comment">// Set &#123;1, 2, 3, "3"&#125;</span></span><br></pre></td></tr></table></figure><p>注意数字<code>3</code>和字符串<code>&#39;3&#39;</code>是不同的元素。</p><p>通过<code>add(key)</code>方法可以添加元素到<code>Set</code>中，可以重复添加，但不会有效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.add(<span class="number">4</span>)</span><br><span class="line">s <span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line">s.add(<span class="number">4</span>)</span><br><span class="line">s <span class="comment">// 仍然是 Set &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure><p>通过<code>delete(key)</code>方法可以删除元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">s <span class="comment">// Set &#123;1, 2, 3&#125;</span></span><br><span class="line">s.delete(<span class="number">3</span>)</span><br><span class="line">s <span class="comment">// Set &#123;1, 2&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Map-和-Set&quot;&gt;&lt;a href=&quot;#Map-和-Set&quot; class=&quot;headerlink&quot; title=&quot;Map 和 Set&quot;&gt;&lt;/a&gt;Map 和 Set&lt;/h2&gt;&lt;p&gt;JavaScript 的默认对象表示方式&lt;code&gt;{}&lt;/code&gt;可以视为其他语言中的&lt;code&gt;Map&lt;/code&gt;或&lt;code&gt;Dictionary&lt;/code&gt;的数据结构，即一组键值对。&lt;/p&gt;
&lt;p&gt;但是 JavaScript 的对象有个小问题，就是键必须是字符串。但实际上 Number 或者其他数据类型作为键也是非常合理的。&lt;/p&gt;
&lt;h3 id=&quot;Map&quot;&gt;&lt;a href=&quot;#Map&quot; class=&quot;headerlink&quot; title=&quot;Map&quot;&gt;&lt;/a&gt;Map&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Map&lt;/code&gt;是一组键值对的结构，具有极快的查找速度。&lt;/p&gt;
&lt;p&gt;举个例子，假设要根据同学的名字查找对应的成绩，如果用&lt;code&gt;Array&lt;/code&gt;实现，需要两个&lt;code&gt;Array&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; names = [&lt;span class=&quot;string&quot;&gt;&#39;Michael&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;Bob&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;Tracy&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; scores = [&lt;span class=&quot;number&quot;&gt;95&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;75&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;85&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;给定一个名字，要查找对应的成绩，就先要在 names 中找到对应的位置，再从 scores 取出对应的成绩，Array 越长，耗时越长。&lt;/p&gt;
&lt;p&gt;如果用 Map 实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用 JavaScript 写一个 Map 如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://weifo.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="https://weifo.github.io/tags/Javascript/"/>
    
      <category term="ES6" scheme="https://weifo.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 - generator</title>
    <link href="https://weifo.github.io/2020/01/20/es6-generator/"/>
    <id>https://weifo.github.io/2020/01/20/es6-generator/</id>
    <published>2020-01-20T03:24:35.000Z</published>
    <updated>2020-03-15T13:17:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote><p><code>Generator</code> 函数是 ES6 提供的一种异步编程解决方案。语法上，首先可以把它理解成，<code>Generator</code> 函数是一个状态机，封装了多个内部状态。</p></blockquote><p>形式上，<code>Generator</code> 函数是一个普通函数，但是有两个特征。一是，<code>function</code> 关键字与函数名之间有一个星号；二是，函数体内部使用 <code>yield</code> 表达式，定义不同的内部状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数有三个状态：hello，world 和 return 语句（结束执行）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有调用 next() 函数才会执行</span></span><br><span class="line"></span><br><span class="line">hw.next() <span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line">hw.next() <span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line">hw.next() <span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line">hw.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">hw <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// yield表达式如果用在另一个表达式之中，必须放在圆括号里面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + <span class="keyword">yield</span>) <span class="comment">// SyntaxError</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + <span class="keyword">yield</span> <span class="number">123</span>) <span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + (<span class="keyword">yield</span>)) <span class="comment">// OK</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + (<span class="keyword">yield</span> <span class="number">123</span>)) <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Generator</code> 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号<br>不同的是，调用 <code>Generator</code> 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象</p><p>总结一下：</p><ul><li>调用 <code>Generator</code> 函数，返回一个遍历器对象，代表 <code>Generator</code> 函数的内部指针。</li><li>以后，每次调用遍历器对象的 next 方法，就会返回一个有着 <code>value</code> 和 <code>done</code> 两个属性的对象。<ul><li><code>value</code> 属性表示当前的内部状态的值，是 yield 表达式后面那个表达式的值</li><li><code>done</code> 属性是一个布尔值，表示是否遍历结束。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Generator&lt;/code&gt; 函数是 ES6 提供的一种异步编程解决方案。语法上，
      
    
    </summary>
    
      <category term="Javascript" scheme="https://weifo.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="https://weifo.github.io/tags/Javascript/"/>
    
      <category term="ES6" scheme="https://weifo.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 - Class</title>
    <link href="https://weifo.github.io/2020/01/16/es6-class/"/>
    <id>https://weifo.github.io/2020/01/16/es6-class/</id>
    <published>2020-01-16T14:19:09.000Z</published>
    <updated>2020-03-15T13:17:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x</span><br><span class="line">  <span class="keyword">this</span>.y = y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x <span class="comment">// this 代表实例对象</span></span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li><code>constructor</code>: 构造方法，类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。<ul><li>一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。</li></ul></li><li><code>this</code>: 关键对象</li></ul><blockquote><p>定义“类”的方法的时候，前面不需要加上 function 这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p></blockquote><p>ES6 的类，完全可以看作构造函数的另一种写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> Point <span class="comment">// "function" ==&gt; 类的数据类型就是函数</span></span><br><span class="line">Point === Point.prototype.constructor <span class="comment">// true ==&gt; 类本身就指向构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义与使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  doStuff() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'stuff'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Bar() <span class="comment">// new 默认执行Bar类的 constructor 方法，该方法默认返回实例对象 即this</span></span><br><span class="line">b.doStuff() <span class="comment">// "stuff"</span></span><br></pre></td></tr></table></figure><p>构造函数的<code>prototype</code>属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的<code>prototype</code>属性上面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toValue() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;,</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">  toValue() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类的实例上面调用方法，其实就是调用原型上的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B()</span><br><span class="line"></span><br><span class="line">b.constructor === B.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>由于类的方法都定义在<code>prototype</code>对象上面，所以类的新方法可以添加在<code>prototype</code>对象上面。Object.assign 方法可以很方便地一次向类添加多个方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(Point.prototype, &#123;</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">  toValue() &#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// prototype对象的constructor属性，直接指向“类”的本身，这与 ES5 的行为是一致的</span></span><br><span class="line">Point.prototype.constructor === Point <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(Point.prototype) <span class="comment">// [] ==&gt; 类的内部所有定义的方法，都是不可枚举的（non-enumerable）这一点与 ES5 的行为不一致</span></span><br></pre></td></tr></table></figure><p>类的属性名，可以采用表达式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> methodName = <span class="string">'getArea'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [methodName]() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的实例对象"><a href="#类的实例对象" class="headerlink" title="类的实例对象"></a>类的实例对象</h2><p>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">point.toString() <span class="comment">// (2, 3)</span></span><br><span class="line"></span><br><span class="line">point.hasOwnProperty(<span class="string">'x'</span>) <span class="comment">// true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">'y'</span>) <span class="comment">// true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">'toString'</span>) <span class="comment">// false</span></span><br><span class="line">point.__proto__.hasOwnProperty(<span class="string">'toString'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>hasOwnProperty</code>: 查找对象原型上是否有某属性 （上面代码表示 <code>toString</code> 保存在<code>Point</code>类中，point 是通过原型链获得 <code>toString</code> 方法）</p><h2 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h2><p>与函数一样，类也可以使用表达式的形式定义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">  getClassName() &#123;</span><br><span class="line">    <span class="keyword">return</span> Me.name <span class="comment">// 内部可以使用到这个类Me</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类</span></span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass()</span><br><span class="line">inst.getClassName() <span class="comment">// Me</span></span><br><span class="line">Me.name <span class="comment">// ReferenceError: Me is not defined</span></span><br></pre></td></tr></table></figure><p>如果类的内部没用到的话，可以省略<code>Me</code>，也就是可以写成下面的形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用 Class 表达式，可以写出立即执行的 Class。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="string">'张三'</span>)</span><br><span class="line"></span><br><span class="line">person.sayName() <span class="comment">// "张三"</span></span><br></pre></td></tr></table></figure><h2 id="私有方法和私有属性"><a href="#私有方法和私有属性" class="headerlink" title="私有方法和私有属性"></a>私有方法和私有属性</h2><p>私有方法是常见需求，但 <code>ES6</code> 不提供，只能通过变通方法模拟实现。</p><p>在命名上加以区别:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lass Widget &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    <span class="keyword">this</span>._bar(baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  _bar(baz) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.snaf = baz;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不保险的，在类的外部，还是可以调用到这个方法</span></span><br></pre></td></tr></table></figure><p>将私有方法移出模块，因为模块内部的所有方法都是对外可见的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  foo(baz) &#123;</span><br><span class="line">    bar.call(<span class="keyword">this</span>, baz)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">baz</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span>.snaf = baz)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，foo 是公有方法，内部调用了 bar.call(this, baz)。这使得 bar 实际上成为了当前模块的私有方法。</p><p>利用<code>Symbol</code>值的唯一性，将私有方法的名字命名为一个<code>Symbol</code>值:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">onst bar = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"><span class="keyword">const</span> snaf = <span class="built_in">Symbol</span>(<span class="string">'snaf'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">myClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  foo(baz) &#123;</span><br><span class="line">    <span class="keyword">this</span>[bar](baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  [bar](baz) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[snaf] = baz;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，bar 和 snaf 都是 Symbol 值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。</p><h2 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h2><p>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  printName(name = <span class="string">'there'</span>) &#123;</span><br><span class="line">    <span class="comment">// this 默认指向 Logger</span></span><br><span class="line">    <span class="keyword">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  print(text) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Logger()</span><br><span class="line"><span class="keyword">const</span> &#123; printName &#125; = logger</span><br><span class="line">printName() <span class="comment">// TypeError: Cannot read property 'print' of undefined</span></span><br><span class="line"><span class="comment">// this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。</span></span><br></pre></td></tr></table></figure><p>解决办法</p><ul><li>在构造方法中绑定<code>this</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.printName = <span class="keyword">this</span>.printName.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>箭头函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.printName = <span class="function">(<span class="params">name = <span class="string">'there'</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>Proxy</code>，获取方法的时候，自动绑定<code>this</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">unction selfish (target) &#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">  <span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span> (target, key) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="built_in">Reflect</span>.get(target, key);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!cache.has(value)) &#123;</span><br><span class="line">        cache.set(value, value.bind(target));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cache.get(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = selfish(<span class="keyword">new</span> Logger());</span><br></pre></td></tr></table></figure><h2 id="getter-setter"><a href="#getter-setter" class="headerlink" title="getter setter"></a>getter setter</h2><p>与 ES5 一样，在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> prop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'getter'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> prop(value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setter: '</span> + value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass()</span><br><span class="line"></span><br><span class="line">inst.prop = <span class="number">123</span></span><br><span class="line"><span class="comment">// setter: 123</span></span><br><span class="line"></span><br><span class="line">inst.prop</span><br><span class="line"><span class="comment">// 'getter'</span></span><br></pre></td></tr></table></figure><p>存值函数和取值函数是设置在属性的 Descriptor 对象上的</p><h2 id="Class-的-Generator-方法"><a href="#Class-的-Generator-方法" class="headerlink" title="Class 的 Generator 方法"></a>Class 的 Generator 方法</h2><p>todo // 对 Generator 不熟悉，待下次理解了在写</p><h2 id="Class-的静态方法"><a href="#Class-的静态方法" class="headerlink" title="Class 的静态方法"></a>Class 的静态方法</h2><p>静态方法：不会被实例继承，而是直接通过类来调用。</p><blockquote><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() <span class="comment">// 'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo()</span><br><span class="line">foo.classMethod()</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> bar() &#123;</span><br><span class="line">    <span class="keyword">this</span>.baz()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> baz() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  baz() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'world'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.bar() <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p><strong>父类的静态方法，可以被子类继承。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod() <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure><p><strong>静态方法也是可以从<code>super</code>对象上调用的</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.classMethod() + <span class="string">', too'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod() <span class="comment">// "hello, too"</span></span><br></pre></td></tr></table></figure><h2 id="Class-的静态属性和实例属性"><a href="#Class-的静态属性和实例属性" class="headerlink" title="Class 的静态属性和实例属性"></a>Class 的静态属性和实例属性</h2><p>静态属性：<code>Class</code> 本身的属性，即<code>Class.propName</code>，而不是定义在实例对象（<code>this</code>）上的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop = <span class="number">1</span></span><br><span class="line">Foo.prop <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><blockquote><p>ES6 明确规定，Class 内部只有静态方法，没有静态属性</p></blockquote><p>写法无效如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两种写法都无效</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 写法一</span></span><br><span class="line">  prop: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写法二</span></span><br><span class="line">  <span class="keyword">static</span> prop: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>类的实例属性<br>类的实例属性可以用等式，写入类的定义之中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  myProp = <span class="number">42</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.myProp) <span class="comment">// 42</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的静态属性<br>类的静态属性只要在上面的实例属性写法前面，加上<code>static</code>关键字就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> myStaticProp = <span class="number">42</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(MyClass.myStaticProp) <span class="comment">// 42</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> MyClass() <span class="comment">// p 中实例属性没有 myStaticProp</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Point&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x, y&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x = x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.y = y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Point.prototype.toString = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;(&#39;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x + &lt;span class=&quot;string&quot;&gt;&#39;, &#39;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.y + &lt;span class=&quot;string&quot;&gt;&#39;)&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; p = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Point(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过&lt;code&gt;class&lt;/code&gt;关键字，可以定义类。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//定义类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Point&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(x, y) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x = x &lt;span class=&quot;comment&quot;&gt;// this 代表实例对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.y = y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  toString() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;(&#39;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x + &lt;span class=&quot;string&quot;&gt;&#39;, &#39;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.y + &lt;span class=&quot;string&quot;&gt;&#39;)&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://weifo.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="https://weifo.github.io/tags/Javascript/"/>
    
      <category term="ES6" scheme="https://weifo.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 - async await</title>
    <link href="https://weifo.github.io/2020/01/12/es6-async&amp;await/"/>
    <id>https://weifo.github.io/2020/01/12/es6-async&amp;await/</id>
    <published>2020-01-12T04:02:26.000Z</published>
    <updated>2020-03-15T13:17:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h2><blockquote><p><code>async</code> 函数是什么？一句话，它就是 <code>Generator</code> 函数的语法糖。<code>async</code> 函数就是将 <code>Generator</code> 函数的星号（*）替换成 <code>async</code>，将 <code>yield</code> 替换成 <code>await</code>，仅此而已</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'something'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Hello async'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> v1 = <span class="keyword">await</span> getSomething() <span class="comment">// 普通值</span></span><br><span class="line">  <span class="keyword">const</span> v2 = <span class="keyword">await</span> testAsync() <span class="comment">// Promise对象</span></span><br><span class="line">  <span class="built_in">console</span>.log(v1, v2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'调用该函数时，会立即返回一个Promise对象'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="async-函数的实现原理"><a href="#async-函数的实现原理" class="headerlink" title="async 函数的实现原理"></a>async 函数的实现原理</h2><p><code>async</code> 函数的实现原理，就是将 <code>Generator</code> 函数和自动执行器，包装在一个函数里。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的 <code>async</code> 函数都可以写成上面的第二种形式，其中的 <code>spawn</code> 函数就是自动执行器。<br>下面给出 <code>spawn</code> 函数的实现，基本就是前文自动执行器的翻版。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">genF</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> gen = genF()</span><br><span class="line">    <span class="keyword">let</span> next</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">nextF</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> next</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        next = nextF()</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (next.done) <span class="keyword">return</span> resolve(next.value)</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(next.value).then(</span><br><span class="line">        v =&gt; step(<span class="function"><span class="params">()</span> =&gt;</span> gen.next(v)), </span><br><span class="line">        e =&gt; gen.throw(e)</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    step(<span class="function"><span class="params">()</span> =&gt;</span> gen.next(<span class="literal">undefined</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;async-函数&quot;&gt;&lt;a href=&quot;#async-函数&quot; class=&quot;headerlink&quot; title=&quot;async 函数&quot;&gt;&lt;/a&gt;async 函数&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt; 函数是什么？一句话，它就是 &lt;code&gt;Generator&lt;/code&gt; 函数的语法糖。&lt;code&gt;async&lt;/code&gt; 函数就是将 &lt;code&gt;Generator&lt;/code&gt; 函数的星号（*）替换成 &lt;code&gt;async&lt;/code&gt;，将 &lt;code&gt;yield&lt;/code&gt; 替换成 &lt;code&gt;await&lt;/code&gt;，仅此而已&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getSomething&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;something&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testAsync&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;Hello async&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; v1 = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; getSomething() &lt;span class=&quot;comment&quot;&gt;// 普通值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; v2 = &lt;span class=&quot;keyword&quot;&gt;await&lt;/span&gt; testAsync() &lt;span class=&quot;comment&quot;&gt;// Promise对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(v1, v2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;test()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;调用该函数时，会立即返回一个Promise对象&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .catch(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;e&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://weifo.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="https://weifo.github.io/tags/Javascript/"/>
    
      <category term="ES6" scheme="https://weifo.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Vue 生命周期</title>
    <link href="https://weifo.github.io/2020/01/06/vue-life-hooks/"/>
    <id>https://weifo.github.io/2020/01/06/vue-life-hooks/</id>
    <published>2020-01-06T02:30:09.000Z</published>
    <updated>2020-03-15T13:18:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h3><p><img src="https://weifo-blog.oss-cn-shanghai.aliyuncs.com/blog/vue-hooks.jpg?Expires=1584026727&amp;OSSAccessKeyId=TMP.3KiQHdpwZF97ctjftLMwdwGNk2VSmAh5U5sdi3TrDEqQErFtr7mpZgRU3m91HzzGK7xFLJqDd4MSPtyy1LrCqYWBrScgF4&amp;Signature=Sfn6HHcFvvQm9m%2BKG86w68hQa5w%3D" alt="default"></p><p>解释：</p><ul><li>created阶段的ajax请求与mounted请求的区别：前者页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态</li><li>mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 <a href="https://cn.vuejs.org/v2/api/#vm-nextTick" target="_blank" rel="noopener">vm.$nextTick</a></li></ul><h3 id="单个组件生命周期"><a href="#单个组件生命周期" class="headerlink" title="单个组件生命周期"></a>单个组件生命周期</h3> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>单组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"dataVar += 1"</span>&gt;</span>更新 &#123;&#123;dataVar&#125;&#125;<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">"handleDestroy"</span>&gt;</span>销毁<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"> <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line">            dataVar: 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.compName = <span class="string">'single'</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`--<span class="subst">$&#123;<span class="keyword">this</span>.compName&#125;</span>--beforeCreate`</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`--<span class="subst">$&#123;<span class="keyword">this</span>.compName&#125;</span>--created`</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    beforeMount() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`--<span class="subst">$&#123;<span class="keyword">this</span>.compName&#125;</span>--beforeMount`</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`--<span class="subst">$&#123;<span class="keyword">this</span>.compName&#125;</span>--mounted`</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    beforeUpdate() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`--<span class="subst">$&#123;<span class="keyword">this</span>.compName&#125;</span>--beforeUpdate`</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    updated() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`--<span class="subst">$&#123;<span class="keyword">this</span>.compName&#125;</span>--updated`</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`--<span class="subst">$&#123;<span class="keyword">this</span>.compName&#125;</span>--beforeDestroy`</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`--<span class="subst">$&#123;<span class="keyword">this</span>.compName&#125;</span>--destroyed`</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        handleDestroy() &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.$destroy()</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>初始化组件时，会执行beforeCreate/Created/beforeMount/mounted四个钩子函数</li><li>当改变data中定义的变量（响应式变量）时，会执行beforeUpdate/updated钩子函数</li><li>当切换组件（当前组件未缓存）时，会执行beforeDestory/destroyed钩子函数</li><li>初始化和销毁时的生命钩子函数均只会执行一次，beforeUpdate/updated可多次执行</li></ul><h3 id="父子组件生命周期"><a href="#父子组件生命周期" class="headerlink" title="父子组件生命周期"></a>父子组件生命周期</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;生命周期钩子函数&quot;&gt;&lt;a href=&quot;#生命周期钩子函数&quot; class=&quot;headerlink&quot; title=&quot;生命周期钩子函数&quot;&gt;&lt;/a&gt;生命周期钩子函数&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://weifo-blog.oss-cn-shanghai.a
      
    
    </summary>
    
      <category term="Javascript" scheme="https://weifo.github.io/categories/Javascript/"/>
    
    
      <category term="Vue" scheme="https://weifo.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Sequelize - 使用 model 查询数据</title>
    <link href="https://weifo.github.io/2020/01/03/copy/"/>
    <id>https://weifo.github.io/2020/01/03/copy/</id>
    <published>2020-01-03T06:56:03.000Z</published>
    <updated>2020-03-15T13:17:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Sequelize</code> 中有两种查询：使用 <code>Model</code>（模型）中的方法查询和使用 <code>sequelize.query()</code> 进行基于 SQL 语句的原始查询。</p><p>下面是事先创建好的数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * <span class="keyword">from</span> users;</span><br><span class="line">+----+----------+------+------+-------+</span><br><span class="line">| id | name     | age  | sex  | score |</span><br><span class="line">+----+----------+------+------+-------+</span><br><span class="line">|  <span class="number">1</span> | guodada0 |   <span class="number">15</span> |    <span class="number">0</span> |    <span class="number">60</span> |</span><br><span class="line">|  <span class="number">2</span> | guodada1 |   <span class="number">16</span> |    <span class="number">1</span> |    <span class="number">80</span> |</span><br><span class="line">|  <span class="number">3</span> | guodada2 |   <span class="number">17</span> |    <span class="number">0</span> |    <span class="number">55</span> |</span><br><span class="line">|  <span class="number">4</span> | guodada3 |   <span class="number">18</span> |    <span class="number">1</span> |    <span class="number">87</span> |</span><br><span class="line">|  <span class="number">5</span> | guodada4 |   <span class="number">19</span> |    <span class="number">0</span> |    <span class="number">73</span> |</span><br><span class="line">|  <span class="number">6</span> | guodada5 |   <span class="number">20</span> |    <span class="number">1</span> |    <span class="number">22</span> |</span><br><span class="line">+----+----------+------+------+-------+</span><br><span class="line"><span class="number">6</span> rows <span class="keyword">in</span> <span class="keyword">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="findAll-搜索数据库中的多个元素"><a href="#findAll-搜索数据库中的多个元素" class="headerlink" title="findAll - 搜索数据库中的多个元素"></a>findAll - 搜索数据库中的多个元素</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> UserModel.findAll() <span class="comment">// result 将是所有 UserModel 实例的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the same as</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> UserModel.all()</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><h3 id="限制字段"><a href="#限制字段" class="headerlink" title="限制字段"></a>限制字段</h3><p>查询时，如果只需要查询模型的部分属性，可以在通过在查询选项中指定 <code>attributes</code> 实现。该选项是一个数组参数，在数组中指定要查询的属性即可，这些要查询的属性就表示要在数据库查询的字段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Model.findAll(&#123;</span><br><span class="line">  attributes: [<span class="string">'foo'</span>, <span class="string">'bar'</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="字段重命名"><a href="#字段重命名" class="headerlink" title="字段重命名"></a>字段重命名</h3><p>查询属性（字段）可以通过传入一个嵌套数据进行重命名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Model.findAll(&#123;</span><br><span class="line">  attributes: [<span class="string">'foo'</span>, [<span class="string">'bar'</span>, <span class="string">'baz'</span>]]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SELECT foo, bar AS baz ...</span></span><br></pre></td></tr></table></figure><p>demo</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> results = <span class="keyword">await</span> UserModel.findAll(&#123;</span><br><span class="line">  attributes: [[<span class="string">'name'</span>, <span class="string">'username'</span>], <span class="string">'age'</span>, <span class="string">'score'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&#123;"username":"guodada0","age":15,"score":60&#125;,&#123;"username":"guodada1","age":16,"score":80&#125; ...]</span></span><br><span class="line">ctx.body = results</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问查询结果 通过 instance.get('xxx')</span></span><br><span class="line"><span class="built_in">console</span>.log(results[<span class="number">0</span>][<span class="string">'username'</span>], results[<span class="number">0</span>].get(<span class="string">'username'</span>)) <span class="comment">// undefind, 'guodada0'</span></span><br></pre></td></tr></table></figure><h3 id="通过-sequelize-fn-方法进行聚合查询"><a href="#通过-sequelize-fn-方法进行聚合查询" class="headerlink" title="通过 sequelize.fn 方法进行聚合查询"></a>通过 sequelize.fn 方法进行聚合查询</h3><h3 id="base-demo"><a href="#base-demo" class="headerlink" title="base demo"></a>base demo</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UserModel = sequelize.define(<span class="string">'user'</span>, &#123;</span><br><span class="line">  name: Sequelize.STRING,</span><br><span class="line">  age: Sequelize.INTEGER,</span><br><span class="line">  sex: Sequelize.INTEGER,</span><br><span class="line">  score: Sequelize.INTEGER</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">sequelize.sync().then(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> results = <span class="keyword">await</span> UserModel.findAll(&#123;</span><br><span class="line">      attributes: [<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'score'</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    results.map(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(user.name, user.age, user.score) <span class="comment">// guodada0 15 60 | guodada1 16 80...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SELECT `name`, `age`, `score` FROM `users` AS `user`;</span></span><br></pre></td></tr></table></figure><h3 id="通过-sequelize-fn-方法进行聚合查询-1"><a href="#通过-sequelize-fn-方法进行聚合查询-1" class="headerlink" title="通过 sequelize.fn 方法进行聚合查询"></a>通过 sequelize.fn 方法进行聚合查询</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Model.findAll(&#123;</span><br><span class="line">  attributes: [[sequelize.fn(<span class="string">'COUNT'</span>, sequelize.col(<span class="string">'hats'</span>)), <span class="string">'no_hats'</span>]]</span><br><span class="line">&#125;) <span class="comment">// SELECT COUNT(hats) AS no_hats ...</span></span><br></pre></td></tr></table></figure><p>在使用聚合函数时，要给聚合字段指定一个别名。如，在上例中我们为聚合函数指定了别名<code>&#39;no_hats&#39;</code>，这样我们就能在查询的回调函数实例中通过 <code>instance.get(&#39;no_hats&#39;)</code>来访问聚合统计的结果。</p><p>demo</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> results = <span class="keyword">await</span> UserModel.findAll(&#123;</span><br><span class="line">  attributes: [[sequelize.fn(<span class="string">'SUM'</span>, sequelize.col(<span class="string">'score'</span>)), <span class="string">'scoreSum'</span>]]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(results[<span class="number">0</span>].get(<span class="string">'scoreSum'</span>)) <span class="comment">// 377</span></span><br></pre></td></tr></table></figure><h3 id="include-exclude"><a href="#include-exclude" class="headerlink" title="include/exclude"></a>include/exclude</h3><p>当需要查询所有字段并对某一字段使用聚合查询时，而只需要以对象的形式传入 <code>attributes</code> 并添加 <code>include</code> 子属性即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拽定全查询字段比较麻烦</span></span><br><span class="line">Model.findAll(&#123;</span><br><span class="line">  attributes: [<span class="string">'id'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>, <span class="string">'quz'</span>, [sequelize.fn(<span class="string">'COUNT'</span>, sequelize.col(<span class="string">'hats'</span>)), <span class="string">'no_hats'</span>]]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样会比较简短，且在你添加/删除属性后不会出错</span></span><br><span class="line">Model.findAll(&#123;</span><br><span class="line">  attributes: &#123; <span class="attr">include</span>: [[sequelize.fn(<span class="string">'COUNT'</span>, sequelize.col(<span class="string">'hats'</span>)), <span class="string">'no_hats'</span>]] &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SELECT id, foo, bar, baz, quz, COUNT(hats) AS no_hats ...</span></span><br></pre></td></tr></table></figure><p>全部查询时，可以通过 <code>exclude</code> 子属性来排除不需要查询的字段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Model.findAll(&#123;</span><br><span class="line">  attributes: &#123; <span class="attr">exclude</span>: [<span class="string">'baz'</span>] &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SELECT id, foo, bar, quz ...</span></span><br></pre></td></tr></table></figure><h3 id="通过-sequelize-fn-方法进行聚合查询-2"><a href="#通过-sequelize-fn-方法进行聚合查询-2" class="headerlink" title="通过 sequelize.fn 方法进行聚合查询"></a>通过 sequelize.fn 方法进行聚合查询</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Sequelize&lt;/code&gt; 中有两种查询：使用 &lt;code&gt;Model&lt;/code&gt;（模型）中的方法查询和使用 &lt;code&gt;sequelize.query()&lt;/code&gt; 进行基于 SQL 语句的原始查询。&lt;/p&gt;
&lt;p&gt;下面是事先创建好的数据：&lt;/p&gt;
      
    
    </summary>
    
      <category term="Sequelize" scheme="https://weifo.github.io/categories/Sequelize/"/>
    
    
      <category term="Sequelize" scheme="https://weifo.github.io/tags/Sequelize/"/>
    
  </entry>
  
  <entry>
    <title>随笔 - 如何用es6+写出优雅的js代码</title>
    <link href="https://weifo.github.io/2019/12/12/%E9%9A%8F%E7%AC%94-%E5%A6%82%E4%BD%95%E7%94%A8es6+%E5%86%99%E5%87%BA%E4%BC%98%E9%9B%85%E7%9A%84js%E4%BB%A3%E7%A0%81/"/>
    <id>https://weifo.github.io/2019/12/12/随笔-如何用es6+写出优雅的js代码/</id>
    <published>2019-12-12T01:59:21.000Z</published>
    <updated>2020-03-15T13:19:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>兼容 IE ？不存在的好吗。</p><p>其实使用新语法配合 <code>babel</code> 的转码，已经可以解决这一些问题了。既然如此，那就多使用新语法去探索一下怎么更好的去写代码吧。</p><p>下面分享个人开发中常用的 js 写法技巧，希望对各位有所帮助。</p><h2 id="使用-let-const"><a href="#使用-let-const" class="headerlink" title="使用 let / const"></a>使用 let / const</h2><p><code>var</code> 命令会发生”变量提升“现象，即变量可以在声明之前使用，值为 <code>undefined</code>。这种现象多多少少是有些奇怪的。</p><p>个人认为，对声明的变量确定后面不会发生更改时，即使性能上没有太大提升差异在，但使用 <code>const</code>, 代码的可读性也会增强很多。</p><ul><li><code>const</code> 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。</li><li><code>let</code> 变量指向的内存地址，保存的只是一个指向实际数据的指针</li></ul><p>补充 <code>const</code> 定义的变量不是数据不可变，而是保存的引用地址不能发生改变。例子如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">age</span>: <span class="number">22</span> &#125;</span><br><span class="line">person.age = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.age) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>详情看 <a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">let 和 const 命令</a></p><a id="more"></a><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p><code>ES6</code> 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（<code>Destructuring</code>）。</p><p>好处就是：解决了访问多层嵌套的对象或数组的命名，减少代码量</p><p>声明多个变量:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [age, name, sex] = [<span class="number">22</span>, <span class="string">'guodada'</span>, <span class="number">1</span>]</span><br><span class="line"><span class="built_in">console</span>.log(age, name, sex) <span class="comment">// 22, guodada, 1</span></span><br></pre></td></tr></table></figure><p>使用在对象中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    firstName: <span class="string">'guo'</span>,</span><br><span class="line">    lastName: <span class="string">'dada'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果我们多处使用 firstName， 那就不必要每个地方都写 obj.name.firstName, 这样极大提升coding效率</span></span><br><span class="line"><span class="keyword">const</span> &#123; firstName, lastName &#125; = obj.name</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> firstName = obj.name.firstName</span><br><span class="line"><span class="keyword">const</span> lastName = obj.name.lastName</span><br></pre></td></tr></table></figure><p>使用在函数中:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在参数中结构赋值，获取参数, 当参数多的使用时候十分方便</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Destructuring</span>(<span class="params">&#123; name, age &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; name, age &#125; <span class="comment">// 相当于 &#123; name: name, age: age &#125; , 可以简写</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> params = &#123; <span class="attr">name</span>: <span class="string">'guodada'</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;</span><br><span class="line">Destructuring(params)</span><br></pre></td></tr></table></figure><p>更多用法见 <a href="http://es6.ruanyifeng.com/#docs/destructuring" target="_blank" rel="noopener">变量的解构赋值</a></p><p>ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; x, y &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">x</span>: x, <span class="attr">y</span>: y &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// Object &#123;x: 1, y: 2&#125;</span></span><br></pre></td></tr></table></figure><h2 id="扩展符的运用"><a href="#扩展符的运用" class="headerlink" title="扩展符的运用"></a>扩展符的运用</h2><p>es6 扩展符有很多用法，他可以使你的代码更加简洁，易懂。这里就举例常用的用法</p><p>在对象中的用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'guodada'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  sex: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制对象。扩展符为浅复制！！！</span></span><br><span class="line"><span class="keyword">const</span> copy = &#123; ...obj &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改对象属性值(生成新对象) 相当于 Object.assgin(&#123;&#125;, obj, &#123; age: 18 &#125;)</span></span><br><span class="line"><span class="keyword">const</span> newObj = &#123; ...obj, <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结合结构赋值</span></span><br><span class="line"><span class="keyword">let</span> &#123; sex, ...z &#125; = obj</span><br><span class="line">z <span class="comment">// &#123; name: 'guodada', age: 22 &#125;</span></span><br></pre></td></tr></table></figure><p>在数组中的用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制数组。扩展符为浅复制！！！</span></span><br><span class="line"><span class="keyword">const</span> newArr = [...arr] <span class="comment">// ...[1, 2, 3] =&gt; 相当于展开数组：1, 2, 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并数组</span></span><br><span class="line"><span class="keyword">const</span> conbineArr = [...arr, ...arr2]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结合求最大值函数</span></span><br><span class="line"><span class="built_in">Math</span>.max(...arr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结合 Set 实现数组去重。注意：json 等对象数组不可用</span></span><br><span class="line">[...new <span class="built_in">Set</span>(arr2)] <span class="comment">// [4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>扩展符的其他用法请自行查资料。</p><h2 id="数组用法"><a href="#数组用法" class="headerlink" title="数组用法"></a>数组用法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr) <span class="comment">// 判断是否为数组</span></span><br><span class="line"></span><br><span class="line">arr.includes(<span class="number">2</span>) <span class="comment">// true 判断数组中是否包含某项</span></span><br><span class="line"></span><br><span class="line">arr.findIndex(<span class="function"><span class="params">d</span> =&gt;</span> d === <span class="number">3</span>) <span class="comment">// 2 找出第一个符合条件的数组成员并返回数组下标, 找不到返回 -1</span></span><br><span class="line"></span><br><span class="line">arr.find(<span class="function"><span class="params">d</span> =&gt;</span> d === <span class="number">3</span>) <span class="comment">// 3 找出第一个符合条件的数组成员并返回, 找不到返回 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// es5 其他还有 filter map forEach 等，这里不做举例。</span></span><br><span class="line">arr.every(<span class="function"><span class="params">d</span> =&gt;</span> d &gt; <span class="number">2</span>) <span class="comment">// false 每一项都满足条件则返回 true</span></span><br><span class="line"></span><br><span class="line">arr.some(<span class="function"><span class="params">d</span> =&gt;</span> d &gt; <span class="number">2</span>) <span class="comment">// true 只要有一项满足条件则返回 true</span></span><br></pre></td></tr></table></figure><p><code>find/findIndex</code> : 找出第一个符合条件的数组成员之后不再匹配，一定程度下优化查找。<br><code>includes</code>: 返回 <code>true/false</code>, 相较于 <code>indexOf</code>, 实用多了</p><ul><li><p><code>flat()</code> : 扁平化数组，常用于将数组转化为一维数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line">arr.flat() <span class="comment">// [1, 2, 3, 4] 扁平化数组, 默认展开一层。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]]</span><br><span class="line"></span><br><span class="line">arr2.flat() <span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br><span class="line">arr2.flat(<span class="number">2</span>) <span class="comment">// [1, 2, 3, 4, 5, 6] flat(3) 也是展开两层...</span></span><br></pre></td></tr></table></figure></li><li><p><code>flatMap()</code>: 在数组执行 <code>map</code> 方法后执行 <code>flat</code>, 用的不多，其实可以写 <code>map</code> 后写 <code>flat</code> 更好懂点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x, x * <span class="number">2</span>]) <span class="comment">//  [ 2, 4, 3, 6, 4, 8 ]</span></span><br><span class="line"><span class="comment">// 1. [2, 3, 4].map(d =&gt; [d, d * 2]) =&gt; [[2, 4], [3, 6], [4, 8]]</span></span><br><span class="line"><span class="comment">// 2. [[2, 4], [3, 6], [4, 8]].flat()</span></span><br></pre></td></tr></table></figure></li></ul><p>补充常用的对象转数组的用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">'guodada'</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">// ['name']</span></span><br><span class="line"><span class="built_in">Object</span>.values(obj) <span class="comment">// ['guodada']</span></span><br><span class="line"><span class="built_in">Object</span>.entries(obj) <span class="comment">// [['name', 'guodada']]</span></span><br></pre></td></tr></table></figure><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>用的挺多的，注意不兼容 <code>IE</code> !</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'guodada'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newStr = <span class="string">`welcome <span class="subst">$&#123;name&#125;</span>`</span> <span class="comment">// welcome guodada</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the same as</span></span><br><span class="line"><span class="keyword">const</span> newStr = <span class="string">'welcome '</span> + name</span><br></pre></td></tr></table></figure><h2 id="使用-async-await"><a href="#使用-async-await" class="headerlink" title="使用 async / await"></a>使用 async / await</h2><p><code>async/await</code> 实际上就是 <code>generator</code> 的语法糖, 主要用来解决异步问题，具体网上很多文章都有介绍，这里就不做多的解释吧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> axios.get(<span class="string">'https://randomuser.me/api/'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  axios.get(<span class="string">'https://randomuser.me/api/'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// axios 也是 promise 对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结合try/catch</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> axios.get(<span class="string">'https://randomuser.me/api/'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps 虽然好用，但是有时候适用场景不好，比如我们在拉取列表和用户信息需要同时进行时，<code>await</code> 后才执行下一条语句，这不是我们希望看到的。解决方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结合 Promise.all</span></span><br><span class="line"><span class="keyword">await</span> <span class="built_in">Promise</span>.all([anAsyncCall(), thisIsAlsoAsync(), oneMore()])</span><br></pre></td></tr></table></figure><p>传送门：<a href="http://es6.ruanyifeng.com/#docs/async" target="_blank" rel="noopener">async 函数</a></p><h2 id="利用-class-封装代码"><a href="#利用-class-封装代码" class="headerlink" title="利用 class 封装代码"></a>利用 class 封装代码</h2><p>主要是抽离代码逻辑，使得代复用性加强。同时，<code>class</code> 的形式会让结构变得更加清晰，譬如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@func <span class="variable">defaultLimit</span></span> - 默认表单输入限制条件, value 为空时返回 true</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> <span class="variable">type</span></span> - 代表表单类型的节点！</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">value</span></span> - 需要被验证的值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="variable">Boolean</span></span></span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 根据 type 属性对输出进行验证</span></span><br><span class="line"><span class="comment">   * 1 0≤x≤50 整数</span></span><br><span class="line"><span class="comment">   * 2 -1000≤x≤2000 整数</span></span><br><span class="line"><span class="comment">   * 3 1≤x 整数</span></span><br><span class="line"><span class="comment">   * 4 0≤x≤10</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> defaultLimit(type, value) &#123;</span><br><span class="line">    <span class="keyword">const</span> typeLimitMap = &#123;</span><br><span class="line">      <span class="number">1</span>: <span class="regexp">/^(\d|[1-4]\d|50)$/g</span>,</span><br><span class="line">      <span class="number">2</span>: <span class="regexp">/^-?(\d&#123;1,3&#125;|1000)$|^(-|1\d&#123;3&#125;|2000)$/</span>,</span><br><span class="line">      <span class="number">3</span>: <span class="regexp">/^[1-9]\d*$/</span>,</span><br><span class="line">      <span class="number">4</span>: <span class="function"><span class="params">value</span> =&gt;</span> value &lt;= <span class="number">10</span> &amp;&amp; value &gt;= <span class="number">0</span> <span class="comment">// 0≤ x ≤ 10 可以为小数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!typeLimitMap[type] || !value) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> typeLimitMap[type] === <span class="string">'function'</span>) <span class="keyword">return</span> typeLimitMap[type](value)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> typeLimitMap[type].test(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@func <span class="variable">translateLimit</span></span> - 转换操作符</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">operator</span></span> - 运算符</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">value</span></span> - 被匹配的值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">compareValue</span></span> - 匹配的值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="variable">Boolean</span></span></span></span><br><span class="line"><span class="comment">   * 'eq': '='</span></span><br><span class="line"><span class="comment">   * 'ne': '≠'</span></span><br><span class="line"><span class="comment">   * 'gt': '&gt;'</span></span><br><span class="line"><span class="comment">   * 'lt': '&lt;'</span></span><br><span class="line"><span class="comment">   * 'ge': '≥'</span></span><br><span class="line"><span class="comment">   * 'le': '≤'</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> translateLimit(operator, value, compareValue) &#123;</span><br><span class="line">    <span class="keyword">const</span> type = &#123;</span><br><span class="line">      eq: value === compareValue,</span><br><span class="line">      ne: value !== compareValue,</span><br><span class="line">      gt: value &gt; compareValue,</span><br><span class="line">      lt: value &lt; compareValue,</span><br><span class="line">      ge: value &gt;= compareValue,</span><br><span class="line">      le: value &lt;= compareValue</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Object</span>.keys(type).includes(operator) || !value || value === <span class="string">'-'</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> type[operator]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> MyForm</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MyForm <span class="keyword">from</span> <span class="string">'./MyForm'</span></span><br><span class="line"></span><br><span class="line">MyForm.defaultLimit(<span class="number">1</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><ul><li><code>static</code> ：静态属性，类可以直接调用</li><li><code>constructor</code> : 实例化类的时候调用，即 <code>new MyForm()</code>, 这里没用到</li></ul><p>更多知识请阅 <a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">Class 的基本语法</a></p><h2 id="优化-if-else-语句"><a href="#优化-if-else-语句" class="headerlink" title="优化 if/else 语句"></a>优化 if/else 语句</h2><blockquote><p>当逻辑或<code>||</code>时，找到为 <code>true</code> 的分项就停止处理，并返回该分项的值，否则执行完，并返回最后分项的值。</p><p>当逻辑与<code>&amp;&amp;</code>时，找到为 <code>false</code> 的分项就停止处理，并返回该分项的值。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">0</span> || <span class="literal">null</span> || <span class="number">3</span> || <span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">3</span> &amp;&amp; <span class="number">4</span> &amp;&amp; <span class="literal">null</span> &amp;&amp; <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>减少 <code>if / else</code>地狱般的调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [age, name, sex] = [<span class="number">22</span>, <span class="string">'guodada'</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (age &gt; <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">'guodada'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'all right'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 &amp;&amp;</span></span><br><span class="line"><span class="keyword">if</span> (age &gt; <span class="number">10</span> &amp;&amp; name === <span class="string">'guodada'</span> &amp;&amp; sex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'all right'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者(太长了不推荐)</span></span><br><span class="line">age &gt; <span class="number">10</span> &amp;&amp; name === <span class="string">'guodada'</span> &amp;&amp; sex &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">console</span>.log(<span class="string">'all right'</span>)</span><br></pre></td></tr></table></figure><p>提一下 <code>react</code> 的坑点, 在 <code>render</code> 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = []</span><br><span class="line">  <span class="keyword">return</span> arr.length &amp;&amp; <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 渲染出 0 ！</span></span><br><span class="line"><span class="comment">// Boolean / undefind / null / NaN 等才不会渲染。我们可以使用 !! 强制转化为 boolean 解决这个问题</span></span><br><span class="line"><span class="keyword">return</span> !!arr.length &amp;&amp; <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 &amp;&amp; 控制组件的渲染</span></span><br><span class="line"><span class="keyword">this</span>.state.visible &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Modal</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><p>使用 <code>Array.includes</code> 来处理多重条件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ages = [<span class="number">18</span>, <span class="number">20</span>, <span class="number">12</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (age === <span class="number">18</span> || age === <span class="number">12</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'match'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// better</span></span><br><span class="line"><span class="keyword">if</span> ([<span class="number">18</span>, <span class="number">12</span>].includes(age)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'match'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是较少的判断逻辑则可以使用三元运算符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">22</span></span><br><span class="line"><span class="keyword">const</span> isAdult = age &gt;= <span class="number">18</span> ? <span class="literal">true</span> : <span class="literal">false</span> <span class="comment">// 这里可以简写为 const isAdult = age &gt; 18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> type = age &gt;= <span class="number">18</span> ? <span class="string">'adult'</span> : <span class="string">'child'</span></span><br></pre></td></tr></table></figure><h2 id="优化-switch-case-语句"><a href="#优化-switch-case-语句" class="headerlink" title="优化 switch/case 语句"></a>优化 switch/case 语句</h2><p><code>switch/case</code> 比 <code>if/else</code> 代码结构好点，但也和它一样有时十分冗长。</p><p>这里以自己实际项目中代码举例：<br>有时我们可能需要对不同类型的字段进行不一样的正则验证，防止用户错误地输入。譬如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [type, value] = [<span class="number">1</span>, <span class="string">'20'</span>]</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 type 属性对输出进行验证</span></span><br><span class="line"><span class="comment"> * 1 0≤x≤50 整数</span></span><br><span class="line"><span class="comment"> * 2 -1000≤x≤2000 整数</span></span><br><span class="line"><span class="comment"> * 3 1≤x 整数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">type, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^(\d|[1-4]\d|50)$/</span>.test(value)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^-?(\d&#123;1,3&#125;|1000)$|^(-|1\d&#123;3&#125;|2000)$/</span>.test(value)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^[1-9]\d*$/</span>.test(value)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func1(type, value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 switch/case</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params">type, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/^(\d|[1-4]\d|50)$/</span>.test(value)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/^-?(\d&#123;1,3&#125;|1000)$|^(-|1\d&#123;3&#125;|2000)$/</span>.test(value)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/^[1-9]\d*$/</span>.test(value)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func2(type, value)</span><br></pre></td></tr></table></figure><p>我们如何巧妙的解决这个代码冗长的问题呢，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func3</span>(<span class="params">type, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> limitMap = &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="regexp">/^(\d|[1-4]\d|50)$/g</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="regexp">/^-?(\d&#123;1,3&#125;|1000)$|^(-|1\d&#123;3&#125;|2000)$/</span>,</span><br><span class="line">    <span class="number">3</span>: <span class="regexp">/^[1-9]\d*$/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> limitMap[type].test(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用对象去匹配属性值，可以减少你的代码量，也使你的代码看起来更加简洁。你也可以使用 <code>Map</code> 对象去匹配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func4</span>(<span class="params">type, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mapArr = [[<span class="number">1</span>, /^(\d|[<span class="number">1</span><span class="number">-4</span>]\d|<span class="number">50</span>)$/g], [<span class="number">2</span>, /^-?(\d&#123;<span class="number">1</span>,<span class="number">3</span>&#125;|<span class="number">1000</span>)$|^(-|<span class="number">1</span>\d&#123;<span class="number">3</span>&#125;|<span class="number">2000</span>)$/], [<span class="number">3</span>, /^[<span class="number">1</span><span class="number">-9</span>]\d*$/]]</span><br><span class="line">  <span class="keyword">const</span> limitMap = <span class="keyword">new</span> <span class="built_in">Map</span>(mapArr)</span><br><span class="line">  <span class="keyword">return</span> limitMap.get(type).test(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Map</code> 是一种键值对的数据结构对象，它的匹配更加严格。它会区分开你传递的是字符串还是数字，譬如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">limitMap.get(<span class="number">1</span>) <span class="comment">// /^(\d|[1-4]\d|50)$/g</span></span><br><span class="line">limitMap.get(<span class="string">'1'</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>更多详见 <a href="http://es6.ruanyifeng.com/#docs/set-map" target="_blank" rel="noopener">Set 和 Map 数据结构</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>函数参数默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">name, age = <span class="number">22</span></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  age = age || <span class="number">22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>===</code> 代替 <code>==</code>。其实大家都懂这个的。。。</p></li><li>箭头函数，es6 最常用的语法。</li><li>return boolean<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> a === <span class="number">1</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="comment">// 多此一举了，其实就等于</span></span><br><span class="line"><span class="keyword">return</span> a === <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><p>敬请各位补充。交流才能进步，相视一笑，嘿嘿。</p><ul><li><a href="https://github.com/gershonv/my-code-store" target="_blank" rel="noopener">github</a> - star 一下人生更美好</li><li><a href="https://gershonv.github.io/categories/" target="_blank" rel="noopener">blog</a> - 欢迎交流</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;兼容 IE ？不存在的好吗。&lt;/p&gt;
&lt;p&gt;其实使用新语法配合 &lt;code&gt;babel&lt;/code&gt; 的转码，已经可以解决这一些问题了。既然如此，那就多使用新语法去探索一下怎么更好的去写代码吧。&lt;/p&gt;
&lt;p&gt;下面分享个人开发中常用的 js 写法技巧，希望对各位有所帮助。&lt;/p&gt;
&lt;h2 id=&quot;使用-let-const&quot;&gt;&lt;a href=&quot;#使用-let-const&quot; class=&quot;headerlink&quot; title=&quot;使用 let / const&quot;&gt;&lt;/a&gt;使用 let / const&lt;/h2&gt;&lt;p&gt;&lt;code&gt;var&lt;/code&gt; 命令会发生”变量提升“现象，即变量可以在声明之前使用，值为 &lt;code&gt;undefined&lt;/code&gt;。这种现象多多少少是有些奇怪的。&lt;/p&gt;
&lt;p&gt;个人认为，对声明的变量确定后面不会发生更改时，即使性能上没有太大提升差异在，但使用 &lt;code&gt;const&lt;/code&gt;, 代码的可读性也会增强很多。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt; 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;let&lt;/code&gt; 变量指向的内存地址，保存的只是一个指向实际数据的指针&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;补充 &lt;code&gt;const&lt;/code&gt; 定义的变量不是数据不可变，而是保存的引用地址不能发生改变。例子如下：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; person = &amp;#123; &lt;span class=&quot;attr&quot;&gt;age&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;22&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.age = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(person.age) &lt;span class=&quot;comment&quot;&gt;// 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;详情看 &lt;a href=&quot;http://es6.ruanyifeng.com/#docs/let&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;let 和 const 命令&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="开发随笔" scheme="https://weifo.github.io/categories/%E5%BC%80%E5%8F%91%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>五分钟了解(安装)typescript</title>
    <link href="https://weifo.github.io/2019/11/14/ts_basic/"/>
    <id>https://weifo.github.io/2019/11/14/ts_basic/</id>
    <published>2019-11-14T15:05:08.000Z</published>
    <updated>2019-11-18T08:04:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="typescript的由来"><a href="#typescript的由来" class="headerlink" title="typescript的由来"></a>typescript的由来</h2><p>typescript是由微软的一个技术团队开发和维护的一个开源项目，之所以会推出这个项目是为了解决js的一个缺陷吧！由于Javascript是一种<em>动态弱类型</em>的语言，在测试和debug阶段会非常的痛苦，也是为了解决这一“痛点”，微软的VS code团队推出了<strong>typescript</strong><br>&ensp; (强弱/动态静态具体解释，<a href="https://github.com/muwenzi/Program-Blog/issues/34" target="_blank" rel="noopener">click here!</a>)</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure><p>安装后即可通过 <strong>tsc -v</strong> 命令行来查看安装版本，如果提示tsc不是内部或外部命令的话，说明系统的环境变量没有配置，csdn上有相关的解决办法。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc xxx.ts</span><br></pre></td></tr></table></figure><p>编译后会在相同文件夹下生成同名的js文件，关于更加工程化地使用typescript可以参考<a href="https://www.tslang.cn/samples/index.html" target="_blank" rel="noopener">官方文档</a></p><h3 id="变量和函数声明"><a href="#变量和函数声明" class="headerlink" title="变量和函数声明"></a>变量和函数声明</h3><p>与js语法相比，在所有的变量加上类型<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> taylor:<span class="built_in">string</span>=<span class="string">'Taylor'</span>;</span><br><span class="line"><span class="keyword">let</span> age:<span class="built_in">number</span>=<span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组有两种定义方式</span></span><br><span class="line"><span class="keyword">let</span> skills:<span class="built_in">string</span>[]=[<span class="string">'sing'</span>,<span class="string">'gituar'</span>,<span class="string">'writing'</span>];</span><br><span class="line"><span class="keyword">let</span> cats:<span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;=[<span class="string">'white'</span>,<span class="string">'dog'</span>,<span class="string">'miao'</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params">name:<span class="built_in">string</span>,age:<span class="built_in">number</span></span>):<span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> s:<span class="built_in">string</span>=<span class="string">''</span>;</span><br><span class="line">    s=<span class="string">`He is <span class="subst">$&#123;name&#125;</span>,and he's <span class="subst">$&#123;age&#125;</span> years old`</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">info(<span class="string">'calvin harris'</span>,<span class="number">28</span>)</span><br></pre></td></tr></table></figure></p><h3 id="接口和类"><a href="#接口和类" class="headerlink" title="接口和类"></a>接口和类</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可选属性</span></span><br><span class="line"><span class="keyword">interface</span> employee&#123;</span><br><span class="line">    degree?:<span class="built_in">string</span>,</span><br><span class="line">    skilled?:<span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">config:employee</span>):<span class="title">boolean</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(config.skilled)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(config.degree===<span class="string">'master'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> t1=test(&#123;degree:<span class="string">'master'</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> t2=test(&#123;degree:<span class="string">'bachelor'</span>,skilled:<span class="string">'false'</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> t3=test(&#123;skilled:<span class="string">'true'</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(t1,t2,t3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读属性</span></span><br><span class="line"><span class="keyword">interface</span> Point&#123;</span><br><span class="line">    readonly x:<span class="built_in">number</span>,</span><br><span class="line">    readonly y:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1:Point=&#123;x:<span class="number">10</span>,y:<span class="number">5</span>&#125;</span><br><span class="line">p1.y=<span class="number">12</span></span><br><span class="line"><span class="comment">// error</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;typescript的由来&quot;&gt;&lt;a href=&quot;#typescript的由来&quot; class=&quot;headerlink&quot; title=&quot;typescript的由来&quot;&gt;&lt;/a&gt;typescript的由来&lt;/h2&gt;&lt;p&gt;typescript是由微软的一个技术团队开发和维护
      
    
    </summary>
    
      <category term="技术" scheme="https://weifo.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://weifo.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>包学不会的深拷贝与浅拷贝</title>
    <link href="https://weifo.github.io/2019/11/14/deepclone/"/>
    <id>https://weifo.github.io/2019/11/14/deepclone/</id>
    <published>2019-11-14T14:13:05.000Z</published>
    <updated>2019-11-30T05:40:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深拷贝与浅拷贝的含义"><a href="#深拷贝与浅拷贝的含义" class="headerlink" title="深拷贝与浅拷贝的含义"></a>深拷贝与浅拷贝的含义</h2><p>首先要知道在js的世界中，有两种类型的值，分别是基础类型和引用类型。基础类型包括<strong>string,number,boolean,Symbol,undefined,null</strong>,引用类型包括<strong>array,object</strong>等。</p><ul><li>基本数据类型：直接存储在栈（stack）中的数据</li><li>引用数据类型：在栈中存放的是指针，真实的数据存放在堆中。</li></ul><p><strong>首先要分清拷贝和赋值的区别</strong><br>引用类型的赋值是直接赋值了一个指针，二者指向相同的数据内存。而拷贝是要创建一个新的对象/数组，如果只拷贝一层数据的话叫浅拷贝，如果拷贝多层数据叫深拷贝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">    name:<span class="string">'Mike'</span>,</span><br><span class="line">    age:<span class="number">36</span>,</span><br><span class="line">    hobby:[<span class="string">'movies'</span>,<span class="string">'music'</span>,<span class="string">'running'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这是赋值,任何一个都能操作共有的内存数据</span></span><br><span class="line"><span class="keyword">let</span> obj1=obj;</span><br><span class="line">obj1.name=<span class="string">'fred'</span>;</span><br><span class="line">obj1.hobby[<span class="number">1</span>]=<span class="string">'eat'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj,obj1)；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是浅拷贝,只能拷贝一层数据，当对象中有引用类型的value时，只会拷贝这个引用的指针</span></span><br><span class="line"><span class="keyword">let</span> obj2=&#123;...obj&#125;;</span><br><span class="line">obj2.name=<span class="string">'max'</span>;<span class="comment">//不会改变源对象</span></span><br><span class="line">obj2.hobby[<span class="number">1</span>]=<span class="string">'sleep'</span>; <span class="comment">//会改变源对象</span></span><br><span class="line"><span class="built_in">console</span>.log(obj,obj2)</span><br></pre></td></tr></table></figure><h2 id="如何实现浅拷贝"><a href="#如何实现浅拷贝" class="headerlink" title="如何实现浅拷贝"></a>如何实现浅拷贝</h2><h4 id="数组的浅拷贝"><a href="#数组的浅拷贝" class="headerlink" title="数组的浅拷贝"></a>数组的浅拷贝</h4><ul><li><p>slice方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>],</span><br><span class="line">    arr1=arr.slice();</span><br><span class="line">arr1.push(<span class="number">11</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr,arr1)</span><br></pre></td></tr></table></figure></li><li><p>concat方法,当不给concat传参时，该方法和slice()作用相同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1=arr.concat();</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>spread操作符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,[<span class="number">8</span>,<span class="number">9</span>]];</span><br><span class="line"><span class="keyword">let</span> arr1=[...arr];</span><br><span class="line">arr.push(<span class="number">15</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr,arr1);</span><br><span class="line">arr1[<span class="number">3</span>].push(<span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr,arr1);</span><br></pre></td></tr></table></figure></li></ul><h4 id="对象的浅拷贝"><a href="#对象的浅拷贝" class="headerlink" title="对象的浅拷贝"></a>对象的浅拷贝</h4><ul><li><p>手动实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">src</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target=&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> src)&#123;</span><br><span class="line">        <span class="keyword">if</span>(src.hasOwnProperty(key))&#123;</span><br><span class="line">            target[key]=src[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hasOwnProperty方法可以排除来自原型链上的属性</span></span><br></pre></td></tr></table></figure></li><li><p>Object.assign()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=&#123;<span class="attr">a</span>:&#123;<span class="attr">name</span>:<span class="string">'weifo'</span>,<span class="attr">age</span>:<span class="number">33</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> copyobj=<span class="built_in">Object</span>.assign(&#123;&#125;,obj);</span><br><span class="line">copyobj.a.name=<span class="string">'curt'</span>;</span><br><span class="line">concole.log(obj.a.name);<span class="comment">//curt</span></span><br></pre></td></tr></table></figure></li><li><p>spread</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj=&#123;<span class="attr">name</span>:<span class="string">'weifo'</span>,<span class="attr">skill</span>:[<span class="string">'english'</span>,<span class="string">'code'</span>]&#125;;</span><br><span class="line"><span class="keyword">let</span> copyobj=&#123;...obj,<span class="attr">name</span>:<span class="string">'fred'</span>&#125;;<span class="comment">//&#123;name:'fred',skill:[...]&#125;</span></span><br><span class="line"><span class="comment">//es6语法</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a>深拷贝的实现</h2><ul><li><p>trick版</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line"><span class="comment">// 该方法的局限性：symbol，undefined，函数的属性值会被忽略，例子如下</span></span><br><span class="line"><span class="keyword">let</span> syb=<span class="built_in">Symbol</span>(<span class="number">12</span>);</span><br><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">    name:<span class="string">'fred'</span>,</span><br><span class="line">    say:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">'It wont alert'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    syb:syb，</span><br><span class="line">    age:<span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> copy=<span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(copy);<span class="comment">//&#123;name:'fred'&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>手动实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepclone</span>(<span class="params">src</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> src===<span class="string">'object'</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> clone=<span class="built_in">Array</span>.isArray(src)?[]:&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> src)&#123;</span><br><span class="line">            clone[key]=deepclone(src[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clone</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test=&#123;</span><br><span class="line">    name:<span class="string">'fred'</span>,</span><br><span class="line">    cities:[<span class="string">'tokyo'</span>,<span class="string">'paris'</span>,<span class="string">'london'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> clone=deepclone(test);</span><br><span class="line">clone.cities.push(<span class="string">'rome'</span>);</span><br><span class="line">clone.name=<span class="string">'weifo'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(test,clone)</span><br></pre></td></tr></table></figure></li><li><p>解决循环引用<br>上面的方法可以满足大部分的应用场景了，除了遇到对象引用自身的情况，如果采用上面的方法，会有爆栈的错误提示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test=&#123;</span><br><span class="line">    name:<span class="string">'weifo'</span>,</span><br><span class="line">    field:[<span class="number">3</span>,<span class="number">5</span>,<span class="number">11</span>],</span><br><span class="line">    field1:&#123;</span><br><span class="line">        child:<span class="string">'name'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test.test=test;<span class="comment">//循环引用</span></span><br><span class="line">deepclone(test)<span class="comment">//RangeError</span></span><br></pre></td></tr></table></figure></li></ul><p>为了解决循环引用的问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝对象时，先去存储对象中找，找到的话直接返回，没有则继续拷贝。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepclone</span>(<span class="params">target,map=new Map(</span>))</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> target===<span class="string">'object'</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> clone=<span class="built_in">Array</span>.isArray(src)?[]:&#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span>(map.get(target))&#123;</span><br><span class="line">            <span class="keyword">return</span> target</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(target,clone);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> target)&#123;</span><br><span class="line">            clone[key]=clone(target[key],map);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clone</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>使用lodash<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _=<span class="built_in">require</span>(<span class="string">'lodash'</span>);</span><br><span class="line"><span class="keyword">var</span> objects = [&#123; <span class="string">'a'</span>: <span class="number">1</span> &#125;, &#123; <span class="string">'b'</span>: <span class="number">2</span> &#125;];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> deep = _.cloneDeep(objects);</span><br><span class="line"><span class="built_in">console</span>.log(deep[<span class="number">0</span>] === objects[<span class="number">0</span>]);<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;深拷贝与浅拷贝的含义&quot;&gt;&lt;a href=&quot;#深拷贝与浅拷贝的含义&quot; class=&quot;headerlink&quot; title=&quot;深拷贝与浅拷贝的含义&quot;&gt;&lt;/a&gt;深拷贝与浅拷贝的含义&lt;/h2&gt;&lt;p&gt;首先要知道在js的世界中，有两种类型的值，分别是基础类型和引用类型。基础类型
      
    
    </summary>
    
      <category term="前端开发" scheme="https://weifo.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="javascript" scheme="https://weifo.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>webpack-plugins</title>
    <link href="https://weifo.github.io/2019/10/12/webpack-plugins/"/>
    <id>https://weifo.github.io/2019/10/12/webpack-plugins/</id>
    <published>2019-10-12T13:43:08.000Z</published>
    <updated>2020-03-15T13:18:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="功能类"><a href="#功能类" class="headerlink" title="功能类"></a>功能类</h2><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><ul><li>把编译后的文件（css/js）插入到入口文件中，可以只指定某些文件插入，可以对 html 进行压缩等</li><li><code>filename</code>：输出文件名；</li><li><code>template</code>：模板文件，不局限于 html 后缀哦；</li><li><code>removeComments</code>：移除 HTML 中的注释；</li><li><code>collapseWhitespace</code>：删除空白符与换行符，整个文件会压成一行；</li><li><code>inlineSource</code>：插入到 html 的 css、js 文件都要内联，即不是以 link、script 的形式引入；</li><li><code>inject</code>：是否能注入内容到 输出 的页面去；</li><li><code>chunks</code>：指定插入某些模块；</li><li><code>hash</code>：每次会在插入的文件后面加上 hash ，用于处理缓存，如：；<br>其他：favicon、meta、title ……；</li></ul><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">// 输出文件的目录</span></span><br><span class="line">    filename: <span class="string">'js/[name].[hash:8].js'</span> <span class="comment">// 打包路径及名称</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'index.html'</span>, <span class="comment">// 生成文件名</span></span><br><span class="line">      template: <span class="string">'./public/index.html'</span>, <span class="comment">// 配置要被编译的html文件</span></span><br><span class="line">      hash: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 压缩HTML文件</span></span><br><span class="line">      minify: &#123;</span><br><span class="line">        removeAttributeQuotes: <span class="literal">true</span>, <span class="comment">//删除双引号</span></span><br><span class="line">        collapseWhitespace: <span class="literal">true</span> <span class="comment">//折叠 html 为一行</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传送门 ==&gt; <a href="https://www.npmjs.com/package/html-webpack-plugin" target="_blank" rel="noopener">html-webpack-plugin</a></p><h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><blockquote><p>在编译之前清理指定目录指定内容。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [<span class="keyword">new</span> CleanWebpackPlugin([<span class="string">'dist'</span>])]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定清除哪些文件 new CleanWebpackPlugin(pathsToClean [, &#123;pathsToClean &#125;]) 详情请看 npm</span></span><br></pre></td></tr></table></figure><p>传送门 ==&gt; <a href="https://www.npmjs.com/package/clean-webpack-plugin" target="_blank" rel="noopener">clean-webpack-plugin</a></p><h3 id="copy-webpack-plugin"><a href="#copy-webpack-plugin" class="headerlink" title="copy-webpack-plugin"></a>copy-webpack-plugin</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [<span class="keyword">new</span> CopyWebpackPlugin([...patterns], options)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传送门 ==&gt; <a href="https://www.npmjs.com/package/copy-webpack-plugin" target="_blank" rel="noopener">copy-webpack-plugin</a></p><h3 id="compression-webpack-plugin"><a href="#compression-webpack-plugin" class="headerlink" title="compression-webpack-plugin"></a>compression-webpack-plugin</h3><blockquote><p>使用 compression-webpack-plugin 插件进行压缩，提供带 <code>Content-Encoding</code> 编码的压缩版的资源。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CompressionPlugin = <span class="built_in">require</span>(<span class="string">'compression-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CompressionPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'[path].gz[query]'</span>, <span class="comment">//目标资源名称。[file] 会被替换成原资源。[path] 会被替换成原资源路径，[query] 替换成原查询字符串</span></span><br><span class="line">      algorithm: <span class="string">'gzip'</span>, <span class="comment">//算法</span></span><br><span class="line">      test: <span class="regexp">/\.js(\?.*)?$/i</span>, <span class="comment">//压缩 js</span></span><br><span class="line">      deleteOriginalAssets: <span class="literal">true</span>, <span class="comment">// 删除源文件</span></span><br><span class="line">      threshold: <span class="number">10240</span>, <span class="comment">//只处理比这个值大的资源。按字节计算</span></span><br><span class="line">      minRatio: <span class="number">0.8</span> <span class="comment">//只有压缩率比这个值小的资源才会被处理</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传送门 ==&gt; <a href="https://www.npmjs.com/package/compression-webpack-plugin" target="_blank" rel="noopener">compression-webpack-plugin</a></p><h3 id="webpack-manifest-plugin"><a href="#webpack-manifest-plugin" class="headerlink" title="webpack-manifest-plugin"></a>webpack-manifest-plugin</h3><blockquote><p>该插件可以显示出编译之前的文件和编译之后的文件的映射</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ManifestPlugin = <span class="built_in">require</span>(<span class="string">'webpack-manifest-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [<span class="keyword">new</span> ManifestPlugin()]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传送门 ==&gt; <a href="https://www.npmjs.com/package/webpack-manifest-plugin" target="_blank" rel="noopener">webpack-manifest-plugin</a></p><h3 id="progress-bar-webpack-plugin"><a href="#progress-bar-webpack-plugin" class="headerlink" title="progress-bar-webpack-plugin"></a>progress-bar-webpack-plugin</h3><blockquote><p>编译进度条插件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ProgressBarPlugin = <span class="built_in">require</span>(<span class="string">'progress-bar-webpack-plugin'</span>) <span class="comment">// 编译进度条插件</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [<span class="keyword">new</span> ProgressBarPlugin()]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传送门 ==&gt; <a href="https://www.npmjs.com/package/progress-bar-webpack-plugin" target="_blank" rel="noopener">progress-bar-webpack-plugin</a></p><h2 id="代码相关"><a href="#代码相关" class="headerlink" title="代码相关"></a>代码相关</h2><h3 id="webpack-ProvidePlugin"><a href="#webpack-ProvidePlugin" class="headerlink" title="webpack.ProvidePlugin"></a>webpack.ProvidePlugin</h3><blockquote><p>自动加载模块，而不必到处 import 或 require 。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [<span class="keyword">new</span> webpack.ProvidePlugin(&#123; <span class="attr">$</span>: <span class="string">'jquery'</span> &#125;)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">console</span>.log($)</span><br></pre></td></tr></table></figure><p>传送门 ==&gt; <a href="https://www.webpackjs.com/plugins/provide-plugin/" target="_blank" rel="noopener">webpack.ProvidePlugin</a></p><h3 id="webpack-DefinePlugin"><a href="#webpack-DefinePlugin" class="headerlink" title="webpack.DefinePlugin"></a>webpack.DefinePlugin</h3><blockquote><p><code>DefinePlugin</code> 允许创建一个在编译时可以配置的全局常量。这可能会对开发模式和发布模式的构建允许不同的行为非常有用。如果在开发构建中，而不在发布构建中执行日志记录，则可以使用全局常量来决定是否记录日志。这就是 <code>DefinePlugin</code> 的用处，设置它，就可以忘记开发和发布构建的规则。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      PRODUCTION: <span class="built_in">JSON</span>.stringify(<span class="literal">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">console</span>.log(PRODUCTION) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>传送门 ==&gt; <a href="https://www.webpackjs.com/plugins/define-plugin/" target="_blank" rel="noopener">webpack.DefinePlugin</a></p><h3 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h3><p><code>mini-css-extract-plugin</code>，它默认就会对你的样式进行模块化拆分。相对 <code>extract-text-webpack-plugin</code>。 即 css 异步按需加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>) <span class="comment">// 抽取 css 到独立文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        include: [path.resolve(__dirname, <span class="string">'src'</span>)],</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: MiniCssExtractPlugin.loader,</span><br><span class="line">            options: &#123;</span><br><span class="line">              publicPath: <span class="string">'../'</span> <span class="comment">// chunk publicPath</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">'css-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'css/[name].[hash:8].css'</span>, <span class="comment">//这里配置跟output写法一致</span></span><br><span class="line">      chunkFilename: <span class="string">'css/[id][chunkhash:8].css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传送门 ==&gt; <a href="https://www.npmjs.com/package/mini-css-extract-plugin" target="_blank" rel="noopener">mini-css-extract-plugin</a></p><h2 id="编译结果优化类"><a href="#编译结果优化类" class="headerlink" title="编译结果优化类"></a>编译结果优化类</h2><h3 id="wbepack-IgnorePlugin"><a href="#wbepack-IgnorePlugin" class="headerlink" title="wbepack.IgnorePlugin"></a>wbepack.IgnorePlugin</h3><p>防止在 import 或 require 调用时，生成以下正则表达式匹配的模块：</p><ul><li><code>requestRegExp</code> 匹配(test)资源请求路径的正则表达式。</li><li><code>contextRegExp</code> （可选）匹配(test)资源上下文（目录）的正则表达式。</li></ul><p>moment 2.18 会将所有本地化内容和核心功能一起打包（见该 <a href="https://github.com/moment/moment/issues/2373" target="_blank" rel="noopener">GitHub issue</a>）。你可使用 IgnorePlugin 在打包时忽略本地化内容:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.IgnorePlugin(<span class="regexp">/^\.\/locale$/</span>, /moment$/)</span><br></pre></td></tr></table></figure><p>传送门 ==&gt; <a href="https://www.webpackjs.com/plugins/ignore-plugin/" target="_blank" rel="noopener">wbepack.IgnorePlugin</a></p><h3 id="uglifyjs-webpack-plugin"><a href="#uglifyjs-webpack-plugin" class="headerlink" title="uglifyjs-webpack-plugin"></a>uglifyjs-webpack-plugin</h3><ul><li>js 代码压缩,默认会使用 <code>optimization.minimizer</code>，</li><li><code>cache</code>: Boolean/String ,字符串即是缓存文件存放的路径；</li><li><code>test</code>：正则表达式、字符串、数组都可以，用于只匹配某些文件，如：/.js(?.*)?\$/i;</li><li><code>parallel</code> : 启用多线程并行运行来提高编译速度，经常编译的时候听到电脑跑的呼呼响，可能就是它干的，哈哈～；</li><li><code>output.comments</code> ： 删除所有注释，</li><li><code>compress.warnings</code> ：插件在进行删除一些无用代码的时候，不提示警告，</li><li><code>compress.drop_console</code>：喜欢打 console 的同学，它能自动帮你过滤掉，再也不用担心线上还打印日志了；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyJsPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      <span class="keyword">new</span> UglifyJsPlugin(&#123;</span><br><span class="line">        cache: <span class="literal">true</span>, <span class="comment">// 开启缓存</span></span><br><span class="line">        parallel: <span class="literal">true</span>, <span class="comment">// 开启多线程编译</span></span><br><span class="line">        sourceMap: <span class="literal">true</span>, <span class="comment">// 是否sourceMap</span></span><br><span class="line">        <span class="comment">// 丑化参数</span></span><br><span class="line">        uglifyOptions: &#123;</span><br><span class="line">          comments: <span class="literal">false</span>,</span><br><span class="line">          warnings: <span class="literal">false</span>,</span><br><span class="line">          compress: &#123;</span><br><span class="line">            unused: <span class="literal">true</span>,</span><br><span class="line">            dead_code: <span class="literal">true</span>,</span><br><span class="line">            collapse_vars: <span class="literal">true</span>,</span><br><span class="line">            reduce_vars: <span class="literal">true</span></span><br><span class="line">          &#125;,</span><br><span class="line">          output: &#123;</span><br><span class="line">            comments: <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传送门 ==&gt; <a href="https://www.npmjs.com/package/uglifyjs-webpack-plugin" target="_blank" rel="noopener">uglifyjs-webpack-plugin</a></p><h3 id="optimize-css-assets-webpack-plugin"><a href="#optimize-css-assets-webpack-plugin" class="headerlink" title="optimize-css-assets-webpack-plugin"></a>optimize-css-assets-webpack-plugin</h3><p>它的作用在于压缩 css 文件</p><ul><li><code>assetNameRegExp</code>：默认是全部的 css 都会压缩，该字段可以进行指定某些要处理的文件，</li><li><code>cssProcessor</code>：指定一个优化 css 的处理器，默认 cssnano，</li><li><code>cssProcessorPluginOptions</code>：cssProcessor 后面可以跟一个 process 方法，会返回一个 promise 对象，而 cssProcessorPluginOptions 就是一个 options 参数选项！</li><li><code>canPrint</code>：布尔，是否要将编译的消息显示在控制台，没发现有什么用！</li><li>坑点 ：建议使用高版本的包，之前低版本有遇到样式丢失把各浏览器前缀干掉的问题，</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OptimizeCssAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>) <span class="comment">// 丑化 css</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      <span class="keyword">new</span> OptimizeCssAssetsPlugin(&#123;</span><br><span class="line">        cssProcessor: <span class="built_in">require</span>(<span class="string">'cssnano'</span>), <span class="comment">// css 压缩优化器</span></span><br><span class="line">        cssProcessorOptions: &#123; <span class="attr">discardComments</span>: &#123; <span class="attr">removeAll</span>: <span class="literal">true</span> &#125; &#125; <span class="comment">// 去除所有注释</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传送门 ==&gt; <a href="https://www.npmjs.com/package/optimize-css-assets-webpack-plugin" target="_blank" rel="noopener">optimize-css-assets-webpack-plugin</a></p><h3 id="SplitChunksPlugin"><a href="#SplitChunksPlugin" class="headerlink" title="SplitChunksPlugin"></a>SplitChunksPlugin</h3><p><code>webpack</code> 把 <code>chunk</code> 分为两种类型，一种是初始加载 <code>initial chunk</code>，另外一种是异步加载 <code>async chunk</code>，如果不配置 <code>SplitChunksPlugin，`</code>webpack <code>会在 production 的模式下自动开启，默认情况下，</code>webpack<code>会将</code>node_modules<code>下的所有模块定义为异步加载模块，并分析你的</code>entry<code>、动态加载（</code>import()<code>、require.ensure）模块，找出这些模块之间共用的</code>node_modules<code>下的模块，并将这些模块提取到单独的</code>chunk` 中，在需要的时候异步加载到页面当中，其中默认配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'async'</span>, <span class="comment">// 异步加载chunk</span></span><br><span class="line">      minSize: <span class="number">30000</span>,</span><br><span class="line">      maxSize: <span class="number">0</span>,</span><br><span class="line">      minChunks: <span class="number">1</span>,</span><br><span class="line">      maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">      maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">      automaticNameDelimiter: <span class="string">'~'</span>, <span class="comment">// 文件名中chunk分隔符</span></span><br><span class="line">      name: <span class="literal">true</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>, <span class="comment">//</span></span><br><span class="line">          priority: <span class="number">-10</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          minChunks: <span class="number">2</span>, <span class="comment">// 最小的共享chunk数</span></span><br><span class="line">          priority: <span class="number">-20</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传送门 ==&gt; <a href="https://www.webpackjs.com/plugins/split-chunks-plugin/" target="_blank" rel="noopener">SplitChunksPlugin</a></p><h3 id="webpack-HotModuleReplacementPlugin"><a href="#webpack-HotModuleReplacementPlugin" class="headerlink" title="webpack.HotModuleReplacementPlugin"></a>webpack.HotModuleReplacementPlugin</h3><p>热更新, 配合 <code>webpack-dev-server</code> 使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add webpack-dev-server -D</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: <span class="number">1234</span>,</span><br><span class="line">    open: <span class="literal">true</span>, <span class="comment">// 自动打开浏览器</span></span><br><span class="line">    compress: <span class="literal">true</span>, <span class="comment">// 服务器压缩</span></span><br><span class="line">    hot: <span class="literal">true</span> <span class="comment">// 开启热加载</span></span><br><span class="line">    <span class="comment">//... proxy、hot</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="keyword">new</span> webpack.HotModuleReplacementPlugin()]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>传送门 ==&gt; <a href="https://www.webpackjs.com/configuration/dev-server/" target="_blank" rel="noopener">devServer</a></li><li>传送门 ==&gt; <a href="https://www.npmjs.com/package/webpack-dev-server" target="_blank" rel="noopener">webpack-dev-server</a></li></ul><h2 id="加快编译速度"><a href="#加快编译速度" class="headerlink" title="加快编译速度"></a>加快编译速度</h2><h3 id="DllPlugin-amp-amp-DllReferencePlugin-amp-amp-autodll-webpack-plugin"><a href="#DllPlugin-amp-amp-DllReferencePlugin-amp-amp-autodll-webpack-plugin" class="headerlink" title="DllPlugin &amp;&amp; DllReferencePlugin &amp;&amp; autodll-webpack-plugin"></a>DllPlugin &amp;&amp; DllReferencePlugin &amp;&amp; autodll-webpack-plugin</h3><p><code>DllPlugin</code> 和 <code>DllReferencePlugin</code> 提供分离包的方式可以大大提高构建时间性能。主要思想在于，将一些不做修改的依赖文件，提前打包，这样我们开发代码发布的时候就不需要再对这部分代码进行打包。从而节省了打包时间。</p><p>DllPlugin 插件：用于打包出一个个单独的动态链接库文件。<br>DllReferencePlugin 插件：用于在主要配置文件中去引入 DllPlugin 插件打包好的动态链接库文件。</p><ul><li><code>DllPlugin</code><ul><li><code>context (optional)</code>: manifest 文件中请求的上下文(context)(默认值为 webpack 的上下文(context))</li><li><code>name</code>: 暴露出的 DLL 的函数名 (TemplatePaths: [hash] &amp; [name] )</li><li><code>path</code>: manifest json 文件的绝对路径 (输出文件)</li></ul></li></ul><p><code>DllReferencePlugin</code>: 这个插件把只有 dll 的 bundle(们)(dll-only-bundle(s)) 引用到需要的预编译的依赖。</p><ul><li><code>DllReferencePlugin</code><ul><li><code>context</code>: (绝对路径) manifest (或者是内容属性)中请求的上下文</li><li><code>manifest</code>: 包含 content 和 name 的对象，或者在编译时(compilation)的一个用于加载的 JSON manifest 绝对路径</li><li><code>content (optional)</code>: 请求到模块 id 的映射 (默认值为 manifest.content)</li><li><code>name (optional)</code>: dll 暴露的地方的名称 (默认值为 manifest.name) (可参考 externals)</li><li><code>scope (optional)</code>: dll 中内容的前缀</li><li><code>sourceType (optional)</code>: dll 是如何暴露的 (libraryTarget)</li></ul></li></ul><pre><code class="js"></code></pre><p>传送门 ==&gt; <a href="https://www.webpackjs.com/plugins/dll-plugin/" target="_blank" rel="noopener">DllPlugin</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;功能类&quot;&gt;&lt;a href=&quot;#功能类&quot; class=&quot;headerlink&quot; title=&quot;功能类&quot;&gt;&lt;/a&gt;功能类&lt;/h2&gt;&lt;h3 id=&quot;html-webpack-plugin&quot;&gt;&lt;a href=&quot;#html-webpack-plugin&quot; class=&quot;headerlink&quot; title=&quot;html-webpack-plugin&quot;&gt;&lt;/a&gt;html-webpack-plugin&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;把编译后的文件（css/js）插入到入口文件中，可以只指定某些文件插入，可以对 html 进行压缩等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filename&lt;/code&gt;：输出文件名；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;template&lt;/code&gt;：模板文件，不局限于 html 后缀哦；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;removeComments&lt;/code&gt;：移除 HTML 中的注释；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;collapseWhitespace&lt;/code&gt;：删除空白符与换行符，整个文件会压成一行；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inlineSource&lt;/code&gt;：插入到 html 的 css、js 文件都要内联，即不是以 link、script 的形式引入；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inject&lt;/code&gt;：是否能注入内容到 输出 的页面去；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chunks&lt;/code&gt;：指定插入某些模块；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hash&lt;/code&gt;：每次会在插入的文件后面加上 hash ，用于处理缓存，如：；&lt;br&gt;其他：favicon、meta、title ……；&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="webpack" scheme="https://weifo.github.io/categories/webpack/"/>
    
    
      <category term="webpack" scheme="https://weifo.github.io/tags/webpack/"/>
    
  </entry>
  
</feed>
