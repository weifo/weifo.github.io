<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="weifo" type="application/atom+xml">






<meta name="description" content="行到水穷处，坐看云起时">
<meta name="keywords" content="读书 旅行">
<meta property="og:type" content="website">
<meta property="og:title" content="weifo">
<meta property="og:url" content="https://weifo.github.io/index.html">
<meta property="og:site_name" content="weifo">
<meta property="og:description" content="行到水穷处，坐看云起时">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="weifo">
<meta name="twitter:description" content="行到水穷处，坐看云起时">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://weifo.github.io/">





  <title>weifo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">weifo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">选择你所爱的，爱你所选择的</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-首页">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-存档">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            存档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-分类">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weifo.github.io/2024/09/16/typeScriptTips2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weifo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="weifo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/09/16/typeScriptTips2/" itemprop="url">TypeScript 在前端项目中的最佳实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-09-16T12:00:12+08:00">
                2024-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TypeScript/" itemprop="url" rel="index">
                    <span itemprop="name">TypeScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>TypeScript 已成为现代前端开发的主流选择之一。它提供了类型系统、接口、泛型等语言特性，极大地提升了代码的可维护性和开发效率。本文将结合实际场景和代码示例，分享 TypeScript 在前端项目中的最佳实践，帮助你构建更稳健、更高效的应用。</p>
<h2 id="一、项目初始化建议"><a href="#一、项目初始化建议" class="headerlink" title="一、项目初始化建议"></a>一、项目初始化建议</h2><h3 id="1-使用官方推荐配置"><a href="#1-使用官方推荐配置" class="headerlink" title="1. 使用官方推荐配置"></a>1. 使用官方推荐配置</h3><p>使用 <code>tsc --init</code> 创建配置文件后，可以启用一些推荐的选项：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"strict"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"noImplicitAny"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"strictNullChecks"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"forceConsistentCasingInFileNames"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"esModuleInterop"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"skipLibCheck"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些配置确保了更严格的类型检查，有助于发现潜在问题。</p>
<h3 id="2-使用-ESLint-Prettier-统一规范"><a href="#2-使用-ESLint-Prettier-统一规范" class="headerlink" title="2. 使用 ESLint + Prettier 统一规范"></a>2. 使用 ESLint + Prettier 统一规范</h3><p>结合 TypeScript 插件，确保团队代码风格统一。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin --save-dev</span><br></pre></td></tr></table></figure>
<p>在 <code>.eslintrc.js</code> 中配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  parser: <span class="string">'@typescript-eslint/parser'</span>,</span><br><span class="line">  plugins: [<span class="string">'@typescript-eslint'</span>],</span><br><span class="line">  extends: [</span><br><span class="line">    <span class="string">'eslint:recommended'</span>,</span><br><span class="line">    <span class="string">'plugin:@typescript-eslint/recommended'</span>,</span><br><span class="line">    <span class="string">'prettier'</span></span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二、类型系统最佳实践"><a href="#二、类型系统最佳实践" class="headerlink" title="二、类型系统最佳实践"></a>二、类型系统最佳实践</h2><h3 id="1-避免使用-any"><a href="#1-避免使用-any" class="headerlink" title="1. 避免使用 any"></a>1. 避免使用 <code>any</code></h3><p><code>any</code> 会绕过类型系统，容易引发运行时错误。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尽量避免</span></span><br><span class="line"><span class="keyword">let</span> data: <span class="built_in">any</span> = fetchData();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好的方式</span></span><br><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user: User = &#123; id: <span class="number">1</span>, name: <span class="string">'Alice'</span> &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-善用联合类型和类型守卫"><a href="#2-善用联合类型和类型守卫" class="headerlink" title="2. 善用联合类型和类型守卫"></a>2. 善用联合类型和类型守卫</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printId</span>(<span class="params">id: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> id === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(id.toUpperCase());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(id.toFixed(<span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-使用类型别名和接口管理结构"><a href="#3-使用类型别名和接口管理结构" class="headerlink" title="3. 使用类型别名和接口管理结构"></a>3. 使用类型别名和接口管理结构</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Status = <span class="string">'loading'</span> | <span class="string">'success'</span> | <span class="string">'error'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ApiResponse&lt;T&gt; &#123;</span><br><span class="line">  status: Status;</span><br><span class="line">  data: T;</span><br><span class="line">  message?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> response: ApiResponse&lt;<span class="built_in">string</span>[]&gt; = &#123;</span><br><span class="line">  status: <span class="string">'success'</span>,</span><br><span class="line">  data: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="三、模块化和可复用性"><a href="#三、模块化和可复用性" class="headerlink" title="三、模块化和可复用性"></a>三、模块化和可复用性</h2><h3 id="1-使用泛型编写通用函数"><a href="#1-使用泛型编写通用函数" class="headerlink" title="1. 使用泛型编写通用函数"></a>1. 使用泛型编写通用函数</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">'hello'</span>);</span><br><span class="line"><span class="keyword">const</span> num = identity&lt;<span class="built_in">number</span>&gt;(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-封装工具函数类型声明"><a href="#2-封装工具函数类型声明" class="headerlink" title="2. 封装工具函数类型声明"></a>2. 封装工具函数类型声明</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">merge</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">a: T, b: U</span>): <span class="title">T</span> &amp; <span class="title">U</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; ...a, ...b &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> obj = merge(&#123; foo: <span class="number">1</span> &#125;, &#123; bar: <span class="string">'baz'</span> &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="四、在-React-中使用-TypeScript"><a href="#四、在-React-中使用-TypeScript" class="headerlink" title="四、在 React 中使用 TypeScript"></a>四、在 React 中使用 TypeScript</h2><h3 id="1-函数组件类型"><a href="#1-函数组件类型" class="headerlink" title="1. 函数组件类型"></a>1. 函数组件类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">type Props = &#123;</span><br><span class="line">  title: string;</span><br><span class="line">  onClick: () =&gt; void;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const Button: React.FC&lt;Props&gt; = (&#123; title, onClick &#125;) =&gt; &#123;</span><br><span class="line">  return &lt;button onClick=&#123;onClick&#125;&gt;&#123;title&#125;&lt;/button&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-使用-useState-的类型"><a href="#2-使用-useState-的类型" class="headerlink" title="2. 使用 useState 的类型"></a>2. 使用 <code>useState</code> 的类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [count, setCount] = useState&lt;number&gt;(0);</span><br></pre></td></tr></table></figure>
<h3 id="3-事件对象类型"><a href="#3-事件对象类型" class="headerlink" title="3. 事件对象类型"></a>3. 事件对象类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const handleChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) =&gt; &#123;</span><br><span class="line">  console.log(e.target.value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="五、集成第三方库"><a href="#五、集成第三方库" class="headerlink" title="五、集成第三方库"></a>五、集成第三方库</h2><h3 id="1-安装类型定义"><a href="#1-安装类型定义" class="headerlink" title="1. 安装类型定义"></a>1. 安装类型定义</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @types/lodash</span><br></pre></td></tr></table></figure>
<h3 id="2-为无类型库添加声明"><a href="#2-为无类型库添加声明" class="headerlink" title="2. 为无类型库添加声明"></a>2. 为无类型库添加声明</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types/custom-lib.d.ts</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'my-lib' &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">customFunction</span>(<span class="params"></span>): <span class="title">void</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、与-API-接口结合的技巧"><a href="#六、与-API-接口结合的技巧" class="headerlink" title="六、与 API 接口结合的技巧"></a>六、与 API 接口结合的技巧</h2><h3 id="1-使用接口或类型描述接口返回值"><a href="#1-使用接口或类型描述接口返回值" class="headerlink" title="1. 使用接口或类型描述接口返回值"></a>1. 使用接口或类型描述接口返回值</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> LoginResponse &#123;</span><br><span class="line">  token: <span class="built_in">string</span>;</span><br><span class="line">  expires: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"></span>): <span class="title">Promise</span>&lt;<span class="title">LoginResponse</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">'/api/login'</span>);</span><br><span class="line">  <span class="keyword">return</span> res.json();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-搭配-Axios-使用"><a href="#2-搭配-Axios-使用" class="headerlink" title="2. 搭配 Axios 使用"></a>2. 搭配 Axios 使用</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.get&lt;User[]&gt;<span class="function">(<span class="params">'/api/users'</span>).<span class="params">then</span>(<span class="params">(<span class="params">res</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="built_in">console</span>.log(<span class="params">res.data</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>);</span></span><br></pre></td></tr></table></figure>
<h2 id="七、避免常见陷阱"><a href="#七、避免常见陷阱" class="headerlink" title="七、避免常见陷阱"></a>七、避免常见陷阱</h2><h3 id="1-不合理的类型断言"><a href="#1-不合理的类型断言" class="headerlink" title="1. 不合理的类型断言"></a>1. 不合理的类型断言</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>) <span class="keyword">as</span> HTMLDivElement;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>);</span><br><span class="line"><span class="keyword">if</span> (element <span class="keyword">instanceof</span> HTMLDivElement) &#123;</span><br><span class="line">  element.innerText = <span class="string">'Hello'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-忽视类型提示或覆盖类型"><a href="#2-忽视类型提示或覆盖类型" class="headerlink" title="2. 忽视类型提示或覆盖类型"></a>2. 忽视类型提示或覆盖类型</h3><p>过度使用 <code>as any</code> 或者 <code>@ts-ignore</code> 会掩盖潜在问题，需慎用。</p>
<h2 id="八、总结与展望"><a href="#八、总结与展望" class="headerlink" title="八、总结与展望"></a>八、总结与展望</h2><p>TypeScript 是现代前端工程不可或缺的一环。它不仅提升了代码的可读性、可靠性，也为大型团队协作带来极大的便利。</p>
<p>通过合理使用类型系统、模块化、泛型、React 类型定义等手段，你将能构建更加可维护和可拓展的应用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weifo.github.io/2024/08/16/performance2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weifo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="weifo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/16/performance2/" itemprop="url">性能优化：打造更快更流畅的前端体验</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-08-16T12:00:12+08:00">
                2024-08-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/性能优化/" itemprop="url" rel="index">
                    <span itemprop="name">性能优化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>无论是企业级应用还是个人项目，前端性能始终是影响用户体验的重要因素之一。一款加载缓慢、交互迟钝的网站，极有可能让用户选择关闭页面。本文将从页面加载、资源管理、渲染优化和开发实践等方面，深入浅出地讲解前端性能优化的核心技巧，并通过示例帮助你快速上手。</p>
<h2 id="1-页面加载优化"><a href="#1-页面加载优化" class="headerlink" title="1. 页面加载优化"></a>1. 页面加载优化</h2><h3 id="1-1-减少请求数量"><a href="#1-1-减少请求数量" class="headerlink" title="1.1 减少请求数量"></a>1.1 减少请求数量</h3><ul>
<li>合并 CSS/JS 文件</li>
<li>使用图标字体或 SVG sprite 替代多张小图标</li>
<li>使用 HTTP/2 以支持多路复用</li>
</ul>
<h3 id="1-2-资源懒加载（Lazy-Load）"><a href="#1-2-资源懒加载（Lazy-Load）" class="headerlink" title="1.2 资源懒加载（Lazy Load）"></a>1.2 资源懒加载（Lazy Load）</h3><p>图片、组件、数据等都可以懒加载，只在需要时才加载，减少初始加载压力。</p>
<h4 id="示例：懒加载图片（原生方式）"><a href="#示例：懒加载图片（原生方式）" class="headerlink" title="示例：懒加载图片（原生方式）"></a>示例：懒加载图片（原生方式）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"placeholder.jpg"</span> <span class="attr">data-src</span>=<span class="string">"real-image.jpg"</span> <span class="attr">loading</span>=<span class="string">"lazy"</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>或使用 JavaScript：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> img = <span class="built_in">document</span>.querySelector(<span class="string">'img'</span>);</span><br><span class="line">img.src = img.dataset.src;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-3-使用-CDN-加速资源加载"><a href="#1-3-使用-CDN-加速资源加载" class="headerlink" title="1.3 使用 CDN 加速资源加载"></a>1.3 使用 CDN 加速资源加载</h3><p>将静态资源托管到 CDN 可减少服务器压力，提高下载速度。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue@3"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-资源优化技巧"><a href="#2-资源优化技巧" class="headerlink" title="2. 资源优化技巧"></a>2. 资源优化技巧</h2><h3 id="2-1-图片优化"><a href="#2-1-图片优化" class="headerlink" title="2.1 图片优化"></a>2.1 图片优化</h3><ul>
<li>使用 WebP 格式</li>
<li>通过压缩工具（如 TinyPNG、ImageOptim）处理图片</li>
<li>设置合适的图片尺寸，避免大图缩小展示</li>
</ul>
<h3 id="2-2-压缩与-Tree-shaking"><a href="#2-2-压缩与-Tree-shaking" class="headerlink" title="2.2 压缩与 Tree-shaking"></a>2.2 压缩与 Tree-shaking</h3><ul>
<li>使用 webpack 的 <code>mode: production</code> 自动启用压缩与 Tree-shaking</li>
<li>移除未使用代码（Dead Code Elimination）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-渲染性能优化"><a href="#3-渲染性能优化" class="headerlink" title="3. 渲染性能优化"></a>3. 渲染性能优化</h2><h3 id="3-1-避免频繁-DOM-操作"><a href="#3-1-避免频繁-DOM-操作" class="headerlink" title="3.1 避免频繁 DOM 操作"></a>3.1 避免频繁 DOM 操作</h3><p>使用虚拟 DOM（React/Vue）是良好的方式，但即使如此，也需注意更新策略。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React 中避免不必要重渲染</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; memo &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">const</span> MyComponent = memo(<span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.value&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="3-2-使用-requestAnimationFrame-优化动画"><a href="#3-2-使用-requestAnimationFrame-优化动画" class="headerlink" title="3.2 使用 requestAnimationFrame 优化动画"></a>3.2 使用 <code>requestAnimationFrame</code> 优化动画</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 动画逻辑</span></span><br><span class="line">  requestAnimationFrame(animate);</span><br><span class="line">&#125;</span><br><span class="line">animate();</span><br></pre></td></tr></table></figure>
<h3 id="3-3-虚拟列表（Virtual-Scrolling）"><a href="#3-3-虚拟列表（Virtual-Scrolling）" class="headerlink" title="3.3 虚拟列表（Virtual Scrolling）"></a>3.3 虚拟列表（Virtual Scrolling）</h3><p>用于渲染大数据列表，只渲染可视区的内容。</p>
<h4 id="示例：React-虚拟列表（使用-react-window）"><a href="#示例：React-虚拟列表（使用-react-window）" class="headerlink" title="示例：React 虚拟列表（使用 react-window）"></a>示例：React 虚拟列表（使用 react-window）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; FixedSizeList <span class="keyword">as</span> List &#125; <span class="keyword">from</span> <span class="string">'react-window'</span>;</span><br><span class="line"></span><br><span class="line">&lt;List</span><br><span class="line">  height=&#123;<span class="number">400</span>&#125;</span><br><span class="line">  itemCount=&#123;<span class="number">1000</span>&#125;</span><br><span class="line">  itemSize=&#123;<span class="number">35</span>&#125;</span><br><span class="line">  width=&#123;<span class="number">300</span>&#125;</span><br><span class="line">&gt;</span><br><span class="line">  &#123;(&#123; index, style &#125;) =&gt; (</span><br><span class="line">    &lt;div style=&#123;style&#125;&gt;Row &#123;index&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>List&gt;</span><br></pre></td></tr></table></figure>
<h2 id="4-开发与构建阶段优化"><a href="#4-开发与构建阶段优化" class="headerlink" title="4. 开发与构建阶段优化"></a>4. 开发与构建阶段优化</h2><h3 id="4-1-代码分割（Code-Splitting）"><a href="#4-1-代码分割（Code-Splitting）" class="headerlink" title="4.1 代码分割（Code Splitting）"></a>4.1 代码分割（Code Splitting）</h3><p>使用 webpack 动态 import 实现按需加载。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态导入模块</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">'lodash'</span>).then(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 使用 lodash</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="4-2-懒加载路由组件（以-Vue-Router-为例）"><a href="#4-2-懒加载路由组件（以-Vue-Router-为例）" class="headerlink" title="4.2 懒加载路由组件（以 Vue Router 为例）"></a>4.2 懒加载路由组件（以 Vue Router 为例）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UserPage = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./views/User.vue'</span>);</span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">'/user'</span>, <span class="attr">component</span>: UserPage &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h3 id="4-3-使用现代打包工具"><a href="#4-3-使用现代打包工具" class="headerlink" title="4.3 使用现代打包工具"></a>4.3 使用现代打包工具</h3><p>如 Vite、esbuild、Rollup 相比 webpack 更快，构建性能优越。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init vite@latest my-project</span><br></pre></td></tr></table></figure>
<h2 id="5-性能监测与分析"><a href="#5-性能监测与分析" class="headerlink" title="5. 性能监测与分析"></a>5. 性能监测与分析</h2><h3 id="5-1-浏览器-DevTools"><a href="#5-1-浏览器-DevTools" class="headerlink" title="5.1 浏览器 DevTools"></a>5.1 浏览器 DevTools</h3><ul>
<li>Performance 标签页分析帧率、渲染耗时</li>
<li>Network 标签页查看资源加载时间</li>
</ul>
<h3 id="5-2-Lighthouse-分析报告"><a href="#5-2-Lighthouse-分析报告" class="headerlink" title="5.2 Lighthouse 分析报告"></a>5.2 Lighthouse 分析报告</h3><p>Chrome 内置 Lighthouse 可评估页面性能、可访问性、SEO 等综合得分。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 也可用 CLI 工具</span></span><br><span class="line">npx lighthouse https://example.com --view</span><br></pre></td></tr></table></figure>
<h2 id="6-常见误区"><a href="#6-常见误区" class="headerlink" title="6. 常见误区"></a>6. 常见误区</h2><ul>
<li>滥用动画效果：可能导致掉帧</li>
<li>未开启压缩打包：体积大，加载慢</li>
<li>忽视移动端网络环境：过大资源拖慢加载</li>
</ul>
<h2 id="7-结语"><a href="#7-结语" class="headerlink" title="7. 结语"></a>7. 结语</h2><p>性能优化其实并不神秘，它更像是日常开发中的一项好习惯。哪怕只优化一两项，也足以让页面加载快上一截。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weifo.github.io/2024/08/12/frontendTest/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weifo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="weifo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/08/12/frontendTest/" itemprop="url">前端测试：从单元测试到端到端测试的全面指南</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-08-12T12:00:12+08:00">
                2024-08-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端测试/" itemprop="url" rel="index">
                    <span itemprop="name">前端测试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>前端开发不仅仅是页面的编写和功能的实现，测试同样是不可忽视的重要环节。一套完整的测试体系能够帮助我们在快速迭代中保障质量，避免 Bug 重复出现。本文将用通俗易懂的语言，带你了解前端测试的核心知识：单元测试、组件测试、集成测试和端到端测试，并通过代码示例让你轻松上手。</p>
<h2 id="1-为什么需要前端测试？"><a href="#1-为什么需要前端测试？" class="headerlink" title="1. 为什么需要前端测试？"></a>1. 为什么需要前端测试？</h2><p>测试的目标不是证明程序没有错误，而是尽早发现错误并降低修复成本。尤其是在多人协作和持续集成（CI）环境中，自动化测试可以极大地提高开发效率和代码稳定性。</p>
<p><strong>常见的问题场景：</strong></p>
<ul>
<li>某个按钮突然失效？</li>
<li>页面改动影响了其他组件？</li>
<li>重构之后页面一片空白？</li>
</ul>
<p>这些问题都可以通过合适的测试手段在上线前发现。</p>
<h2 id="2-单元测试（Unit-Testing）"><a href="#2-单元测试（Unit-Testing）" class="headerlink" title="2. 单元测试（Unit Testing）"></a>2. 单元测试（Unit Testing）</h2><p>单元测试是测试最小功能单元，比如一个函数的输出是否正确。</p>
<h3 id="工具推荐：Jest"><a href="#工具推荐：Jest" class="headerlink" title="工具推荐：Jest"></a>工具推荐：Jest</h3><h3 id="示例：测试一个格式化函数"><a href="#示例：测试一个格式化函数" class="headerlink" title="示例：测试一个格式化函数"></a>示例：测试一个格式化函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils/format.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">formatPrice</span>(<span class="params">price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`$<span class="subst">$&#123;price.toFixed(<span class="number">2</span>)&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// __tests__/format.test.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; formatPrice &#125; <span class="keyword">from</span> <span class="string">'../utils/format'</span>;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'formats price correctly'</span>, () =&gt; &#123;</span><br><span class="line">  expect(formatPrice(<span class="number">5</span>)).toBe(<span class="string">'$5.00'</span>);</span><br><span class="line">  expect(formatPrice(<span class="number">5.1</span>)).toBe(<span class="string">'$5.10'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="3-组件测试（Component-Testing）"><a href="#3-组件测试（Component-Testing）" class="headerlink" title="3. 组件测试（Component Testing）"></a>3. 组件测试（Component Testing）</h2><p>测试 Vue、React 等框架中的组件是否能正确渲染、响应交互。</p>
<h3 id="工具推荐：React-Testing-Library-Vue-Test-Utils"><a href="#工具推荐：React-Testing-Library-Vue-Test-Utils" class="headerlink" title="工具推荐：React Testing Library / Vue Test Utils"></a>工具推荐：React Testing Library / Vue Test Utils</h3><h3 id="示例：测试-React-组件按钮点击"><a href="#示例：测试-React-组件按钮点击" class="headerlink" title="示例：测试 React 组件按钮点击"></a>示例：测试 React 组件按钮点击</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Button.jsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Button</span>(<span class="params">&#123; onClick &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onClick&#125;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Button.test.jsx</span></span><br><span class="line"><span class="keyword">import</span> &#123; render, fireEvent &#125; <span class="keyword">from</span> <span class="string">'@testing-library/react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">'./Button'</span>;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'button calls onClick when clicked'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> handleClick = jest.fn();</span><br><span class="line">  <span class="keyword">const</span> &#123; getByText &#125; = render(<span class="xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span> /&gt;</span></span>);</span><br><span class="line">  fireEvent.click(getByText(<span class="string">'Click Me'</span>));</span><br><span class="line">  expect(handleClick).toHaveBeenCalled();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="4-集成测试（Integration-Testing）"><a href="#4-集成测试（Integration-Testing）" class="headerlink" title="4. 集成测试（Integration Testing）"></a>4. 集成测试（Integration Testing）</h2><p>测试多个组件或模块组合后的整体行为是否符合预期。</p>
<p>比如一个表单是否能完整地填写并提交：</p>
<ul>
<li>用户输入内容</li>
<li>点击提交按钮</li>
<li>是否触发正确的回调或 API 请求</li>
</ul>
<p><strong>建议使用组件测试库模拟用户行为</strong>，不需要测试具体实现，而是关注行为：输入、点击、跳转等。</p>
<h2 id="5-端到端测试（E2E-Testing）"><a href="#5-端到端测试（E2E-Testing）" class="headerlink" title="5. 端到端测试（E2E Testing）"></a>5. 端到端测试（E2E Testing）</h2><p>端到端测试关注整个系统的行为：从用户打开页面、执行操作，到看到期望的结果。</p>
<h3 id="工具推荐：Playwright-Cypress"><a href="#工具推荐：Playwright-Cypress" class="headerlink" title="工具推荐：Playwright / Cypress"></a>工具推荐：Playwright / Cypress</h3><h3 id="示例：使用-Playwright-进行登录流程测试"><a href="#示例：使用-Playwright-进行登录流程测试" class="headerlink" title="示例：使用 Playwright 进行登录流程测试"></a>示例：使用 Playwright 进行登录流程测试</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// login.spec.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; test, expect &#125; <span class="keyword">from</span> <span class="string">'@playwright/test'</span>;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'user can login'</span>, <span class="keyword">async</span> (&#123; page &#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> page.goto(<span class="string">'https://example.com/login'</span>);</span><br><span class="line">  <span class="keyword">await</span> page.fill(<span class="string">'#username'</span>, <span class="string">'testuser'</span>);</span><br><span class="line">  <span class="keyword">await</span> page.fill(<span class="string">'#password'</span>, <span class="string">'password123'</span>);</span><br><span class="line">  <span class="keyword">await</span> page.click(<span class="string">'button[type=submit]'</span>);</span><br><span class="line">  <span class="keyword">await</span> expect(page.locator(<span class="string">'text=Welcome'</span>)).toBeVisible();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>E2E 测试适合关键路径验证，例如登录、下单、支付等。虽然写起来比单元测试慢，但它覆盖的是整个真实用户的行为路径，非常有价值。</p>
<h2 id="6-测试策略建议"><a href="#6-测试策略建议" class="headerlink" title="6. 测试策略建议"></a>6. 测试策略建议</h2><p>一个成熟项目中，应包含以下几种测试：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>目的</th>
<th>工具推荐</th>
</tr>
</thead>
<tbody>
<tr>
<td>单元测试</td>
<td>验证函数逻辑正确性</td>
<td>Jest</td>
</tr>
<tr>
<td>组件测试</td>
<td>检查组件行为与 UI 渲染</td>
<td>Testing Library / Vue Test Utils</td>
</tr>
<tr>
<td>集成测试</td>
<td>模块组合是否正常工作</td>
<td>RTL / Vue Test Utils</td>
</tr>
<tr>
<td>E2E 测试</td>
<td>用户端到端行为验证</td>
<td>Playwright / Cypress</td>
</tr>
</tbody>
</table>
<h2 id="7-写测试的小技巧"><a href="#7-写测试的小技巧" class="headerlink" title="7. 写测试的小技巧"></a>7. 写测试的小技巧</h2><ul>
<li>用行为驱动的方式写测试（以“用户会做什么”为主）</li>
<li>避免过度测试实现细节（容易因重构破坏）</li>
<li>测试名要清晰表述测试目的</li>
<li>每次提交前跑一次测试用例（通过 CI 或 pre-commit）</li>
</ul>
<h2 id="8-结语"><a href="#8-结语" class="headerlink" title="8. 结语"></a>8. 结语</h2><p>前端测试听起来可能有些枯燥，但它的确是保障应用质量的关键部分。你不需要一开始就覆盖所有测试类型，只要从最容易上手的单元测试开始，一步一步扩展，最终你会构建出一套坚实的测试体系。</p>
<p>测试就像给你的代码买了一份保险，一旦出问题，它会第一时间跳出来提醒你。长期来看，它能为你省下无数加班修 Bug 的夜晚。</p>
<p>希望这篇文章能帮你迈出前端测试的第一步。只要肯动手，你一定能写出既稳定又靠谱的前端项目。加油！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weifo.github.io/2024/07/22/microFrontend/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weifo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="weifo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/07/22/microFrontend/" itemprop="url">前端微前端架构：如何构建模块化 Web 应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-07-22T12:00:12+08:00">
                2024-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/微前端/" itemprop="url" rel="index">
                    <span itemprop="name">微前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>随着 Web 应用变得日益复杂，单一前端项目逐渐难以满足大型团队的开发和维护需求。微前端（Micro Frontends）作为一种新兴架构思想，借鉴微服务理念，将前端应用拆分为多个独立的子应用。本文将介绍微前端的基本原理、常用技术方案，并提供实践建议与代码示例。</p>
<h2 id="1-微前端概述"><a href="#1-微前端概述" class="headerlink" title="1. 微前端概述"></a>1. 微前端概述</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>微前端是一种架构模式，将一个大型 Web 应用拆分成多个独立的子应用，每个子应用可以独立开发、测试和部署。</p>
<h3 id="1-2-优势"><a href="#1-2-优势" class="headerlink" title="1.2 优势"></a>1.2 优势</h3><ul>
<li><strong>独立部署</strong>：每个子应用可单独发布，不影响其他模块。</li>
<li><strong>技术栈自由</strong>：子应用可以使用不同的前端框架。</li>
<li><strong>团队协作优化</strong>：不同团队可并行开发各自负责的模块。</li>
</ul>
<h2 id="2-主流实现方案"><a href="#2-主流实现方案" class="headerlink" title="2. 主流实现方案"></a>2. 主流实现方案</h2><h3 id="2-1-基于-iframe"><a href="#2-1-基于-iframe" class="headerlink" title="2.1 基于 iframe"></a>2.1 基于 iframe</h3><p>每个子应用嵌入在 iframe 中，优点是隔离性强，但缺点是通信复杂、SEO 不友好。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://subapp.example.com"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-JavaScript-集成（single-spa）"><a href="#2-2-JavaScript-集成（single-spa）" class="headerlink" title="2.2 JavaScript 集成（single-spa）"></a>2.2 JavaScript 集成（single-spa）</h3><p><a href="https://single-spa.js.org/" target="_blank" rel="noopener">single-spa</a> 是目前最流行的微前端框架之一。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install single-spa --save</span><br></pre></td></tr></table></figure>
<h4 id="注册子应用"><a href="#注册子应用" class="headerlink" title="注册子应用"></a>注册子应用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; registerApplication, start &#125; <span class="keyword">from</span> <span class="string">'single-spa'</span>;</span><br><span class="line"></span><br><span class="line">registerApplication(&#123;</span><br><span class="line">  name: <span class="string">'nav'</span>,</span><br><span class="line">  app: <span class="function"><span class="params">()</span> =&gt;</span> System.import(<span class="string">'nav'</span>),</span><br><span class="line">  activeWhen: [<span class="string">'/'</span>]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">start();</span><br></pre></td></tr></table></figure>
<h3 id="2-3-基于模块联邦（Module-Federation）"><a href="#2-3-基于模块联邦（Module-Federation）" class="headerlink" title="2.3 基于模块联邦（Module Federation）"></a>2.3 基于模块联邦（Module Federation）</h3><p>Webpack 5 的 Module Federation 插件允许多个应用共享模块。</p>
<h4 id="主应用配置"><a href="#主应用配置" class="headerlink" title="主应用配置"></a>主应用配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> ModuleFederationPlugin(&#123;</span><br><span class="line">    remotes: &#123;</span><br><span class="line">      app1: <span class="string">'app1@http://localhost:3001/remoteEntry.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="子应用导出模块"><a href="#子应用导出模块" class="headerlink" title="子应用导出模块"></a>子应用导出模块</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> ModuleFederationPlugin(&#123;</span><br><span class="line">    name: <span class="string">'app1'</span>,</span><br><span class="line">    filename: <span class="string">'remoteEntry.js'</span>,</span><br><span class="line">    exposes: &#123;</span><br><span class="line">      <span class="string">'./Button'</span>: <span class="string">'./src/components/Button.vue'</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="3-微前端中的通信机制"><a href="#3-微前端中的通信机制" class="headerlink" title="3. 微前端中的通信机制"></a>3. 微前端中的通信机制</h2><h3 id="3-1-URL-参数或-Hash"><a href="#3-1-URL-参数或-Hash" class="headerlink" title="3.1 URL 参数或 Hash"></a>3.1 URL 参数或 Hash</h3><p>适合简单场景，如状态同步。</p>
<h3 id="3-2-自定义事件（CustomEvent）"><a href="#3-2-自定义事件（CustomEvent）" class="headerlink" title="3.2 自定义事件（CustomEvent）"></a>3.2 自定义事件（CustomEvent）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.dispatchEvent(<span class="keyword">new</span> CustomEvent(<span class="string">'user:login'</span>, &#123; <span class="attr">detail</span>: &#123; <span class="attr">userId</span>: <span class="number">123</span> &#125; &#125;));</span><br></pre></td></tr></table></figure>
<h3 id="3-3-全局状态管理（如-Redux-或-pinia）"><a href="#3-3-全局状态管理（如-Redux-或-pinia）" class="headerlink" title="3.3 全局状态管理（如 Redux 或 pinia）"></a>3.3 全局状态管理（如 Redux 或 pinia）</h3><p>推荐使用共享状态库进行统一管理。</p>
<h2 id="4-实践建议"><a href="#4-实践建议" class="headerlink" title="4. 实践建议"></a>4. 实践建议</h2><ul>
<li>尽量统一子应用的公共依赖，如 React、Vue 版本。</li>
<li>使用主应用加载子应用的样式，避免样式污染。</li>
<li>为子应用设定加载超时处理，提升用户体验。</li>
</ul>
<h2 id="5-结语"><a href="#5-结语" class="headerlink" title="5. 结语"></a>5. 结语</h2><p>微前端不是银弹，但它为大型应用的可扩展性、团队协作与技术多样性提供了坚实基础。通过合理拆分模块、选择合适的集成方式，并建立良好的通信机制，可以让团队在保障独立性的同时实现统一的用户体验。</p>
<p>当然，引入微前端也意味着增加架构复杂性，因此需要根据团队规模和项目需求权衡使用。未来的前端开发，注定会是组件化和服务化的结合体。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weifo.github.io/2024/07/14/web-security/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weifo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="weifo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/07/14/web-security/" itemprop="url">Web安全：前端开发者必须掌握的安全防护措施</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-07-14T12:00:12+08:00">
                2024-07-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web安全/" itemprop="url" rel="index">
                    <span itemprop="name">Web安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>Web安全是前端开发中不可忽视的重要本文将介绍前端开发者必须掌握的安全防护措施，并提供代码示例，帮助开发者提升 Web 应用的安全性。</p>
<h2 id="1-防范-XSS（跨站脚本攻击）"><a href="#1-防范-XSS（跨站脚本攻击）" class="headerlink" title="1. 防范 XSS（跨站脚本攻击）"></a>1. 防范 XSS（跨站脚本攻击）</h2><p>XSS（Cross-Site Scripting）攻击是指攻击者在网页中注入恶意脚本，影响用户。</p>
<h3 id="1-1-输入验证和输出编码"><a href="#1-1-输入验证和输出编码" class="headerlink" title="1.1 输入验证和输出编码"></a>1.1 输入验证和输出编码</h3><p><strong>错误示例（未处理用户输入）</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"output"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> params = <span class="keyword">new</span> URLSearchParams(<span class="built_in">window</span>.location.search);</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">"output"</span>).innerHTML = params.get(<span class="string">"name"</span>); <span class="comment">// XSS 风险！</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>正确示例（使用 <code>textContent</code> 进行转义）</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"output"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> params = <span class="keyword">new</span> URLSearchParams(<span class="built_in">window</span>.location.search);</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">"output"</span>).textContent = params.get(<span class="string">"name"</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="1-2-使用-CSP（内容安全策略）"><a href="#1-2-使用-CSP（内容安全策略）" class="headerlink" title="1.2 使用 CSP（内容安全策略）"></a>1.2 使用 CSP（内容安全策略）</h3><p>CSP 可以有效防止 XSS 攻击。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"default-src 'self'; script-src 'self' https://trusted.com"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-防范-CSRF（跨站请求伪造）"><a href="#2-防范-CSRF（跨站请求伪造）" class="headerlink" title="2. 防范 CSRF（跨站请求伪造）"></a>2. 防范 CSRF（跨站请求伪造）</h2><p>CSRF（Cross-Site Request Forgery）攻击是指攻击者伪造用户请求执行恶意操作。</p>
<h3 id="2-1-使用-CSRF-令牌"><a href="#2-1-使用-CSRF-令牌" class="headerlink" title="2.1 使用 CSRF 令牌"></a>2.1 使用 CSRF 令牌</h3><p>在请求中加入 CSRF 令牌，确保请求来源合法。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"csrf_token"</span> <span class="attr">value</span>=<span class="string">"&#123;&#123; csrf_token &#125;&#125;"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-限制跨域请求"><a href="#2-2-限制跨域请求" class="headerlink" title="2.2 限制跨域请求"></a>2.2 限制跨域请求</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span>: same-origin</span><br></pre></td></tr></table></figure>
<h2 id="3-防止点击劫持（Clickjacking）"><a href="#3-防止点击劫持（Clickjacking）" class="headerlink" title="3. 防止点击劫持（Clickjacking）"></a>3. 防止点击劫持（Clickjacking）</h2><p>Clickjacking 是通过隐藏的 <code>iframe</code> 诱骗用户点击恶意链接。</p>
<h3 id="3-1-禁止-iframe-嵌套"><a href="#3-1-禁止-iframe-嵌套" class="headerlink" title="3.1 禁止 iframe 嵌套"></a>3.1 禁止 <code>iframe</code> 嵌套</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">X-Frame-Options</span>: DENY</span><br></pre></td></tr></table></figure>
<h3 id="3-2-使用-CSP-规则"><a href="#3-2-使用-CSP-规则" class="headerlink" title="3.2 使用 CSP 规则"></a>3.2 使用 CSP 规则</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: frame-ancestors 'none';</span><br></pre></td></tr></table></figure>
<h2 id="4-数据安全与存储保护"><a href="#4-数据安全与存储保护" class="headerlink" title="4. 数据安全与存储保护"></a>4. 数据安全与存储保护</h2><h3 id="4-1-避免在前端存储敏感信息"><a href="#4-1-避免在前端存储敏感信息" class="headerlink" title="4.1 避免在前端存储敏感信息"></a>4.1 避免在前端存储敏感信息</h3><p><strong>错误示例（在 localStorage 存储密码）</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">"password"</span>, <span class="string">"123456"</span>); <span class="comment">// ❌ 高风险！</span></span><br></pre></td></tr></table></figure></p>
<p><strong>正确示例（仅存储 Token，敏感数据存后端）</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">"authToken"</span>, token);</span><br></pre></td></tr></table></figure></p>
<h3 id="4-2-使用-HTTPS-加密传输"><a href="#4-2-使用-HTTPS-加密传输" class="headerlink" title="4.2 使用 HTTPS 加密传输"></a>4.2 使用 HTTPS 加密传输</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Strict-Transport-Security</span>: max-age=31536000; includeSubDomains; preload</span><br></pre></td></tr></table></figure>
<h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><p>前端开发者应掌握 XSS、CSRF、Clickjacking 等安全攻击的防范措施，并通过 CSP、CSRF 令牌、X-Frame-Options 等安全策略来提高 Web 应用的安全性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weifo.github.io/2024/06/24/vue3Features/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weifo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="weifo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/06/24/vue3Features/" itemprop="url">Vue 3 新特性与最佳实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-06-24T12:00:12+08:00">
                2024-06-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue3/" itemprop="url" rel="index">
                    <span itemprop="name">Vue3</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>Vue3 作为 Vue.js 的重大升级，带来了 Composition API、Teleport、Fragments、Suspense 等一系列新特性。本文将详细介绍 Vue 3 的新特性，并结合代码示例，帮助开发者更高效地构建 Vue 应用。</p>
<h2 id="1-Composition-API"><a href="#1-Composition-API" class="headerlink" title="1. Composition API"></a>1. Composition API</h2><p>Vue 3 引入了 Composition API，使代码更具可复用性和可读性。</p>
<h3 id="1-1-setup-函数"><a href="#1-1-setup-函数" class="headerlink" title="1.1 setup 函数"></a>1.1 <code>setup</code> 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &apos;vue&apos;;</span><br><span class="line"></span><br><span class="line">const count = ref(0);</span><br><span class="line">const increment = () =&gt; &#123;</span><br><span class="line">  count.value++;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;increment&quot;&gt;Count: &#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-reactive-vs-ref"><a href="#1-2-reactive-vs-ref" class="headerlink" title="1.2 reactive vs ref"></a>1.2 <code>reactive</code> vs <code>ref</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, reactive &#125; from &apos;vue&apos;;</span><br><span class="line"></span><br><span class="line">const count = ref(0);</span><br><span class="line">const state = reactive(&#123; count: 0 &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-如何组织逻辑代码"><a href="#1-3-如何组织逻辑代码" class="headerlink" title="1.3 如何组织逻辑代码"></a>1.3 如何组织逻辑代码</h3><p>使用 Composition API 可以将不同的逻辑抽离为独立的函数模块，例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useCounter.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count = ref(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> increment = <span class="function"><span class="params">()</span> =&gt;</span> count.value++;</span><br><span class="line">  <span class="keyword">return</span> &#123; count, increment &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; useCounter &#125; from &apos;./useCounter&apos;;</span><br><span class="line"></span><br><span class="line">const &#123; count, increment &#125; = useCounter();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;increment&quot;&gt;Count: &#123;&#123; count &#125;&#125;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-Teleport-组件"><a href="#2-Teleport-组件" class="headerlink" title="2. Teleport 组件"></a>2. <code>Teleport</code> 组件</h2><p><code>Teleport</code> 允许将子组件渲染到 DOM 的其他位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;teleport to=&quot;body&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;modal&quot;&gt;This is a modal&lt;/div&gt;</span><br><span class="line">  &lt;/teleport&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>弹窗（Modal）</li>
<li>提示框（Tooltip）</li>
<li>全局层级组件（如 Loading Spinner）</li>
</ul>
<h2 id="3-Suspense-组件"><a href="#3-Suspense-组件" class="headerlink" title="3. Suspense 组件"></a>3. <code>Suspense</code> 组件</h2><p>用于异步组件的加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Suspense&gt;</span><br><span class="line">    &lt;template #default&gt;</span><br><span class="line">      &lt;AsyncComponent /&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;template #fallback&gt;</span><br><span class="line">      Loading...</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/Suspense&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>只适用于 <code>&lt;script setup&gt;</code> 或函数式组件中的异步组件</li>
<li><code>Suspense</code> 的 fallback 不应太复杂，以避免性能问题</li>
</ul>
<h2 id="4-Fragments-组件"><a href="#4-Fragments-组件" class="headerlink" title="4. Fragments 组件"></a>4. <code>Fragments</code> 组件</h2><p>支持多个根节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;h1&gt;Title&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;Paragraph&lt;/p&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<h3 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h3><p>Fragments 是编译器层面支持，最终仍会转成普通元素包裹，因此对样式布局基本无影响。</p>
<h2 id="5-其他增强"><a href="#5-其他增强" class="headerlink" title="5. 其他增强"></a>5. 其他增强</h2><h3 id="更快的虚拟-DOM"><a href="#更快的虚拟-DOM" class="headerlink" title="更快的虚拟 DOM"></a>更快的虚拟 DOM</h3><p>Vue 3 在底层对 Virtual DOM 进行了重写，整体性能提升约 1.5~2 倍。</p>
<h3 id="更好的-TypeScript-支持"><a href="#更好的-TypeScript-支持" class="headerlink" title="更好的 TypeScript 支持"></a>更好的 TypeScript 支持</h3><p>Vue 3 完全用 TypeScript 重写，支持 IDE 自动提示和类型推导，更适合大型项目。</p>
<h3 id="更轻量的打包体积"><a href="#更轻量的打包体积" class="headerlink" title="更轻量的打包体积"></a>更轻量的打包体积</h3><p>Tree-shaking 支持让 Vue 3 的打包更小，更精简。</p>
<h2 id="6-结论"><a href="#6-结论" class="headerlink" title="6. 结论"></a>6. 结论</h2><p>Vue 3 通过 Composition API、Teleport、Suspense 等特性提升了代码组织能力和性能。掌握这些新特性，将让你的 Vue 开发更加高效。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weifo.github.io/2024/06/14/fontend-performance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weifo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="weifo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/06/14/fontend-performance/" itemprop="url">前端性能优化：提升 Web 应用速度的关键策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-06-14T12:00:12+08:00">
                2024-06-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/性能优化/" itemprop="url" rel="index">
                    <span itemprop="name">性能优化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>前端性能优化是提升用户体验、减少加载时间和提高转化率的关键环节。本文将深入探讨优化 Web 应用性能的核心策略，并提供相应的代码示例。</p>
<h2 id="1-资源优化"><a href="#1-资源优化" class="headerlink" title="1. 资源优化"></a>1. 资源优化</h2><h3 id="1-1-代码分割（Code-Splitting）"><a href="#1-1-代码分割（Code-Splitting）" class="headerlink" title="1.1 代码分割（Code Splitting）"></a>1.1 代码分割（Code Splitting）</h3><p>代码分割可以减少首屏加载时间，按需加载所需的代码。</p>
<h4 id="在-React-中使用动态导入"><a href="#在-React-中使用动态导入" class="headerlink" title="在 React 中使用动态导入"></a>在 React 中使用动态导入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Suspense, lazy &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">const HeavyComponent = lazy(() =&gt; import(&apos;./HeavyComponent&apos;));</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line">      &lt;HeavyComponent /&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>
<h4 id="在-Webpack-中配置代码分割"><a href="#在-Webpack-中配置代码分割" class="headerlink" title="在 Webpack 中配置代码分割"></a>在 Webpack 中配置代码分割</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'all'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-压缩-JavaScript-和-CSS"><a href="#1-2-压缩-JavaScript-和-CSS" class="headerlink" title="1.2 压缩 JavaScript 和 CSS"></a>1.2 压缩 JavaScript 和 CSS</h3><p>使用工具如 Terser、CSSNano 进行代码压缩，以减少传输大小。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install terser cssnano --save-dev</span><br></pre></td></tr></table></figure>
<h3 id="1-3-资源懒加载（Lazy-Loading）"><a href="#1-3-资源懒加载（Lazy-Loading）" class="headerlink" title="1.3 资源懒加载（Lazy Loading）"></a>1.3 资源懒加载（Lazy Loading）</h3><p>在图片加载时使用 <code>loading=&quot;lazy&quot;</code> 进行懒加载。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image.jpg"</span> <span class="attr">loading</span>=<span class="string">"lazy"</span> <span class="attr">alt</span>=<span class="string">"Lazy Loaded Image"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-网络优化"><a href="#2-网络优化" class="headerlink" title="2. 网络优化"></a>2. 网络优化</h2><h3 id="2-1-启用-HTTP-2-或-HTTP-3"><a href="#2-1-启用-HTTP-2-或-HTTP-3" class="headerlink" title="2.1 启用 HTTP/2 或 HTTP/3"></a>2.1 启用 HTTP/2 或 HTTP/3</h3><p>HTTP/2 和 HTTP/3 可以显著提升资源加载速度。确保服务器支持这些协议。</p>
<h3 id="2-2-预加载和预获取资源"><a href="#2-2-预加载和预获取资源" class="headerlink" title="2.2 预加载和预获取资源"></a>2.2 预加载和预获取资源</h3><ul>
<li><code>preload</code> 适用于关键资源，如字体或脚本。</li>
<li><code>prefetch</code> 用于提前加载未来可能使用的资源。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"styles.css"</span> <span class="attr">as</span>=<span class="string">"style"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prefetch"</span> <span class="attr">href</span>=<span class="string">"next-page.js"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-使用-Service-Worker-进行缓存"><a href="#2-3-使用-Service-Worker-进行缓存" class="headerlink" title="2.3 使用 Service Worker 进行缓存"></a>2.3 使用 Service Worker 进行缓存</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, (event) =&gt; &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> response || fetch(event.request);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="3-渲染优化"><a href="#3-渲染优化" class="headerlink" title="3. 渲染优化"></a>3. 渲染优化</h2><h3 id="3-1-避免不必要的重排（Reflow）和重绘（Repaint）"><a href="#3-1-避免不必要的重排（Reflow）和重绘（Repaint）" class="headerlink" title="3.1 避免不必要的重排（Reflow）和重绘（Repaint）"></a>3.1 避免不必要的重排（Reflow）和重绘（Repaint）</h3><p>尽量减少 DOM 操作，并使用 <code>requestAnimationFrame</code> 进行动画。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">requestAnimationFrame(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  element.style.transform = <span class="string">'translateX(100px)'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="3-2-使用-Virtual-DOM（React）"><a href="#3-2-使用-Virtual-DOM（React）" class="headerlink" title="3.2 使用 Virtual DOM（React）"></a>3.2 使用 Virtual DOM（React）</h3><p>React 内部优化了 DOM 操作，使用 <code>useMemo</code> 和 <code>useCallback</code> 进行优化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(data), [data]);</span><br></pre></td></tr></table></figure>
<h3 id="3-3-服务器端渲染（SSR）"><a href="#3-3-服务器端渲染（SSR）" class="headerlink" title="3.3 服务器端渲染（SSR）"></a>3.3 服务器端渲染（SSR）</h3><p>使用 Next.js 进行服务器端渲染，加快首屏加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export async function getServerSideProps() &#123;</span><br><span class="line">  const data = await fetchData();</span><br><span class="line">  return &#123; props: &#123; data &#125; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a>4. 结论</h2><p>通过代码分割、懒加载、网络优化和渲染优化等手段，可以显著提升 Web 应用的性能。合理使用这些优化策略，将让你的 Web 应用运行得更快，提供更好的用户体验。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weifo.github.io/2024/05/18/typescriptTips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weifo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="weifo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/05/18/typescriptTips/" itemprop="url">TypeScript 在前端项目中的最佳实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-05-18T12:00:12+08:00">
                2024-05-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TypeScript/" itemprop="url" rel="index">
                    <span itemprop="name">TypeScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>TypeScript（TS）已经成为现代前端开发的首选语言之一，它提供了强类型检查、增强的代码可读性以及更好的工具支持。本文将介绍 TypeScript 在前端项目中的最佳实践，并提供相应的代码示例，帮助开发者更高效地编写可维护的代码。</p>
<h2 id="1-TypeScript-的优势"><a href="#1-TypeScript-的优势" class="headerlink" title="1. TypeScript 的优势"></a>1. TypeScript 的优势</h2><ul>
<li><strong>静态类型检查</strong>：在编译阶段捕获错误，减少运行时错误。</li>
<li><strong>更好的代码提示</strong>：借助 IDE（如 VS Code），提供智能补全和类型推导。</li>
<li><strong>更强的可维护性</strong>：强类型系统让代码更加可读，降低 bug 率。</li>
<li><strong>良好的 JavaScript 兼容性</strong>：可以逐步引入 TypeScript，不影响现有 JavaScript 代码。</li>
</ul>
<h2 id="2-TypeScript-基本语法"><a href="#2-TypeScript-基本语法" class="headerlink" title="2. TypeScript 基本语法"></a>2. TypeScript 基本语法</h2><h3 id="2-1-类型注解"><a href="#2-1-类型注解" class="headerlink" title="2.1 类型注解"></a>2.1 类型注解</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message: <span class="built_in">string</span> = <span class="string">"Hello, TypeScript!"</span>;</span><br><span class="line"><span class="keyword">let</span> count: <span class="built_in">number</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-接口（Interface）"><a href="#2-2-接口（Interface）" class="headerlink" title="2.2 接口（Interface）"></a>2.2 接口（Interface）</h3><p>接口用于定义对象的结构，有助于提高代码的可维护性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>; <span class="comment">// 可选属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user: User = &#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  name: <span class="string">"Alice"</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-类型别名（Type-Alias）"><a href="#2-3-类型别名（Type-Alias）" class="headerlink" title="2.3 类型别名（Type Alias）"></a>2.3 类型别名（Type Alias）</h3><p>类型别名与接口类似，但可以用于更复杂的类型组合。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ID = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> Status = <span class="string">"active"</span> | <span class="string">"inactive"</span> | <span class="string">"banned"</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-泛型（Generics）"><a href="#2-4-泛型（Generics）" class="headerlink" title="2.4 泛型（Generics）"></a>2.4 泛型（Generics）</h3><p>泛型提供了更强的类型复用能力。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> output = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="3-TypeScript-在-React-项目中的应用"><a href="#3-TypeScript-在-React-项目中的应用" class="headerlink" title="3. TypeScript 在 React 项目中的应用"></a>3. TypeScript 在 React 项目中的应用</h2><h3 id="3-1-使用-Props-和-State"><a href="#3-1-使用-Props-和-State" class="headerlink" title="3.1 使用 Props 和 State"></a>3.1 使用 <code>Props</code> 和 <code>State</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type ButtonProps = &#123;</span><br><span class="line">  label: string;</span><br><span class="line">  onClick: () =&gt; void;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const Button: React.FC&lt;ButtonProps&gt; = (&#123; label, onClick &#125;) =&gt; &#123;</span><br><span class="line">  return &lt;button onClick=&#123;onClick&#125;&gt;&#123;label&#125;&lt;/button&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-使用-useState-和-useEffect"><a href="#3-2-使用-useState-和-useEffect" class="headerlink" title="3.2 使用 useState 和 useEffect"></a>3.2 使用 <code>useState</code> 和 <code>useEffect</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState, useEffect &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const Counter = () =&gt; &#123;</span><br><span class="line">  const [count, setCount] = useState&lt;number&gt;(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    document.title = `Count: $&#123;count&#125;`;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;Count: &#123;count&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Increment&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="4-TypeScript-在-Vue-3-项目中的应用"><a href="#4-TypeScript-在-Vue-3-项目中的应用" class="headerlink" title="4. TypeScript 在 Vue 3 项目中的应用"></a>4. TypeScript 在 Vue 3 项目中的应用</h2><p>Vue 3 完全支持 TypeScript，结合 <code>defineProps</code> 和 <code>defineEmits</code> 使得开发更加类型安全。</p>
<h3 id="4-1-Vue-组件使用-TypeScript"><a href="#4-1-Vue-组件使用-TypeScript" class="headerlink" title="4.1 Vue 组件使用 TypeScript"></a>4.1 Vue 组件使用 TypeScript</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">type Props = &#123;</span><br><span class="line">  message: string;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">defineProps&lt;Props&gt;();</span><br><span class="line"></span><br><span class="line">const count = ref&lt;number&gt;(0);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Count: &#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;count++&quot;&gt;Increment&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<h2 id="5-TypeScript-最佳实践"><a href="#5-TypeScript-最佳实践" class="headerlink" title="5. TypeScript 最佳实践"></a>5. TypeScript 最佳实践</h2><h3 id="5-1-启用严格模式"><a href="#5-1-启用严格模式" class="headerlink" title="5.1 启用严格模式"></a>5.1 启用严格模式</h3><p>在 <code>tsconfig.json</code> 中启用严格模式，以确保类型安全。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"strict"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"noImplicitAny"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"strictNullChecks"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-避免使用-any"><a href="#5-2-避免使用-any" class="headerlink" title="5.2 避免使用 any"></a>5.2 避免使用 <code>any</code></h3><p>使用 <code>any</code> 可能会导致类型安全性降低，推荐使用 <code>unknown</code> 或更具体的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processInput</span>(<span class="params">input: unknown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> input === <span class="string">"string"</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(input.toUpperCase());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-使用-Readonly-保护数据"><a href="#5-3-使用-Readonly-保护数据" class="headerlink" title="5.3 使用 Readonly 保护数据"></a>5.3 使用 <code>Readonly</code> 保护数据</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Config &#123;</span><br><span class="line">  readonly apiUrl: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config: Config = &#123; apiUrl: <span class="string">"https://api.example.com"</span> &#125;;</span><br><span class="line"><span class="comment">// config.apiUrl = "https://new-api.com"; // ❌ 错误</span></span><br></pre></td></tr></table></figure>
<h3 id="5-4-使用-Record-构造对象类型"><a href="#5-4-使用-Record-构造对象类型" class="headerlink" title="5.4 使用 Record 构造对象类型"></a>5.4 使用 <code>Record</code> 构造对象类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Role = <span class="string">"admin"</span> | <span class="string">"user"</span>;</span><br><span class="line"><span class="keyword">const</span> permissions: Record&lt;Role, <span class="built_in">string</span>[]&gt; = &#123;</span><br><span class="line">  admin: [<span class="string">"read"</span>, <span class="string">"write"</span>, <span class="string">"delete"</span>],</span><br><span class="line">  user: [<span class="string">"read"</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="5-5-使用-Pick-和-Omit-进行类型裁剪"><a href="#5-5-使用-Pick-和-Omit-进行类型裁剪" class="headerlink" title="5.5 使用 Pick 和 Omit 进行类型裁剪"></a>5.5 使用 <code>Pick</code> 和 <code>Omit</code> 进行类型裁剪</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  email: <span class="built_in">string</span>;</span><br><span class="line">  password: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PublicUser = Omit&lt;User, <span class="string">"password"</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> UserCredentials = Pick&lt;User, <span class="string">"email"</span> | <span class="string">"password"</span>&gt;;</span><br></pre></td></tr></table></figure>
<h2 id="6-结论"><a href="#6-结论" class="headerlink" title="6. 结论"></a>6. 结论</h2><p>TypeScript 在前端开发中的应用越来越广泛，它提供了更好的类型安全性、代码维护性和开发体验。通过掌握 TypeScript 的核心概念，并在 React 和 Vue 项目中合理使用，可以显著提升项目的质量和可维护性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weifo.github.io/2024/05/12/react18Features/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weifo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="weifo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/05/12/react18Features/" itemprop="url">React 18 新特性与最佳实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-05-12T12:00:12+08:00">
                2024-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>React 18 是 React 生态中的一个重要版本，带来了许多优化和新特性，尤其是在并发渲染、自动批量更新和新的 Hooks 方面。本文将深入解析 React 18 的新功能，并提供实际代码示例，帮助开发者更好地利用这些特性。</p>
<h2 id="1-并发渲染（Concurrent-Rendering）"><a href="#1-并发渲染（Concurrent-Rendering）" class="headerlink" title="1. 并发渲染（Concurrent Rendering）"></a>1. 并发渲染（Concurrent Rendering）</h2><p>并发渲染是 React 18 最重要的更新之一，它使得 React 能够更好地调度 UI 更新，提高应用的流畅度。</p>
<h3 id="1-1-startTransition-API"><a href="#1-1-startTransition-API" class="headerlink" title="1.1 startTransition API"></a>1.1 <code>startTransition</code> API</h3><p><code>startTransition</code> 允许开发者将某些状态更新标记为“过渡”，从而避免阻塞关键 UI 更新。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, startTransition &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TransitionExample</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [text, setText] = useState(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> [searchResults, setSearchResults] = useState([]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    setText(e.target.value);</span><br><span class="line">    startTransition(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟搜索结果更新</span></span><br><span class="line">      setSearchResults(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(e.target.value));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input type=<span class="string">"text"</span> value=&#123;text&#125; onChange=&#123;handleChange&#125; /&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;searchResults.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (</span><br><span class="line">          &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-useDeferredValue"><a href="#1-2-useDeferredValue" class="headerlink" title="1.2 useDeferredValue"></a>1.2 <code>useDeferredValue</code></h3><p><code>useDeferredValue</code> 允许延迟计算某个状态，以防止界面卡顿。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useDeferredValue &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DeferredExample</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [text, setText] = useState(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> deferredText = useDeferredValue(text);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input type=<span class="string">"text"</span> value=&#123;text&#125; onChange=&#123;(e) =&gt; setText(e.target.value)&#125; /&gt;</span><br><span class="line">      &lt;p&gt;Deferred Value: &#123;deferredText&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-自动批量更新（Automatic-Batching）"><a href="#2-自动批量更新（Automatic-Batching）" class="headerlink" title="2. 自动批量更新（Automatic Batching）"></a>2. 自动批量更新（Automatic Batching）</h2><p>React 18 之前，React 只会在事件处理函数中进行批量更新，而在 <code>setTimeout</code>、<code>Promise</code> 或者 <code>fetch</code> 回调中，状态更新不会自动合并。但在 React 18 中，所有的状态更新都会被自动批量处理。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BatchingExample</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [text, setText] = useState(<span class="string">'Hello'</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(<span class="function">(<span class="params">c</span>) =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">      setText(<span class="string">'World'</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;Count: &#123;count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;Text: &#123;text&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-新的-React-Hook"><a href="#3-新的-React-Hook" class="headerlink" title="3. 新的 React Hook"></a>3. 新的 React Hook</h2><h3 id="3-1-useId"><a href="#3-1-useId" class="headerlink" title="3.1 useId"></a>3.1 <code>useId</code></h3><p><code>useId</code> 允许在无障碍（a11y）场景中生成唯一 ID。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useId &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Form</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = useId();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;label htmlFor=&#123;id&#125;&gt;Name: &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input id=&#123;id&#125; type="text" /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a>4. 结论</h2><p>React 18 带来了许多优化和新特性，使得开发更加高效。本文介绍了并发渲染、自动批量更新以及新 Hooks 的使用。希望这些示例能帮助你更好地理解和应用 React 18 的新特性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weifo.github.io/2024/05/03/vue3-composition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weifo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="weifo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/05/03/vue3-composition/" itemprop="url">Vue 3 深入解析：Composition API vs Options API</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-05-03T12:00:12+08:00">
                2024-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue3/" itemprop="url" rel="index">
                    <span itemprop="name">Vue3</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>Vue 3 引入了 Composition API，它与 Options API 在代码组织和逻辑复用上有很大不同。本篇文章将深入对比这两种 API，分析它们的优缺点，并通过代码示例展示如何在实际项目中应用它们。</p>
<h2 id="1-什么是-Options-API？"><a href="#1-什么是-Options-API？" class="headerlink" title="1. 什么是 Options API？"></a>1. 什么是 Options API？</h2><p>Options API 是 Vue 2 及 Vue 3 仍然支持的一种组件编写方式，它通过 <code>data</code>、<code>methods</code>、<code>computed</code> 和 <code>watch</code> 等选项组织代码。</p>
<h3 id="1-1-Options-API-示例"><a href="#1-1-Options-API-示例" class="headerlink" title="1.1 Options API 示例"></a>1.1 Options API 示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;计数器：&#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;increment&quot;&gt;增加&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      this.count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-Options-API-的优点"><a href="#1-2-Options-API-的优点" class="headerlink" title="1.2 Options API 的优点"></a>1.2 Options API 的优点</h3><ul>
<li>代码结构清晰，适合小型组件。</li>
<li>对 Vue 2 用户友好，迁移成本低。</li>
<li>逻辑通过选项（如 <code>data</code>、<code>methods</code>）组织，易于理解。</li>
</ul>
<h3 id="1-3-Options-API-的缺点"><a href="#1-3-Options-API-的缺点" class="headerlink" title="1.3 Options API 的缺点"></a>1.3 Options API 的缺点</h3><ul>
<li>逻辑复用不够灵活，通常需要 mixins 或 Vuex。</li>
<li>复杂组件中，逻辑分散在多个选项中，导致代码难以维护。</li>
</ul>
<h2 id="2-什么是-Composition-API？"><a href="#2-什么是-Composition-API？" class="headerlink" title="2. 什么是 Composition API？"></a>2. 什么是 Composition API？</h2><p>Composition API 允许开发者通过 <code>setup</code> 函数和 Vue 的内置 Hooks 来管理组件逻辑。</p>
<h3 id="2-1-Composition-API-示例"><a href="#2-1-Composition-API-示例" class="headerlink" title="2.1 Composition API 示例"></a>2.1 Composition API 示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;计数器：&#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;increment&quot;&gt;增加&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; ref &#125; from &apos;vue&apos;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const count = ref(0);</span><br><span class="line">    const increment = () =&gt; count.value++;</span><br><span class="line">    </span><br><span class="line">    return &#123; count, increment &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-Composition-API-的优点"><a href="#2-2-Composition-API-的优点" class="headerlink" title="2.2 Composition API 的优点"></a>2.2 Composition API 的优点</h3><ul>
<li>逻辑组织更加灵活，可复用性强。</li>
<li>适用于大型应用，逻辑集中在 <code>setup</code>，更易维护。</li>
<li>更好地支持 TypeScript。</li>
</ul>
<h3 id="2-3-Composition-API-的缺点"><a href="#2-3-Composition-API-的缺点" class="headerlink" title="2.3 Composition API 的缺点"></a>2.3 Composition API 的缺点</h3><ul>
<li>语法相对复杂，学习成本较高。</li>
<li>需要理解 <code>reactive</code>、<code>ref</code>、<code>computed</code> 等概念。</li>
</ul>
<h2 id="3-逻辑复用对比"><a href="#3-逻辑复用对比" class="headerlink" title="3. 逻辑复用对比"></a>3. 逻辑复用对比</h2><p>在 Options API 中，逻辑复用通常依赖 mixins，但 mixins 可能导致变量命名冲突。</p>
<h3 id="3-1-Options-API-的-mixins"><a href="#3-1-Options-API-的-mixins" class="headerlink" title="3.1 Options API 的 mixins"></a>3.1 Options API 的 mixins</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export const counterMixin = &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123; count: 0 &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      this.count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; counterMixin &#125; from &apos;./counterMixin&apos;;</span><br><span class="line">export default &#123;</span><br><span class="line">  mixins: [counterMixin]</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>在 Composition API 中，逻辑复用可以通过 Composable 函数来实现。</p>
<h3 id="3-2-Composition-API-的-Composable"><a href="#3-2-Composition-API-的-Composable" class="headerlink" title="3.2 Composition API 的 Composable"></a>3.2 Composition API 的 Composable</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useCounter.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> count = ref(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> increment = <span class="function"><span class="params">()</span> =&gt;</span> count.value++;</span><br><span class="line">  <span class="keyword">return</span> &#123; count, increment &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; useCounter &#125; from &apos;./useCounter&apos;;</span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    return useCounter();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="4-何时使用-Composition-API？"><a href="#4-何时使用-Composition-API？" class="headerlink" title="4. 何时使用 Composition API？"></a>4. 何时使用 Composition API？</h2><ul>
<li>需要高度复用逻辑的项目。</li>
<li>组件逻辑较复杂时。</li>
<li>使用 TypeScript 进行类型约束时。</li>
</ul>
<h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><p>Options API 适用于小型项目，而 Composition API 适用于大型项目。Vue 3 提供了更多的灵活性，使开发者可以根据需求选择最佳方式进行开发。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weifo.github.io/2022/05/05/keep-alive/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weifo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="weifo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/05/05/keep-alive/" itemprop="url">Vue Keep-alive中的钩子函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-05-05T08:06:00+08:00">
                2022-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>–</p>
<p>说到Vue的钩子函数，可能很多人只停留在一些很简单常用的钩子(<code>created</code>,<code>mounted</code>)，而且对于里面的区别，什么时候该用什么钩子，并没有仔细的去研究过，熟悉这些函数后对我们写逻辑时会更有帮助。下面就用代码示例简单介绍下这些钩子吧。</p>
<hr>
<h2 id="Vue-Router导航守卫："><a href="#Vue-Router导航守卫：" class="headerlink" title="Vue-Router导航守卫："></a>Vue-Router导航守卫：</h2><p>有的时候，我们需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。</p>
<p>为此我们有很多种方法可以植入路由的导航过程：<strong>全局的, 单个路由独享的, 或者组件级的</strong>,推荐优先阅读<a href="https://link.juejin.cn?target=https%3A%2F%2Frouter.vuejs.org%2Fzh%2Fguide%2Fadvanced%2Fnavigation-guards.html" title="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html" target="_blank" rel="noopener">路由文档</a></p>
<h3 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h3><p>vue-router全局有三个守卫：</p>
<ol>
<li>router.beforeEach 全局前置守卫 进入路由之前</li>
<li>router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用</li>
<li>router.afterEach 全局后置钩子 进入路由之后</li>
</ol>
<p><strong>使用方法</strong>：</p>
<pre><code>    // main.js 入口文件
    import router from &apos;./router&apos;; // 引入路由
    router.beforeEach((to, from, next) =&gt; { 
      next();
    });
    router.beforeResolve((to, from, next) =&gt; {
      next();
    });
    router.afterEach((to, from) =&gt; {
      console.log(&apos;afterEach 全局后置钩子&apos;);
    });
复制代码
</code></pre><h4 id="to-from-next-这三个参数："><a href="#to-from-next-这三个参数：" class="headerlink" title="to,from,next 这三个参数："></a>to,from,next 这三个参数：</h4><p>to和from是<strong>将要进入和将要离开的路由对象</strong>,路由对象指的是平时通过this.$route获取到的路由对象。</p>
<p><strong>next:Function</strong> 这个参数是个函数，且<strong>必须调用，否则不能进入路由</strong>(页面空白)。</p>
<ul>
<li><p>next() 进入该路由。</p>
</li>
<li><p>next(false): 取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)。</p>
</li>
<li><p>next 跳转新路由，当前的导航被中断，重新开始一个新的导航。</p>
<pre><code>  我们可以这样跳转：next(&apos;path地址&apos;)或者next({path:&apos;&apos;})或者next({name:&apos;&apos;})
  且允许设置诸如 replace: true、name: &apos;home&apos; 之类的选项
  以及你用在router-link或router.push的对象选项。
复制代码
</code></pre></li>
</ul>
<h3 id="路由独享守卫"><a href="#路由独享守卫" class="headerlink" title="路由独享守卫"></a>路由独享守卫</h3><p>如果你不想全局配置守卫的话，你可以为某些路由单独配置守卫：</p>
<pre><code>    const router = new VueRouter({
      routes: [
        {
          path: &apos;/foo&apos;,
          component: Foo,
          beforeEnter: (to, from, next) =&gt; { 
            // 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖
            // ...
          }
        }
      ]
    })
复制代码
</code></pre><h3 id="路由组件内的守卫："><a href="#路由组件内的守卫：" class="headerlink" title="路由组件内的守卫："></a>路由组件内的守卫：</h3><ol>
<li>beforeRouteEnter 进入路由前</li>
<li>beforeRouteUpdate (2.2) 路由复用同一个组件时</li>
<li>beforeRouteLeave 离开当前路由时</li>
</ol>
<p><strong>文档中的介绍：</strong></p>
<pre><code>  beforeRouteEnter (to, from, next) {
    // 在路由独享守卫后调用 不！能！获取组件实例 `this`，组件实例还没被创建
  },
  beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用 可以访问组件实例 `this`
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
  },
  beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用，可以访问组件实例 `this`
  }
复制代码
</code></pre><p><strong>beforeRouteEnter访问this</strong></p>
<p>因为钩子在组件实例还没被创建的时候调用，所以不能获取组件实例 <code>this</code>，可以通过传一个回调给<code>next</code>来访问组件实例 。</p>
<p>但是<strong>回调的执行时机在mounted后面</strong>,所以在我看来这里对this的访问意义不太大，可以放在<code>created</code>或者<code>mounted</code>里面。</p>
<pre><code>    beforeRouteEnter (to, from, next) {
    console.log(&apos;在路由独享守卫后调用&apos;);
      next(vm =&gt; {
        // 通过 `vm` 访问组件实例`this` 执行回调的时机在mounted后面，
      })
    }
复制代码
</code></pre><p><strong>beforeRouteLeave：</strong></p>
<p>导航离开该组件的对应路由时调用，我们用它来禁止用户离开，比如还未保存草稿，或者在用户离开前，将<code>setInterval</code>销毁，防止离开之后，定时器还在调用。</p>
<pre><code>    beforeRouteLeave (to, from , next) {
      if (文章保存) {
        next(); // 允许离开或者可以跳到别的路由 上面讲过了
      } else {
        next(false); // 取消离开
      }
    }
复制代码
</code></pre><h3 id="关于钩子的一些知识："><a href="#关于钩子的一些知识：" class="headerlink" title="关于钩子的一些知识："></a>关于钩子的一些知识：</h3><h4 id="路由钩子函数的错误捕获"><a href="#路由钩子函数的错误捕获" class="headerlink" title="路由钩子函数的错误捕获"></a>路由钩子函数的错误捕获</h4><p>如果我们在全局守卫/路由独享守卫/组件路由守卫的钩子函数中有错误，可以这样捕获：</p>
<pre><code>    router.onError(callback =&gt; { 
    // 2.4.0新增 并不常用，了解一下就可以了 
      console.log(callback, &apos;callback&apos;);
    });
复制代码
</code></pre><p>在路由文档中还有更多的<a href="https://link.juejin.cn?target=https%3A%2F%2Frouter.vuejs.org%2Fzh%2Fapi%2F%23router-%25E5%25AE%259E%25E4%25BE%258B%25E6%2596%25B9%25E6%25B3%2595" title="https://router.vuejs.org/zh/api/#router-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">实例方法</a>：动态添加路由等，有兴趣可以了解一下。</p>
<h4 id="跳转死循环，页面永远空白"><a href="#跳转死循环，页面永远空白" class="headerlink" title="跳转死循环，页面永远空白"></a>跳转死循环，页面永远空白</h4><p>我了解到的，很多人会碰到这个问题，来看一下这段伪代码：</p>
<pre><code>    router.beforeEach((to, from, next) =&gt; {
      if(登录){
         next()
      }else{
          next({ name: &apos;login&apos; }); 
      }
    });
复制代码
</code></pre><p>看逻辑貌似是对的，但是当我们跳转到<code>login</code>之后，因为此时还是未登录状态，所以会一直跳转到<code>login</code>然后死循环，页面一直是空白的，所以：我们需要把判断条件稍微改一下。</p>
<pre><code>    if(登录 || to.name === &apos;login&apos;){ next() } // 登录，或者将要前往login页面的时候，就允许进入路由
复制代码
</code></pre><h4 id="全局后置钩子的跳转："><a href="#全局后置钩子的跳转：" class="headerlink" title="全局后置钩子的跳转："></a>全局后置钩子的跳转：</h4><p>文档中提到因为router.afterEach不接受<code>next</code>函数所以也不会改变导航本身，意思就是只能当成一个钩子来使用，但是我自己在试的时候发现，我们可以通过这种形式来实现跳转：</p>
<pre><code>    // main.js 入口文件
    import router from &apos;./router&apos;; // 引入路由
    router.afterEach((to, from) =&gt; {
      if (未登录 &amp;&amp; to.name !== &apos;login&apos;) {
        router.push({ name: &apos;login&apos; }); // 跳转login
      }
    });
复制代码
</code></pre><p>额，通过router.beforeEach 也完全可以实现且更好，我就骚一下。</p>
<h3 id="完整的路由导航解析流程-不包括其他生命周期-："><a href="#完整的路由导航解析流程-不包括其他生命周期-：" class="headerlink" title="完整的路由导航解析流程(不包括其他生命周期)："></a>完整的路由导航解析流程(不包括其他生命周期)：</h3><ol>
<li>触发进入其他路由。</li>
<li>调用要离开路由的组件守卫<code>beforeRouteLeave</code></li>
<li>调用局前置守卫：<code>beforeEach</code></li>
<li>在重用的组件里调用 <code>beforeRouteUpdate</code></li>
<li>调用路由独享守卫 <code>beforeEnter</code>。</li>
<li>解析异步路由组件。</li>
<li>在将要进入的路由组件中调用<code>beforeRouteEnter</code></li>
<li>调用全局解析守卫 <code>beforeResolve</code></li>
<li>导航被确认。</li>
<li>调用全局后置钩子的 <code>afterEach</code> 钩子。</li>
<li>触发DOM更新(<code>mounted</code>)。</li>
<li>执行<code>beforeRouteEnter</code> 守卫中传给 next 的回调函数</li>
</ol>
<hr>
<h2 id="你不知道的keep-alive-我猜你不知道"><a href="#你不知道的keep-alive-我猜你不知道" class="headerlink" title="你不知道的keep-alive[我猜你不知道]"></a>你不知道的keep-alive[我猜你不知道]</h2><p>在开发Vue项目的时候，大部分组件是没必要多次渲染的，所以Vue提供了一个内置组件<code>keep-alive</code>来<strong>缓存组件内部状态，避免重新渲染</strong>，<a href="https://link.juejin.cn?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fapi%2F%23keep-alive" title="https://cn.vuejs.org/v2/api/#keep-alive" target="_blank" rel="noopener">文档在这里</a>。</p>
<blockquote>
<p>文档：和 <code>&lt;transition&gt;</code>相似，<code>&lt;keep-alive&gt;</code> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。</p>
</blockquote>
<h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><p><strong>缓存动态组件：</strong></p>
<p><code>&lt;keep-alive&gt;</code>包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们，此种方式并无太大的实用意义。</p>
<pre><code>    &lt;!-- 基本 --&gt;
    &lt;keep-alive&gt;
      &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
    &lt;/keep-alive&gt;

    &lt;!-- 多个条件判断的子组件 --&gt;
    &lt;keep-alive&gt;
      &lt;comp-a v-if=&quot;a &gt; 1&quot;&gt;&lt;/comp-a&gt;
      &lt;comp-b v-else&gt;&lt;/comp-b&gt;
    &lt;/keep-alive&gt;
复制代码
</code></pre><p><strong>缓存路由组件：</strong></p>
<p>使用<code>keep-alive</code>可以将所有路径匹配到的路由组件都缓存起来，包括路由组件里面的组件，<code>keep-alive</code>大多数使用场景就是这种。</p>
<pre><code>    &lt;keep-alive&gt;
        &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/keep-alive&gt;
复制代码
</code></pre><h3 id="生命周期钩子："><a href="#生命周期钩子：" class="headerlink" title="生命周期钩子："></a>生命周期钩子：</h3><p>这篇既然是Vue钩子函数的专场，那肯定要扣题呀~</p>
<p>在被<code>keep-alive</code>包含的组件/路由中，会多出两个生命周期的钩子:<code>activated</code> 与 <code>deactivated</code>。</p>
<blockquote>
<p>文档：在 2.2.0 及其更高版本中，activated 和 deactivated 将会在 树内的<strong>所有嵌套组件</strong>中触发。</p>
</blockquote>
<p><strong>activated在组件第一次渲染时会被调用，之后在每次缓存组件被激活时调用</strong>。</p>
<p><strong>activated调用时机：</strong></p>
<p>第一次进入缓存路由/组件，在<code>mounted</code>后面，<code>beforeRouteEnter</code>守卫传给 next 的回调函数之前调用：</p>
<pre><code>    beforeMount=&gt; 如果你是从别的路由/组件进来(组件销毁destroyed/或离开缓存deactivated)=&gt;
    mounted=&gt; activated 进入缓存组件 =&gt; 执行 beforeRouteEnter回调
复制代码
</code></pre><p>因为组件被缓存了，<strong>再次进入缓存路由/组件时，不会触发这些钩子</strong>：</p>
<pre><code>    // beforeCreate created beforeMount mounted 都不会触发。
复制代码
</code></pre><p>所以之后的调用时机是：</p>
<pre><code>    组件销毁destroyed/或离开缓存deactivated =&gt; activated 进入当前缓存组件 
    =&gt; 执行 beforeRouteEnter回调
    // 组件缓存或销毁，嵌套组件的销毁和缓存也在这里触发
复制代码
</code></pre><p><strong>deactivated：组件被停用(离开路由)时调用</strong></p>
<p><strong>使用了<code>keep-alive</code>就不会调用<code>beforeDestroy</code>(组件销毁前钩子)和<code>destroyed</code>(组件销毁)，因为组件没被销毁，被缓存起来了</strong>。</p>
<p>这个钩子可以看作<code>beforeDestroy</code>的替代，如果你缓存了组件，要在组件销毁的的时候做一些事情，你可以放在这个钩子里。</p>
<p>如果你离开了路由，会依次触发：</p>
<pre><code>    组件内的离开当前路由钩子beforeRouteLeave =&gt;  路由前置守卫 beforeEach =&gt;
    全局后置钩子afterEach =&gt; deactivated 离开缓存组件 =&gt; activated 进入缓存组件(如果你进入的也是缓存路由)
    // 如果离开的组件没有缓存的话 beforeDestroy会替换deactivated 
    // 如果进入的路由也没有缓存的话  全局后置钩子afterEach=&gt;销毁 destroyed=&gt; beforeCreate等
复制代码
</code></pre><p>那么，如果我只是想缓存其中几个路由/组件，那该怎么做？</p>
<h3 id="缓存你想缓存的路由："><a href="#缓存你想缓存的路由：" class="headerlink" title="缓存你想缓存的路由："></a>缓存你想缓存的路由：</h3><h4 id="Vue2-1-0之前"><a href="#Vue2-1-0之前" class="headerlink" title="Vue2.1.0之前:"></a>Vue2.1.0之前:</h4><p>想实现类似的操作，你可以：</p>
<ol>
<li><p>配置一下路由元信息</p>
</li>
<li><p>创建两个<code>keep-alive</code>标签</p>
</li>
<li><p>使用<code>v-if</code>通过路由元信息判断缓存哪些路由。</p>
<pre><code> &lt;keep-alive&gt;
     &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;
         &lt;!--这里是会被缓存的路由--&gt;
     &lt;/router-view&gt;
 &lt;/keep-alive&gt;
 &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;
     &lt;!--因为用的是v-if 所以下面还要创建一个未缓存的路由视图出口--&gt;
 &lt;/router-view&gt;
 //router配置
 new Router({
   routes: [
     {
       path: &apos;/&apos;,
       name: &apos;home&apos;,
       component: Home,
       meta: {
         keepAlive: true // 需要被缓存
       }
     },
     {
       path: &apos;/:id&apos;,
       name: &apos;edit&apos;,
       component: Edit,
       meta: {
         keepAlive: false // 不需要被缓存
       }
     }
   ]
 });
复制代码
</code></pre></li>
</ol>
<h4 id="Vue2-1-0版本之后："><a href="#Vue2-1-0版本之后：" class="headerlink" title="Vue2.1.0版本之后："></a>Vue2.1.0版本之后：</h4><p>使用路由元信息的方式，要多创建一个<code>router-view</code>标签，并且每个路由都要配置一个元信息，是可以实现我们想要的效果，但是过于繁琐了点。</p>
<p>幸运的是在Vue2.1.0之后，Vue新增了两个属性配合<code>keep-alive</code>来有条件地缓存 路由/组件。</p>
<p><strong>新增属性：</strong></p>
<ul>
<li><code>include</code>：匹配的 路由/组件 会被缓存</li>
<li><code>exclude</code>：匹配的 路由/组件 不会被缓存</li>
</ul>
<p><code>include</code>和<code>exclude</code>支持三种方式来有条件的缓存路由：采用逗号分隔的字符串形式，正则形式，数组形式。</p>
<p>正则和数组形式，必须采用<code>v-bind</code>形式来使用。</p>
<p><strong>缓存组件的使用方式</strong>：</p>
<pre><code>    &lt;!-- 逗号分隔字符串 --&gt;
    &lt;keep-alive include=&quot;a,b&quot;&gt;
      &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
    &lt;/keep-alive&gt;

    &lt;!-- 正则表达式 (使用 `v-bind`) --&gt;
    &lt;keep-alive :include=&quot;/a|b/&quot;&gt;
      &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
    &lt;/keep-alive&gt;

    &lt;!-- 数组 (使用 `v-bind`) --&gt;
    &lt;keep-alive :include=&quot;[&apos;a&apos;, &apos;b&apos;]&quot;&gt;
      &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;
    &lt;/keep-alive&gt;
复制代码
</code></pre><p><strong>但更多场景中，我们会使用<code>keep-alive</code>来缓存路由</strong>：</p>
<pre><code>&lt;keep-alive include=&apos;a&apos;&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;
复制代码
</code></pre><p><strong>匹配规则：</strong></p>
<ol>
<li><strong>首先匹配组件的name选项</strong>，如果<code>name</code>选项不可用。</li>
<li>则匹配它的<strong>局部注册名称</strong>。 (父组件 <code>components</code> 选项的键值)</li>
<li><strong>匿名组件，不可匹配</strong>。</li>
</ol>
<p>比如路由组件没有<code>name</code>选项，并且没有注册的组件名。</p>
<ol start="4">
<li>只能匹配当前被包裹的组件，<strong>不能匹配更下面嵌套的子组件</strong>。</li>
</ol>
<p>比如用在路由上，只能匹配路由组件的<code>name</code>选项，不能匹配路由组件里面的嵌套组件的<code>name</code>选项。</p>
<ol start="5">
<li>文档：<code>&lt;keep-alive&gt;</code><strong>不会在函数式组件中正常工作</strong>，因为它们没有缓存实例。</li>
<li><strong><code>exclude</code>的优先级大于<code>include</code></strong></li>
</ol>
<p>也就是说：当<code>include</code>和<code>exclude</code>同时存在时，<code>exclude</code>生效，<code>include</code>不生效。</p>
<pre><code>  &lt;keep-alive include=&quot;a,b&quot; exclude=&quot;a&quot;&gt;
    &lt;!--只有a不被缓存--&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/keep-alive&gt;
复制代码
</code></pre><p><strong>当组件被<code>exclude</code>匹配，该组件将不会被缓存，不会调用<code>activated</code> 和 <code>deactivated</code></strong>。</p>
<hr>
<h2 id="组件生命周期钩子："><a href="#组件生命周期钩子：" class="headerlink" title="组件生命周期钩子："></a>组件生命周期钩子：</h2><p>关于组件的生命周期，是时候放出这张图片了：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/21/164bbf610b61f3cd~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt></p>
<p>这张图片已经讲得很清楚了，很多人这部分也很清楚了，大部分生命周期并不会用到，这里提一下几点：</p>
<ol>
<li><p><strong>ajax请求最好放在<code>created</code>里面</strong>，因为此时已经可以访问<code>this</code>了，请求到数据就可以直接放在<code>data</code>里面。</p>
<p>这里也碰到过几次，面试官问：ajax请求应该放在哪个生命周期。</p>
</li>
<li><p><strong>关于dom的操作要放在<code>mounted</code>里面</strong>，在<code>mounted</code>前面访问dom会是<code>undefined</code>。</p>
</li>
<li><p>每次进入/离开组件都要做一些事情，用什么钩子：</p>
</li>
</ol>
<ul>
<li><p>不缓存：</p>
<p>进入的时候可以用<code>created</code>和<code>mounted</code>钩子，离开的时候用<code>beforeDestory</code>和<code>destroyed</code>钩子,<code>beforeDestory</code>可以访问<code>this</code>，<code>destroyed</code>不可以访问<code>this</code>。</p>
</li>
<li><p>缓存了组件：</p>
<p>缓存了组件之后，再次进入组件不会触发<code>beforeCreate</code>、<code>created</code> 、<code>beforeMount</code>、 <code>mounted</code>，<strong>如果你想每次进入组件都做一些事情的话，你可以放在<code>activated</code>进入缓存组件的钩子中</strong>。</p>
<p>同理：离开缓存组件的时候，<code>beforeDestroy</code>和<code>destroyed</code>并不会触发，可以使用<code>deactivated</code>离开缓存组件的钩子来代替。</p>
</li>
</ul>
<hr>
<h2 id="触发钩子的完整顺序："><a href="#触发钩子的完整顺序：" class="headerlink" title="触发钩子的完整顺序："></a>触发钩子的完整顺序：</h2><p>将路由导航、<code>keep-alive</code>、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件：</p>
<ol>
<li><code>beforeRouteLeave</code>:路由组件的组件离开路由前钩子，可取消路由离开。</li>
<li><code>beforeEach</code>: 路由全局前置守卫，可用于登录验证、全局路由loading等。</li>
<li><code>beforeEnter</code>: 路由独享守卫</li>
<li><code>beforeRouteEnter</code>: 路由组件的组件进入路由前钩子。</li>
<li><code>beforeResolve</code>:<a href="https://link.juejin.cn?target=https%3A%2F%2Frouter.vuejs.org%2Fzh%2Fguide%2Fadvanced%2Fnavigation-guards.html%23%25E5%2585%25A8%25E5%25B1%2580%25E8%25A7%25A3%25E6%259E%2590%25E5%25AE%2588%25E5%258D%25AB" title="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E8%A7%A3%E6%9E%90%E5%AE%88%E5%8D%AB" target="_blank" rel="noopener">路由全局解析守卫</a></li>
<li><code>afterEach</code>:路由全局后置钩子</li>
<li><code>beforeCreate</code>:组件生命周期，不能访问<code>this</code>。</li>
<li><code>created</code>:组件生命周期，可以访问<code>this</code>，不能访问dom。</li>
<li><code>beforeMount</code>:组件生命周期</li>
<li><code>deactivated</code>: 离开缓存组件a，或者触发a的<code>beforeDestroy</code>和<code>destroyed</code>组件销毁钩子。</li>
<li><code>mounted</code>:访问/操作dom。</li>
<li><code>activated</code>:进入缓存组件，进入a的嵌套子组件(如果有的话)。</li>
<li>执行beforeRouteEnter回调函数next。</li>
</ol>
<hr>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Vue提供了很多钩子，但很多钩子我们几乎不会用到，只有清楚这些钩子函数的触发顺序以及背后的一些限制等，这样我们才能够正确的使用这些钩子，希望看了本文的同学，能对这些钩子有更加清晰的认识，使用起来更加得心应手。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weifo.github.io/2022/05/03/设计模式简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weifo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="weifo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/05/03/设计模式简介/" itemprop="url">设计模式简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-05-03T14:56:03+08:00">
                2022-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Interview/" itemprop="url" rel="index">
                    <span itemprop="name">Interview</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>设计模式代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>
<p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。</p>
<h3 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h3><ul>
<li><strong>S – Single Responsibility Principle 单一职责原则</strong><ul>
<li>一个程序只做好一件事</li>
<li>如果功能过于复杂就拆分开，每个部分保持独立</li>
</ul>
</li>
<li><strong>O – OpenClosed Principle 开放/封闭原则</strong><ul>
<li>对扩展开放，对修改封闭</li>
<li>增加需求时，扩展新代码，而非修改已有代码</li>
</ul>
</li>
<li>L – Liskov Substitution Principle 里氏替换原则<ul>
<li>子类能覆盖父类</li>
<li>父类能出现的地方子类就能出现</li>
</ul>
</li>
<li>I – Interface Segregation Principle 接口隔离原则<ul>
<li>保持接口的单一独立</li>
<li>类似单一职责原则，这里更关注接口</li>
</ul>
</li>
<li>D – Dependency Inversion Principle 依赖倒转原则<ul>
<li>面向接口编程，依赖于抽象而不依赖于具体</li>
<li>使用方只关注接口而不关注具体类的实现</li>
</ul>
</li>
</ul>
<h5 id="SO体现较多，举个栗子：（比如Promise）"><a href="#SO体现较多，举个栗子：（比如Promise）" class="headerlink" title="SO体现较多，举个栗子：（比如Promise）"></a>SO体现较多，举个栗子：（比如Promise）</h5><ul>
<li>单一职责原则：每个then中的逻辑只做好一件事</li>
<li>开放封闭原则（对扩展开放，对修改封闭）：如果新增需求，扩展then</li>
</ul>
<h5 id="再举个栗子：-此例来源-守候-改善代码的各方面问题"><a href="#再举个栗子：-此例来源-守候-改善代码的各方面问题" class="headerlink" title="再举个栗子：(此例来源-守候-改善代码的各方面问题)"></a>再举个栗子：(此例来源-<a href="https://juejin.im/post/6844903597092651015#comment" title="https://juejin.im/post/6844903597092651015#comment" target="_blank" rel="noopener">守候-改善代码的各方面问题</a>)</h5><pre><code>//checkType(&apos;165226226326&apos;,&apos;mobile&apos;)
//result：false
let checkType=function(str, type) {
    switch (type) {
        case &apos;email&apos;:
            return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str)
        case &apos;mobile&apos;:
            return /^1[3|4|5|7|8][0-9]{9}$/.test(str);
        case &apos;tel&apos;:
            return /^(0\d{2,3}-\d{7,8})(-\d{1,4})?$/.test(str);
        default:
            return true;
    }
}

复制代码
</code></pre><p>有以下两个问题：</p>
<ul>
<li>如果想添加其他规则就得在函数里面增加 case 。添加一个规则就修改一次！这样违反了开放-封闭原则（对扩展开放，对修改关闭）。而且这样也会导致整个 API 变得臃肿，难维护。</li>
<li>比如A页面需要添加一个金额的校验，B页面需要一个日期的校验，但是金额的校验只在A页面需要，日期的校验只在B页面需要。如果一直添加 case 。就是导致A页面把只在B页面需要的校验规则也添加进去，造成不必要的开销。B页面也同理。</li>
</ul>
<p>建议的方式是给这个 API 增加一个扩展的接口:</p>
<pre><code>let checkType=(function(){
    let rules={
        email(str){
            return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str);
        },
        mobile(str){
            return /^1[3|4|5|7|8][0-9]{9}$/.test(str);
        }
    };
    //暴露接口
    return {
        //校验
        check(str, type){
            return rules[type]?rules[type](str):false;
        },
        //添加规则
        addRule(type,fn){
            rules[type]=fn;
        }
    }
})();

//调用方式
//使用mobile校验规则
console.log(checkType.check(&apos;188170239&apos;,&apos;mobile&apos;));
//添加金额校验规则
checkType.addRule(&apos;money&apos;,function (str) {
    return /^[0-9]+(.[0-9]{2})?$/.test(str)
});
//使用金额校验规则
console.log(checkType.check(&apos;18.36&apos;,&apos;money&apos;));

复制代码
</code></pre><p>此例更详细内容请查看-&gt; <a href="https://juejin.im/post/6844903597092651015#comment" title="https://juejin.im/post/6844903597092651015#comment" target="_blank" rel="noopener">守候i-重构-改善代码的各方面问题</a></p>
<h2 id="设计模式分类（23种设计模式）"><a href="#设计模式分类（23种设计模式）" class="headerlink" title="设计模式分类（23种设计模式）"></a>设计模式分类（23种设计模式）</h2><ul>
<li>创建型<ul>
<li>单例模式</li>
<li>原型模式</li>
<li>工厂模式</li>
<li>抽象工厂模式</li>
<li>建造者模式</li>
</ul>
</li>
<li>结构型<ul>
<li>适配器模式</li>
<li>装饰器模式</li>
<li>代理模式</li>
<li>外观模式</li>
<li>桥接模式</li>
<li>组合模式</li>
<li>享元模式</li>
</ul>
</li>
<li>行为型<ul>
<li>观察者模式</li>
<li>迭代器模式</li>
<li>策略模式</li>
<li>模板方法模式</li>
<li>职责链模式</li>
<li>命令模式</li>
<li>备忘录模式</li>
<li>状态模式</li>
<li>访问者模式</li>
<li>中介者模式</li>
<li>解释器模式</li>
</ul>
</li>
</ul>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。</p>
<pre><code>class Product {
    constructor(name) {
        this.name = name
    }
    init() {
        console.log(&apos;init&apos;)
    }
    fun() {
        console.log(&apos;fun&apos;)
    }
}

class Factory {
    create(name) {
        return new Product(name)
    }
}

// use
let factory = new Factory()
let p = factory.create(&apos;p1&apos;)
p.init()
p.fun()

复制代码
</code></pre><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul>
<li>如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择</li>
<li>将new操作简单封装，遇到new的时候就应该考虑是否用工厂模式；</li>
<li>需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性</li>
</ul>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>创建对象的过程可能很复杂，但我们只需要关心创建结果。</li>
<li>构造函数和创建者分离, 符合“开闭原则”</li>
<li>一个调用者想创建一个对象，只要知道其名称就可以了。</li>
<li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>添加新产品时，需要编写新的具体产品类,一定程度上增加了系统的复杂度</li>
<li>考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度</li>
</ul>
<h5 id="什么时候不用"><a href="#什么时候不用" class="headerlink" title="什么时候不用"></a>什么时候不用</h5><p>当被应用到错误的问题类型上时,这一模式会给应用程序引入大量不必要的复杂性.除非为创建对象提供一个接口是我们编写的库或者框架的一个设计上目标,否则我会建议使用明确的构造器,以避免不必要的开销。</p>
<p>由于对象的创建过程被高效的抽象在一个接口后面的事实,这也会给依赖于这个过程可能会有多复杂的单元测试带来问题。</p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><ul>
<li><p>曾经我们熟悉的JQuery的$()就是一个工厂函数，它根据传入参数的不同创建元素或者去寻找上下文中的元素，创建成相应的jQuery对象</p>
<p>class jQuery {</p>
<pre><code>constructor(selector) {
    super(selector)
}
add() {

}
</code></pre><p>  // 此处省略若干API<br>}</p>
<p>window.$ = function(selector) {</p>
<pre><code>return new jQuery(selector)
</code></pre><p>}</p>
</li>
</ul>
<pre><code>复制代码
</code></pre><ul>
<li>vue 的异步组件</li>
</ul>
<p>在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。例如：</p>
<pre><code>Vue.component(&apos;async-example&apos;, function (resolve, reject) {
  setTimeout(function () {
    // 向 `resolve` 回调传递组件定义
    resolve({
      template: &apos;&lt;div&gt;I am async!&lt;/div&gt;&apos;
    })
  }, 1000)
})

复制代码
</code></pre><hr>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>一个类只有一个实例，并提供一个访问它的全局访问点。</p>
<pre><code> class LoginForm {
    constructor() {
        this.state = &apos;hide&apos;
    }
    show() {
        if (this.state === &apos;show&apos;) {
            alert(&apos;已经显示&apos;)
            return
        }
        this.state = &apos;show&apos;
        console.log(&apos;登录框显示成功&apos;)
    }
    hide() {
        if (this.state === &apos;hide&apos;) {
            alert(&apos;已经隐藏&apos;)
            return
        }
        this.state = &apos;hide&apos;
        console.log(&apos;登录框隐藏成功&apos;)
    }
 }
 LoginForm.getInstance = (function () {
     let instance
     return function () {
        if (!instance) {
            instance = new LoginForm()
        }
        return instance
     }
 })()

let obj1 = LoginForm.getInstance()
obj1.show()

let obj2 = LoginForm.getInstance()
obj2.hide()

console.log(obj1 === obj2)
复制代码
</code></pre><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>划分命名空间，减少全局变量</li>
<li>增强模块性，把自己的代码组织在一个全局变量名下，放在单一位置，便于维护</li>
<li>且只会实例化一次。简化了代码的调试和维护</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>由于单例模式提供的是一种单点访问，所以它有可能导致模块间的强耦合 从而不利于单元测试。无法单独测试一个调用了来自单例的方法的类，而只能把它与那个单例作为一个单元一起测试。</li>
</ul>
<h4 id="场景例子"><a href="#场景例子" class="headerlink" title="场景例子"></a>场景例子</h4><ul>
<li>定义命名空间和实现分支型方法</li>
<li>登录框</li>
<li>vuex 和 redux中的store</li>
</ul>
<hr>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>将一个类的接口转化为另外一个接口，以满足用户需求，使类之间接口不兼容问题通过适配器得以解决。</p>
<pre><code>class Plug {
  getName() {
    return &apos;iphone充电头&apos;;
  }
}

class Target {
  constructor() {
    this.plug = new Plug();
  }
  getName() {
    return this.plug.getName() + &apos; 适配器Type-c充电头&apos;;
  }
}

let target = new Target();
target.getName(); // iphone充电头 适配器转Type-c充电头
复制代码
</code></pre><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul>
<li>可以让任何两个没有关联的类一起运行。</li>
<li>提高了类的复用。</li>
<li>适配对象，适配库，适配数据</li>
</ul>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>额外对象的创建，非直接调用，存在一定的开销（且不像代理模式在某些功能点上可实现性能优化)</li>
<li>如果没必要使用适配器模式的话，可以考虑重构，如果使用的话，尽量把文档完善</li>
</ul>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><ul>
<li>整合第三方SDK</li>
<li><p>封装旧接口</p>
<p>// 自己封装的ajax， 使用方式如下<br>ajax({</p>
<pre><code>url: &apos;/getData&apos;,
type: &apos;Post&apos;,
dataType: &apos;json&apos;,
data: {
    test: 111
}
</code></pre><p>}).done(function() {})<br>// 因为历史原因，代码中全都是：<br>// $.ajax({….})</p>
<p>// 做一层适配器<br>var $ = {</p>
<pre><code>ajax: function (options) {
    return ajax(options)
}
</code></pre><p>}<br>复制代码</p>
</li>
<li><p>vue的computed</p>
<p><template></template></p>
<pre><code>&lt;div id=&quot;example&quot;&gt;
    &lt;p&gt;Original message: &quot;{{ message }}&quot;&lt;/p&gt;  &lt;!-- Hello --&gt;
    &lt;p&gt;Computed reversed message: &quot;{{ reversedMessage }}&quot;&lt;/p&gt;  &lt;!-- olleH --&gt;
&lt;/div&gt;
</code></pre><p></p>
<script type="text/javascript">
    export default {
        name: 'demo',
        data() {
            return {
                message: 'Hello'
            }
        },
        computed: {
            reversedMessage: function() {
                return this.message.split('').reverse().join('')
            }
        }
    }
</script>

<p>复制代码</p>
</li>
</ul>
<h5 id="原有data-中的数据不满足当前的要求，通过计算属性的规则来适配成我们需要的格式，对原有数据并没有改变，只改变了原有数据的表现形式"><a href="#原有data-中的数据不满足当前的要求，通过计算属性的规则来适配成我们需要的格式，对原有数据并没有改变，只改变了原有数据的表现形式" class="headerlink" title="原有data 中的数据不满足当前的要求，通过计算属性的规则来适配成我们需要的格式，对原有数据并没有改变，只改变了原有数据的表现形式"></a>原有data 中的数据不满足当前的要求，通过计算属性的规则来适配成我们需要的格式，对原有数据并没有改变，只改变了原有数据的表现形式</h5><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p>适配器与代理模式相似</p>
<ul>
<li>适配器模式： 提供一个不同的接口（如不同版本的插头）</li>
<li>代理模式： 提供一模一样的接口</li>
</ul>
<hr>
<h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><ul>
<li>动态地给某个对象添加一些额外的职责，，是一种实现继承的替代方案</li>
<li><p>在不改变原对象的基础上，通过对其进行包装扩展，使原有对象可以满足用户的更复杂需求，而不会影响从这个类中派生的其他对象</p>
<p>class Cellphone {</p>
<pre><code>create() {
    console.log(&apos;生成一个手机&apos;)
}
</code></pre><p>}<br>class Decorator {</p>
<pre><code>constructor(cellphone) {
    this.cellphone = cellphone
}
create() {
    this.cellphone.create()
    this.createShell(cellphone)
}
createShell() {
    console.log(&apos;生成手机壳&apos;)
}
</code></pre><p>}<br>// 测试代码<br>let cellphone = new Cellphone()<br>cellphone.create()</p>
<p>console.log(‘————‘)<br>let dec = new Decorator(cellphone)<br>dec.create()<br>复制代码</p>
</li>
</ul>
<h4 id="场景例子-1"><a href="#场景例子-1" class="headerlink" title="场景例子"></a>场景例子</h4><ul>
<li>比如现在有4 种型号的自行车，我们为每种自行车都定义了一个单</li>
</ul>
<p>独的类。现在要给每种自行车都装上前灯、尾 灯和铃铛这3 种配件。如果使用继承的方式来给 每种自行车创建子类，则需要 4×3 = 12 个子类。 但是如果把前灯、尾灯、铃铛这些对象动态组 合到自行车上面，则只需要额外增加3 个类</p>
<ul>
<li>ES7 Decorator <a href="https://link.juejin.cn?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fdecorator" title="http://es6.ruanyifeng.com/#docs/decorator" target="_blank" rel="noopener">阮一峰</a></li>
<li>core-decorators</li>
</ul>
<h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul>
<li>装饰类和被装饰类都只关心自身的核心业务，实现了解耦。</li>
<li>方便动态的扩展功能，且提供了比继承更多的灵活性。</li>
</ul>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>多层装饰比较复杂。</li>
<li>常常会引入许多小对象，看起来比较相似，实际功能大相径庭，从而使得我们的应用程序架构变得复杂起来</li>
</ul>
<hr>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>是为一个对象提供一个代用品或占位符，以便控制对它的访问</p>
<blockquote>
<p>假设当A 在心情好的时候收到花，小明表白成功的几率有</p>
</blockquote>
<p>60%，而当A 在心情差的时候收到花，小明表白的成功率无限趋近于0。 小明跟A 刚刚认识两天，还无法辨别A 什么时候心情好。如果不合时宜地把花送给A，花 被直接扔掉的可能性很大，这束花可是小明吃了7 天泡面换来的。 但是A 的朋友B 却很了解A，所以小明只管把花交给B，B 会监听A 的心情变化，然后选 择A 心情好的时候把花转交给A，代码如下：</p>
<pre><code>let Flower = function() {}
let xiaoming = {
  sendFlower: function(target) {
    let flower = new Flower()
    target.receiveFlower(flower)
  }
}
let B = {
  receiveFlower: function(flower) {
    A.listenGoodMood(function() {
      A.receiveFlower(flower)
    })
  }
}
let A = {
  receiveFlower: function(flower) {
    console.log(&apos;收到花&apos;+ flower)
  },
  listenGoodMood: function(fn) {
    setTimeout(function() {
      fn()
    }, 1000)
  }
}
xiaoming.sendFlower(B)
复制代码
</code></pre><h4 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h4><ul>
<li><p>HTML元 素事件代理</p>
<p><ul id="ul"><br>  <li>1</li><br>  <li>2</li><br>  <li>3</li><br></ul><br><script><br>  let ul = document.querySelector(‘#ul’);<br>  ul.addEventListener(‘click’, event =&gt; {</p>
<pre><code>console.log(event.target);
</code></pre><p>  });<br></script><br>复制代码</p>
</li>
<li><p>ES6 的 proxy <a href="https://link.juejin.cn?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fproxy" title="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">阮一峰Proxy</a></p>
</li>
<li>jQuery.proxy()方法</li>
</ul>
<h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><ul>
<li>代理模式能将代理对象与被调用对象分离，降低了系统的耦合度。代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用</li>
<li>代理对象可以扩展目标对象的功能；通过修改代理对象就可以了，符合开闭原则；</li>
</ul>
<h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><p>处理请求速度可能有差别，非直接访问存在开销</p>
<h4 id="不同点-1"><a href="#不同点-1" class="headerlink" title="不同点"></a>不同点</h4><p>装饰者模式实现上和代理模式类似</p>
<ul>
<li>装饰者模式： 扩展功能，原有功能不变且可直接使用</li>
<li>代理模式： 显示原有功能，但是经过限制之后的</li>
</ul>
<hr>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>为子系统的一组接口提供一个一致的界面，定义了一个高层接口，这个接口使子系统更加容易使用</p>
<ol>
<li><p>兼容浏览器事件绑定</p>
<p>let addMyEvent = function (el, ev, fn) {</p>
<pre><code>if (el.addEventListener) {
    el.addEventListener(ev, fn, false)
} else if (el.attachEvent) {
    el.attachEvent(&apos;on&apos; + ev, fn)
} else {
    el[&apos;on&apos; + ev] = fn
}
</code></pre><p>};<br>复制代码</p>
</li>
<li><p>封装接口</p>
<p>let myEvent = {</p>
<pre><code>// ...
stop: e =&gt; {
    e.stopPropagation();
    e.preventDefault();
}
</code></pre><p>};<br>复制代码</p>
</li>
</ol>
<h4 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h4><ul>
<li>设计初期，应该要有意识地将不同的两个层分离，比如经典的三层结构，在数据访问层和业务逻辑层、业务逻辑层和表示层之间建立外观Facade</li>
<li>在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观Facade可以提供一个简单的接口，减少他们之间的依赖。</li>
<li>在维护一个遗留的大型系统时，可能这个系统已经很难维护了，这时候使用外观Facade也是非常合适的，为系系统开发一个外观Facade类，为设计粗糙和高度复杂的遗留代码提供比较清晰的接口，让新系统和Facade对象交互，Facade与遗留代码交互所有的复杂工作。</li>
</ul>
<p>参考： 大话设计模式</p>
<h4 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h4><ul>
<li>减少系统相互依赖。</li>
<li>提高灵活性。</li>
<li>提高了安全性</li>
</ul>
<h4 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</li>
</ul>
<hr>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使它们能够自动更新自己，当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。</p>
<ul>
<li>发布 &amp; 订阅</li>
<li><p>一对多</p>
<p>// 主题 保存状态，状态变化之后触发所有观察者对象<br>class Subject {<br>  constructor() {</p>
<pre><code>this.state = 0
this.observers = []
</code></pre><p>  }<br>  getState() {</p>
<pre><code>return this.state
</code></pre><p>  }<br>  setState(state) {</p>
<pre><code>this.state = state
this.notifyAllObservers()
</code></pre><p>  }<br>  notifyAllObservers() {</p>
<pre><code>this.observers.forEach(observer =&gt; {
  observer.update()
})
</code></pre><p>  }<br>  attach(observer) {</p>
<pre><code>this.observers.push(observer)
</code></pre><p>  }<br>}</p>
<p>// 观察者<br>class Observer {<br>  constructor(name, subject) {</p>
<pre><code>this.name = name
this.subject = subject
this.subject.attach(this)
</code></pre><p>  }<br>  update() {</p>
<pre><code>console.log(`${this.name} update, state: ${this.subject.getState()}`)
</code></pre><p>  }<br>}</p>
<p>// 测试<br>let s = new Subject()<br>let o1 = new Observer(‘o1’, s)<br>let o2 = new Observer(‘02’, s)</p>
<p>s.setState(12)<br>复制代码</p>
</li>
</ul>
<h4 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h4><ul>
<li><p>DOM事件</p>
<p>document.body.addEventListener(‘click’, function() {</p>
<pre><code>console.log(&apos;hello world!&apos;);
</code></pre><p>});<br>document.body.click()<br>复制代码</p>
</li>
<li><p>vue 响应式</p>
</li>
</ul>
<h4 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h4><ul>
<li>支持简单的广播通信，自动通知所有已经订阅过的对象</li>
<li>目标对象与观察者之间的抽象耦合关系能单独扩展以及重用</li>
<li>增加了灵活性</li>
<li>观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。</li>
</ul>
<h4 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h4><p>过度使用会导致对象与对象之间的联系弱化，会导致程序难以跟踪维护和理解</p>
<hr>
<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>允许一个对象在其内部状态改变的时候改变它的行为，对象看起来似乎修改了它的类</p>
<pre><code>// 状态 （弱光、强光、关灯）
class State {
    constructor(state) {
        this.state = state
    }
    handle(context) {
        console.log(`this is ${this.state} light`)
        context.setState(this)
    }
}
class Context {
    constructor() {
        this.state = null
    }
    getState() {
        return this.state
    }
    setState(state) {
        this.state = state
    }
}
// test 
let context = new Context()
let weak = new State(&apos;weak&apos;)
let strong = new State(&apos;strong&apos;)
let off = new State(&apos;off&apos;)

// 弱光
weak.handle(context)
console.log(context.getState())

// 强光
strong.handle(context)
console.log(context.getState())

// 关闭
off.handle(context)
console.log(context.getState())
复制代码
</code></pre><h4 id="场景-4"><a href="#场景-4" class="headerlink" title="场景"></a>场景</h4><ul>
<li>一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为</li>
<li>一个操作中含有大量的分支语句，而且这些分支语句依赖于该对象的状态</li>
</ul>
<h4 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h4><ul>
<li>定义了状态与行为之间的关系，封装在一个类里，更直观清晰，增改方便</li>
<li>状态与状态间，行为与行为间彼此独立互不干扰</li>
<li>用对象代替字符串来记录当前状态，使得状态的切换更加一目了然</li>
</ul>
<h4 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>会在系统中定义许多状态类</li>
<li>逻辑分散</li>
</ul>
<hr>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p>
<pre><code>class Iterator {
    constructor(conatiner) {
        this.list = conatiner.list
        this.index = 0
    }
    next() {
        if (this.hasNext()) {
            return this.list[this.index++]
        }
        return null
    }
    hasNext() {
        if (this.index &gt;= this.list.length) {
            return false
        }
        return true
    }
}

class Container {
    constructor(list) {
        this.list = list
    }
    getIterator() {
        return new Iterator(this)
    }
}

// 测试代码
let container = new Container([1, 2, 3, 4, 5])
let iterator = container.getIterator()
while(iterator.hasNext()) {
  console.log(iterator.next())
}
复制代码
</code></pre><h4 id="场景例子-2"><a href="#场景例子-2" class="headerlink" title="场景例子"></a>场景例子</h4><ul>
<li>Array.prototype.forEach</li>
<li>jQuery中的$.each()</li>
<li>ES6 Iterator</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>访问一个聚合对象的内容而无需暴露它的内部表示。</li>
<li>为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对于集合内部结果常常变化各异，不想暴露其内部结构的话，但又想让客户代码透明的访问其中的元素，可以使用迭代器模式</p>
<hr>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
<pre><code>class Color {
    constructor(name){
        this.name = name
    }
}
class Shape {
    constructor(name,color){
        this.name = name
        this.color = color 
    }
    draw(){
        console.log(`${this.color.name} ${this.name}`)
    }
}

//测试
let red = new Color(&apos;red&apos;)
let yellow = new Color(&apos;yellow&apos;)
let circle = new Shape(&apos;circle&apos;, red)
circle.draw()
let triangle = new Shape(&apos;triangle&apos;, yellow)
triangle.draw()

复制代码
</code></pre><h4 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h4><ul>
<li>有助于独立地管理各组成部分， 把抽象化与实现化解耦</li>
<li>提高可扩充性</li>
</ul>
<h4 id="缺点-8"><a href="#缺点-8" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>大量的类将导致开发成本的增加，同时在性能方面可能也会有所减少。</li>
</ul>
<hr>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><ul>
<li>将对象组合成树形结构，以表示“整体-部分”的层次结构。</li>
<li><p>通过对象的多态表现，使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>class TrainOrder {</p>
<pre><code>create () {
    console.log(&apos;创建火车票订单&apos;)
}
</code></pre><p>}<br>class HotelOrder {</p>
<pre><code>create () {
    console.log(&apos;创建酒店订单&apos;)
}
</code></pre><p>}</p>
<p>class TotalOrder {</p>
<pre><code>constructor () {
    this.orderList = []
}
addOrder (order) {
    this.orderList.push(order)
    return this
}
create () {
    this.orderList.forEach(item =&gt; {
        item.create()
    })
    return this
}
</code></pre><p>}<br>// 可以在购票网站买车票同时也订房间<br>let train = new TrainOrder()<br>let hotel = new HotelOrder()<br>let total = new TotalOrder()<br>total.addOrder(train).addOrder(hotel).create()<br>复制代码</p>
</li>
</ul>
<h4 id="场景-5"><a href="#场景-5" class="headerlink" title="场景"></a>场景</h4><ul>
<li>表示对象-整体层次结构</li>
<li>希望用户忽略组合对象和单个对象的不同，用户将统一地使用组合结构中的所有对象（方法）</li>
</ul>
<h4 id="缺点-9"><a href="#缺点-9" class="headerlink" title="缺点"></a>缺点</h4><p>如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起。</p>
<hr>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>原型模式（prototype）是指用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<pre><code>class Person {
  constructor(name) {
    this.name = name
  }
  getName() {
    return this.name
  }
}
class Student extends Person {
  constructor(name) {
    super(name)
  }
  sayHello() {
    console.log(`Hello， My name is ${this.name}`)
  }
}

let student = new Student(&quot;xiaoming&quot;)
student.sayHello()
复制代码
</code></pre><p>原型模式，就是创建一个共享的原型，通过拷贝这个原型来创建新的类，用于创建重复的对象，带来性能上的提升。</p>
<hr>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换</p>
<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;策略模式-校验表单&lt;/title&gt;
    &lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form id = &quot;registerForm&quot; method=&quot;post&quot; action=&quot;http://xxxx.com/api/register&quot;&gt;
        用户名：&lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt;
        密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;
        手机号码：&lt;input type=&quot;text&quot; name=&quot;phoneNumber&quot;&gt;
        &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;
    &lt;/form&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        // 策略对象
        const strategies = {
          isNoEmpty: function (value, errorMsg) {
            if (value === &apos;&apos;) {
              return errorMsg;
            }
          },
          isNoSpace: function (value, errorMsg) {
            if (value.trim() === &apos;&apos;) {
              return errorMsg;
            }
          },
          minLength: function (value, length, errorMsg) {
            if (value.trim().length &lt; length) {
              return errorMsg;
            }
          },
          maxLength: function (value, length, errorMsg) {
            if (value.length &gt; length) {
              return errorMsg;
            }
          },
          isMobile: function (value, errorMsg) {
            if (!/^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|17[7]|18[0|1|2|3|5|6|7|8|9])\d{8}$/.test(value)) {
              return errorMsg;
            }                
          }
        }

        // 验证类
        class Validator {
          constructor() {
            this.cache = []
          }
          add(dom, rules) {
            for(let i = 0, rule; rule = rules[i++];) {
              let strategyAry = rule.strategy.split(&apos;:&apos;)
              let errorMsg = rule.errorMsg
              this.cache.push(() =&gt; {
                let strategy = strategyAry.shift()
                strategyAry.unshift(dom.value)
                strategyAry.push(errorMsg)
                return strategies[strategy].apply(dom, strategyAry)
              })
            }
          }
          start() {
            for(let i = 0, validatorFunc; validatorFunc = this.cache[i++];) {
              let errorMsg = validatorFunc()
              if (errorMsg) {
                return errorMsg
              }
            }
          }
        }

        // 调用代码
        let registerForm = document.getElementById(&apos;registerForm&apos;)

        let validataFunc = function() {
          let validator = new Validator()
          validator.add(registerForm.userName, [{
            strategy: &apos;isNoEmpty&apos;,
            errorMsg: &apos;用户名不可为空&apos;
          }, {
            strategy: &apos;isNoSpace&apos;,
            errorMsg: &apos;不允许以空白字符命名&apos;
          }, {
            strategy: &apos;minLength:2&apos;,
            errorMsg: &apos;用户名长度不能小于2位&apos;
          }])
          validator.add(registerForm.password, [ {
            strategy: &apos;minLength:6&apos;,
            errorMsg: &apos;密码长度不能小于6位&apos;
          }])
          validator.add(registerForm.phoneNumber, [{
            strategy: &apos;isMobile&apos;,
            errorMsg: &apos;请输入正确的手机号码格式&apos;
          }])
          return validator.start()
        }

        registerForm.onsubmit = function() {
          let errorMsg = validataFunc()
          if (errorMsg) {
            alert(errorMsg)
            return false
          }
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
复制代码
</code></pre><h4 id="场景例子-3"><a href="#场景例子-3" class="headerlink" title="场景例子"></a>场景例子</h4><ul>
<li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的’行为’，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li>
<li>一个系统需要动态地在几种算法中选择一种。</li>
<li>表单验证</li>
</ul>
<h4 id="优点-9"><a href="#优点-9" class="headerlink" title="优点"></a>优点</h4><ul>
<li>利用组合、委托、多态等技术和思想，可以有效的避免多重条件选择语句</li>
<li>提供了对开放-封闭原则的完美支持，将算法封装在独立的strategy中，使得它们易于切换，理解，易于扩展</li>
<li>利用组合和委托来让Context拥有执行算法的能力，这也是继承的一种更轻便的代替方案</li>
</ul>
<h4 id="缺点-10"><a href="#缺点-10" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>会在程序中增加许多策略类或者策略对象</li>
<li>要使用策略模式，必须了解所有的strategy，必须了解各个strategy之间的不同点，这样才能选择一个合适的strategy</li>
</ul>
<hr>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式</p>
<pre><code>let examCarNum = 0         // 驾考车总数
/* 驾考车对象 */
class ExamCar {
    constructor(carType) {
        examCarNum++
        this.carId = examCarNum
        this.carType = carType ? &apos;手动档&apos; : &apos;自动档&apos;
        this.usingState = false    // 是否正在使用
    }

    /* 在本车上考试 */
    examine(candidateId) {
        return new Promise((resolve =&gt; {
            this.usingState = true
            console.log(`考生- ${ candidateId } 开始在${ this.carType }驾考车- ${ this.carId } 上考试`)
            setTimeout(() =&gt; {
                this.usingState = false
                console.log(`%c考生- ${ candidateId } 在${ this.carType }驾考车- ${ this.carId } 上考试完毕`, &apos;color:#f40&apos;)
                resolve()                       // 0~2秒后考试完毕
            }, Math.random() * 2000)
        }))
    }
}

/* 手动档汽车对象池 */
ManualExamCarPool = {
    _pool: [],                  // 驾考车对象池
    _candidateQueue: [],        // 考生队列

    /* 注册考生 ID 列表 */
    registCandidates(candidateList) {
        candidateList.forEach(candidateId =&gt; this.registCandidate(candidateId))
    },

    /* 注册手动档考生 */
    registCandidate(candidateId) {
        const examCar = this.getManualExamCar()    // 找一个未被占用的手动档驾考车
        if (examCar) {
            examCar.examine(candidateId)           // 开始考试，考完了让队列中的下一个考生开始考试
              .then(() =&gt; {
                  const nextCandidateId = this._candidateQueue.length &amp;&amp; this._candidateQueue.shift()
                  nextCandidateId &amp;&amp; this.registCandidate(nextCandidateId)
              })
        } else this._candidateQueue.push(candidateId)
    },

    /* 注册手动档车 */
    initManualExamCar(manualExamCarNum) {
        for (let i = 1; i &lt;= manualExamCarNum; i++) {
            this._pool.push(new ExamCar(true))
        }
    },

    /* 获取状态为未被占用的手动档车 */
    getManualExamCar() {
        return this._pool.find(car =&gt; !car.usingState)
    }
}

ManualExamCarPool.initManualExamCar(3)          // 一共有3个驾考车
ManualExamCarPool.registCandidates([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])  // 10个考生来考试
复制代码
</code></pre><h4 id="场景例子-4"><a href="#场景例子-4" class="headerlink" title="场景例子"></a>场景例子</h4><ul>
<li>文件上传需要创建多个文件实例的时候</li>
<li>如果一个应用程序使用了大量的对象，而这些大量的对象造成了很大的存储开销时就应该考虑使用享元模式</li>
</ul>
<h4 id="优点-10"><a href="#优点-10" class="headerlink" title="优点"></a>优点</h4><ul>
<li>大大减少对象的创建，降低系统的内存，使效率提高。</li>
</ul>
<h4 id="缺点-11"><a href="#缺点-11" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，</li>
</ul>
<h2 id="不应该随着内部状态的变化而变化，否则会造成系统的混乱"><a href="#不应该随着内部状态的变化而变化，否则会造成系统的混乱" class="headerlink" title="不应该随着内部状态的变化而变化，否则会造成系统的混乱"></a>不应该随着内部状态的变化而变化，否则会造成系统的混乱</h2><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法和封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。</p>
<pre><code>class Beverage {
    constructor({brewDrink, addCondiment}) {
        this.brewDrink = brewDrink
        this.addCondiment = addCondiment
    }
    /* 烧开水，共用方法 */
    boilWater() { console.log(&apos;水已经煮沸=== 共用&apos;) }
    /* 倒杯子里，共用方法 */
    pourCup() { console.log(&apos;倒进杯子里===共用&apos;) }
    /* 模板方法 */
    init() {
        this.boilWater()
        this.brewDrink()
        this.pourCup()
        this.addCondiment()
    }
}
/* 咖啡 */
const coffee = new Beverage({
     /* 冲泡咖啡，覆盖抽象方法 */
     brewDrink: function() { console.log(&apos;冲泡咖啡&apos;) },
     /* 加调味品，覆盖抽象方法 */
     addCondiment: function() { console.log(&apos;加点奶和糖&apos;) }
})
coffee.init() 
复制代码
</code></pre><h4 id="场景例子-5"><a href="#场景例子-5" class="headerlink" title="场景例子"></a>场景例子</h4><ul>
<li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现</li>
<li>子类中公共的行为应被提取出来并集中到一个公共父类中的避免代码重复</li>
</ul>
<h4 id="优点-11"><a href="#优点-11" class="headerlink" title="优点"></a>优点</h4><ul>
<li>提取了公共代码部分，易于维护</li>
</ul>
<h4 id="缺点-12"><a href="#缺点-12" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>增加了系统复杂度，主要是增加了的抽象类和类间联系</li>
</ul>
<hr>
<h3 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h3><p>使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止</p>
<pre><code>// 请假审批，需要组长审批、经理审批、总监审批
class Action {
    constructor(name) {
        this.name = name
        this.nextAction = null
    }
    setNextAction(action) {
        this.nextAction = action
    }
    handle() {
        console.log( `${this.name} 审批`)
        if (this.nextAction != null) {
            this.nextAction.handle()
        }
    }
}

let a1 = new Action(&quot;组长&quot;)
let a2 = new Action(&quot;经理&quot;)
let a3 = new Action(&quot;总监&quot;)
a1.setNextAction(a2)
a2.setNextAction(a3)
a1.handle()
复制代码
</code></pre><h4 id="场景例子-6"><a href="#场景例子-6" class="headerlink" title="场景例子"></a>场景例子</h4><ul>
<li>JS 中的事件冒泡</li>
<li>作用域链</li>
<li>原型链</li>
</ul>
<h4 id="优点-12"><a href="#优点-12" class="headerlink" title="优点"></a>优点</h4><ul>
<li>降低耦合度。它将请求的发送者和接收者解耦。</li>
<li>简化了对象。使得对象不需要知道链的结构</li>
<li>增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任</li>
<li>增加新的请求处理类很方便。</li>
</ul>
<h4 id="缺点-13"><a href="#缺点-13" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>不能保证某个请求一定会被链中的节点处理，这种情况可以在链尾增加一个保底的接受者节点来处理这种即将离开链尾的请求。</li>
<li>使程序中多了很多节点对象，可能再一次请求的过程中，大部分的节点并没有起到实质性的作用。他们的作用仅仅是让请求传递下去，从性能当面考虑，要避免过长的职责链到来的性能损耗。</li>
</ul>
<hr>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。</p>
<pre><code>// 接收者类
class Receiver {
    execute() {
      console.log(&apos;接收者执行请求&apos;)
    }
  }

// 命令者
class Command {  
    constructor(receiver) {
        this.receiver = receiver
    }
    execute () {    
        console.log(&apos;命令&apos;);
        this.receiver.execute()
    }
}
// 触发者
class Invoker {   
    constructor(command) {
        this.command = command
    }
    invoke() {   
        console.log(&apos;开始&apos;)
        this.command.execute()
    }
}

// 仓库
const warehouse = new Receiver();   
// 订单    
const order = new Command(warehouse);  
// 客户
const client = new Invoker(order);      
client.invoke()
复制代码
</code></pre><h4 id="优点-13"><a href="#优点-13" class="headerlink" title="优点"></a>优点</h4><ul>
<li>对命令进行封装，使命令易于扩展和修改</li>
<li>命令发出者和接受者解耦，使发出者不需要知道命令的具体执行过程即可执行</li>
</ul>
<h4 id="缺点-14"><a href="#缺点-14" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>使用命令模式可能会导致某些系统有过多的具体命令类。</li>
</ul>
<hr>
<h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。</p>
<pre><code>//备忘类
class Memento{
    constructor(content){
        this.content = content
    }
    getContent(){
        return this.content
    }
}
// 备忘列表
class CareTaker {
    constructor(){
        this.list = []
    }
    add(memento){
        this.list.push(memento)
    }
    get(index){
        return this.list[index]
    }
}
// 编辑器
class Editor {
    constructor(){
        this.content = null
    }
    setContent(content){
        this.content = content
    }
    getContent(){
     return this.content
    }
    saveContentToMemento(){
        return new Memento(this.content)
    }
    getContentFromMemento(memento){
        this.content = memento.getContent()
    }
}

//测试代码

let editor = new Editor()
let careTaker = new CareTaker()

editor.setContent(&apos;111&apos;)
editor.setContent(&apos;222&apos;)
careTaker.add(editor.saveContentToMemento())
editor.setContent(&apos;333&apos;)
careTaker.add(editor.saveContentToMemento())
editor.setContent(&apos;444&apos;)

console.log(editor.getContent()) //444
editor.getContentFromMemento(careTaker.get(1))
console.log(editor.getContent()) //333

editor.getContentFromMemento(careTaker.get(0))
console.log(editor.getContent()) //222
复制代码
</code></pre><h4 id="场景例子-7"><a href="#场景例子-7" class="headerlink" title="场景例子"></a>场景例子</h4><ul>
<li>分页控件</li>
<li>撤销组件</li>
</ul>
<h4 id="优点-14"><a href="#优点-14" class="headerlink" title="优点"></a>优点</h4><ul>
<li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态</li>
</ul>
<h4 id="缺点-15"><a href="#缺点-15" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</li>
</ul>
<hr>
<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p>解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的 相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知 中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者 模式使网状的多对多关系变成了相对简单的一对多关系（类似于观察者模式，但是单向的，由中介者统一管理。）</p>
<pre><code>class A {
    constructor() {
        this.number = 0
    }
    setNumber(num, m) {
        this.number = num
        if (m) {
            m.setB()
        }
    }
}
class B {
    constructor() {
        this.number = 0
    }
    setNumber(num, m) {
        this.number = num
        if (m) {
            m.setA()
        }
    }
}
class Mediator {
    constructor(a, b) {
        this.a = a
        this.b = b
    }
    setA() {
        let number = this.b.number
        this.a.setNumber(number * 10)
    }
    setB() {
        let number = this.a.number
        this.b.setNumber(number / 10)
    }
}

let a = new A()
let b = new B()
let m = new Mediator(a, b)
a.setNumber(10, m)
console.log(a.number, b.number)
b.setNumber(10, m)
console.log(a.number, b.number)
复制代码
</code></pre><h4 id="场景例子-8"><a href="#场景例子-8" class="headerlink" title="场景例子"></a>场景例子</h4><ul>
<li>系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象</li>
<li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</li>
</ul>
<h4 id="优点-15"><a href="#优点-15" class="headerlink" title="优点"></a>优点</h4><ul>
<li>使各对象之间耦合松散，而且可以独立地改变它们之间的交互</li>
<li>中介者和对象一对多的关系取代了对象之间的网状多对多的关系</li>
<li>如果对象之间的复杂耦合度导致维护很困难，而且耦合度随项目变化增速很快，就需要中介者重构代码</li>
</ul>
<h4 id="缺点-16"><a href="#缺点-16" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>系统中会新增一个中介者对象，因 为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介 者对象自身往往就是一个难以维护的对象。</li>
</ul>
<hr>
<h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><p>给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。</p>
<p>此例来自<a href="https://link.juejin.cn?target=https%3A%2F%2Fxin-tan.com%2Fpassages%2F2019-01-25-interpreter-pattern%2F%23_3-%25E5%25A4%259A%25E8%25AF%25AD%25E8%25A8%2580%25E5%25AE%259E%25E7%258E%25B0" title="https://xin-tan.com/passages/2019-01-25-interpreter-pattern/#_3-%E5%A4%9A%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener">心谭博客</a></p>
<pre><code>class Context {
    constructor() {
      this._list = []; // 存放 终结符表达式
      this._sum = 0; // 存放 非终结符表达式(运算结果)
    }

    get sum() {
      return this._sum;
    }
    set sum(newValue) {
      this._sum = newValue;
    }
    add(expression) {
      this._list.push(expression);
    }
    get list() {
      return [...this._list];
    }
  }

  class PlusExpression {
    interpret(context) {
      if (!(context instanceof Context)) {
        throw new Error(&quot;TypeError&quot;);
      }
      context.sum = ++context.sum;
    }
  }
  class MinusExpression {
    interpret(context) {
      if (!(context instanceof Context)) {
        throw new Error(&quot;TypeError&quot;);
      }
      context.sum = --context.sum;
    }
  }

  /** 以下是测试代码 **/
  const context = new Context();

  // 依次添加: 加法 | 加法 | 减法 表达式
  context.add(new PlusExpression());
  context.add(new PlusExpression());
  context.add(new MinusExpression());

  // 依次执行: 加法 | 加法 | 减法 表达式
  context.list.forEach(expression =&gt; expression.interpret(context));
  console.log(context.sum);
复制代码
</code></pre><h4 id="优点-16"><a href="#优点-16" class="headerlink" title="优点"></a>优点</h4><ul>
<li>易于改变和扩展文法。</li>
<li>由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法</li>
</ul>
<h4 id="缺点-17"><a href="#缺点-17" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>执行效率较低，在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度慢</li>
<li>对于复杂的文法比较难维护</li>
</ul>
<hr>
<h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
<pre><code>// 访问者  
class Visitor {
    constructor() {}
    visitConcreteElement(ConcreteElement) {
        ConcreteElement.operation()
    }
}
// 元素类  
class ConcreteElement{
    constructor() {
    }
    operation() {
       console.log(&quot;ConcreteElement.operation invoked&quot;);  
    }
    accept(visitor) {
        visitor.visitConcreteElement(this)
    }
}
// client
let visitor = new Visitor()
let element = new ConcreteElement()
element.accept(visitor)
复制代码
</code></pre><h4 id="场景例子-9"><a href="#场景例子-9" class="headerlink" title="场景例子"></a>场景例子</h4><ul>
<li>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作</li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。</li>
</ul>
<h4 id="优点-17"><a href="#优点-17" class="headerlink" title="优点"></a>优点</h4><ul>
<li>符合单一职责原则</li>
<li>优秀的扩展性</li>
<li>灵活性</li>
</ul>
<h4 id="缺点-18"><a href="#缺点-18" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>具体元素对访问者公布细节，违反了迪米特原则</li>
<li>违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</li>
<li>具体元素变更比较困难</li>
</ul>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weifo.github.io/2022/03/03/react hooks1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weifo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="weifo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/03/03/react hooks1/" itemprop="url">React Hooks使用案例学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-03-03T09:58:42+08:00">
                2022-03-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="清除-effect"><a href="#清除-effect" class="headerlink" title="清除 effect"></a><strong>清除 effect</strong></h3><p>通常，组件卸载时需要清除 effect 创建的诸如订阅或计时器 ID 等资源。要实现这一点，useEffect 函数需返回一个清除函数。也就是说，要想在组件销毁的时候搞一些事情，需要useEffect 末尾返回一个函数，在这个函数里面可以写具体销毁的内容。</p>
<p>看下面的例子，在当前页面里面，页面的标题是’测试title’，当切换到其他页面时，页面的标题变成‘正式title’。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDocumentTitle</span>(<span class="params">title</span>) </span>&#123;</span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = title;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'销毁1————————————————'</span>);</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">'正式title'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;, [title]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">CheckboxDemo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">useDocumentTitle(<span class="string">'测试title'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="监听页面大小变化，网络是否断开"><a href="#监听页面大小变化，网络是否断开" class="headerlink" title="监听页面大小变化，网络是否断开"></a><strong>监听页面大小变化，网络是否断开</strong></h3><p>效果：在组件调用 useWindowSize 时，可以拿到页面大小，并且在浏览器缩放时自动触发组件更新。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    innerHeight: <span class="built_in">window</span>.innerHeight,</span><br><span class="line">    innerWidth: <span class="built_in">window</span>.innerWidth,</span><br><span class="line">    outerHeight: <span class="built_in">window</span>.outerHeight,</span><br><span class="line">    outerWidth: <span class="built_in">window</span>.outerWidth,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useWindowSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> [windowSize, setWindowSize] = useState(getSize());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setWindowSize(getSize());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, handleResize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'resize'</span>, handleResize);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="keyword">return</span> windowSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> windowSize = useWindowSize();</span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>页面宽度&#123;windowSize.innerWidth&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态注入-css"><a href="#动态注入-css" class="headerlink" title="动态注入 css"></a><strong>动态注入 css</strong></h2><p>效果：在页面注入一段 class，并且当组件销毁时，移除这个 class。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> className = useCss(&#123;</span><br><span class="line">color: <span class="string">"red"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span>&gt;</span>Text.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>实现：可以看到，Hooks 方便的地方是在组件销毁时移除副作用，所以我们可以安心的利用 Hooks 做一些副作用。注入 css 自然不必说了，而销毁 css 只要找到注入的那段引用进行销毁即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weifo.github.io/2020/02/10/react-redux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weifo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="weifo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/10/react-redux/" itemprop="url">react-redux</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-10T22:42:05+08:00">
                2020-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="rudux"><a href="#rudux" class="headerlink" title="rudux"></a>rudux</h2><p><code>redux</code> 运行流程图：<br><img src="https://user-gold-cdn.xitu.io/2018/9/12/165c9daf60abdbd6?w=638&amp;h=479&amp;f=jpeg&amp;s=21322" alt></p>
<p>简单概述：<strong>click</strong> -&gt; <strong>store.dispatch(action)</strong> -&gt; <strong>reduer</strong> -&gt; <strong>newState</strong> -&gt; <strong>viewUpdate</strong></p>
<p><strong>react-readux</strong> 中 通过 <strong>connect</strong> 链接组件和 <strong>redux</strong> , <strong>this.props.dispatch()</strong> 调用</p>
<p>后面将会讲到…</p>
<p><code>redux</code> 依赖包也是十分的简洁<br><img src="https://user-gold-cdn.xitu.io/2018/9/14/165d8c900fb1fcd4?w=280&amp;h=295&amp;f=png&amp;s=14746" alt><br>先来个<code>demo</code></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/02/10/react-redux/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weifo.github.io/2020/02/08/react-hooks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weifo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="weifo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/08/react-hooks/" itemprop="url">react - hooks(v16.7)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-08T15:30:32+08:00">
                2020-02-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文不做概念性的解析，旨在实操 <code>hooks</code>，相关资源可以自行谷歌。以下提供相关参考资料：</p>
<ul>
<li><a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">Introducing Hooks</a></li>
<li><a href="https://juejin.im/post/5be409696fb9a049b13db042" target="_blank" rel="noopener">理解 React Hooks</a></li>
<li><a href="https://juejin.im/post/5bffc271e51d454dca3547b1#heading-0" target="_blank" rel="noopener">React Hooks 实用指南</a> - 大都借鉴这篇文章</li>
<li><a href="https://juejin.im/post/5bd53d6a51882528382d8108" target="_blank" rel="noopener">Hooks 一览</a></li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/02/08/react-hooks/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weifo.github.io/2020/02/05/react-LifeCycle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weifo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="weifo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/05/react-LifeCycle/" itemprop="url">react - 生命周期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-05T21:20:13+08:00">
                2020-02-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="v16-3"><a href="#v16-3" class="headerlink" title="v16.3+"></a>v16.3+</h2><ul>
<li>Mounting<ul>
<li>constructor(props)</li>
<li>static getDerivedStateFromProps(props, state)</li>
<li>render()</li>
<li>componentDidMount()</li>
</ul>
</li>
<li>Updating<ul>
<li>static getDerivedStateFromProps()</li>
<li>shouldComponentUpdate(nextProps, nextState)</li>
<li>render()</li>
<li>getSnapshotBeforeUpdate(prevProps, prevState)</li>
<li>componentDidUpdate(prevProps, prevState, snapshot)</li>
</ul>
</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/02/05/react-LifeCycle/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weifo.github.io/2020/02/03/react-context/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weifo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="weifo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/03/react-context/" itemprop="url">react-context</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-03T09:58:42+08:00">
                2020-02-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p><code>Context</code> 设计目的是为共享那些被认为对于一个组件树而言是“全局”的数据，你可以看做为 <code>redux</code>，因为 <code>redux</code> 也是通过这个东东实现的。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 创建 context</span></span><br><span class="line"><span class="comment"> * 2. 根组件 App 包裹 MyContext.Provider</span></span><br><span class="line"><span class="comment"> * 3. App =&gt; Father =&gt; Child =&gt; MyContext.Consumer =&gt; context.age 取出结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> MyContext = React.createContext()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Child = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;MyContext.Consumer&gt;&#123;(&#123; age &#125;) =&gt; <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>My age is &#123;age&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;&lt;<span class="regexp">/MyContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const Father = () =&gt; &lt;Child /</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;MyContext.Provider value=&#123;&#123; <span class="attr">age</span>: <span class="number">22</span> &#125;&#125;&gt;</span><br><span class="line">        &lt;Father /&gt;</span><br><span class="line">      &lt;<span class="regexp">/MyContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App</span></span><br></pre></td></tr></table></figure>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/02/03/react-context/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weifo.github.io/2020/02/02/react-basic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weifo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="weifo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/02/react-basic/" itemprop="url">react 入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-02T23:03:29+08:00">
                2020-02-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react@16/umd/react.development.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react-dom@16/umd/react-dom.development.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 生产环境中不建议使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/babel-standalone@6.15.0/babel.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</span></span><br><span class="line">);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>react.min.js - React 的核心库</li>
<li>react-dom.min.js - 提供与 DOM 相关的功能</li>
<li>babel.min.js - Babel 可以将 ES6 代码转为 ES5 代码</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/02/02/react-basic/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weifo.github.io/2020/01/23/git-command/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weifo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="weifo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/23/git-command/" itemprop="url">git 实用指南</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-23T21:30:04+08:00">
                2020-01-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/开发工具/" itemprop="url" rel="index">
                    <span itemprop="name">开发工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="commit-规范速查"><a href="#commit-规范速查" class="headerlink" title="commit 规范速查"></a>commit 规范速查</h2><ul>
<li><code>feat</code>：新功能（feature）</li>
<li><code>fix</code>：修补 bug</li>
<li><code>docs</code>：文档（documentation）</li>
<li><code>style</code>： 格式（不影响代码运行的变动）</li>
<li><code>refactor</code>：重构（即不是新增功能，也不是修改 bug 的代码变动）</li>
<li><code>test</code>：增加测试</li>
<li><code>chore</code>：构建过程或辅助工具的变动</li>
<li><p><code>revert</code>: 撤销以前的 commit</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revert: feat(pencil): add <span class="string">'graphiteWidth'</span> option</span><br></pre></td></tr></table></figure>
</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/01/23/git-command/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weifo.github.io/2020/01/23/http-cache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="weifo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="weifo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/23/http-cache/" itemprop="url">HTTP - 缓存机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-23T09:23:23+08:00">
                2020-01-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTTP/" itemprop="url" rel="index">
                    <span itemprop="name">HTTP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="缓存实现的步骤"><a href="#缓存实现的步骤" class="headerlink" title="缓存实现的步骤"></a>缓存实现的步骤</h2><ul>
<li>首先是当用户请求资源时，会判断是否有缓存，如果没有，则会向原服务器请求资源。</li>
<li>如果有缓存，则会进入强缓存的范畴，判断缓存是否新鲜<ul>
<li>如果缓存新鲜，则会直接返回缓存副本给客户端。</li>
<li>如果缓存不新鲜了，则表示强缓存失败，将会进入到<strong>协商缓存</strong>。</li>
</ul>
</li>
<li>协商缓存将判断是否存在 <code>Etag</code> 和 <code>Last-Modified</code> 首部<ul>
<li>如果未发生变化，则表示命中了协商缓存，会重定向到缓存副本，将资源返回给客户端</li>
<li>否则的话表示协商缓存未命中，服务器会返回新的资源。</li>
</ul>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/4/166de9f3ae4b1f20?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><blockquote>
<p>服务端告知客户端缓存时间后，由客户端判断并决定是否使用缓存。</p>
</blockquote>
<p>强缓存是通过 <code>Expires</code> 首部或 <code>Cache-Control: max-age</code> 来实现的。</p>
<ul>
<li><code>Expires</code>: 响应头，代表该资源的过期时间。</li>
<li><code>Cache-Control</code>: 请求/响应头，缓存控制字段，精确控制缓存策略。</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/01/23/http-cache/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="weifo">
            
              <p class="site-author-name" itemprop="name">weifo</p>
              <p class="site-description motion-element" itemprop="description">行到水穷处，坐看云起时</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/weifo" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">weifo</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
