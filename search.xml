<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[五分钟了解(安装)typescript]]></title>
    <url>%2F2019%2F11%2F14%2Fts_basic%2F</url>
    <content type="text"><![CDATA[typescript的由来typescript是由微软的一个技术团队开发和维护的一个开源项目，之所以会推出这个项目是为了解决js的一个缺陷吧！由于Javascript是一种动态弱类型的语言，在测试和debug阶段会非常的痛苦，也是为了解决这一“痛点”，微软的VS code团队推出了typescript&ensp; (强弱/动态静态具体解释，click here!) 安装1npm install -g typescript 安装后即可通过 tsc -v 命令行来查看安装版本，如果提示tsc不是内部或外部命令的话，说明系统的环境变量没有配置，csdn上有相关的解决办法。 编译1tsc xxx.ts 编译后会在相同文件夹下生成同名的js文件，关于更加工程化地使用typescript可以参考官方文档 变量和函数声明与js语法相比，在所有的变量加上类型123456789101112131415let taylor:string='Taylor';let age:number=25;// 数组有两种定义方式let skills:string[]=['sing','gituar','writing'];let cats:Array&lt;string&gt;=['white','dog','miao'];// 函数声明function info(name:string,age:number):string&#123; let s:string=''; s=`He is $&#123;name&#125;,and he's $&#123;age&#125; years old`; return s;&#125;info('calvin harris',28) 接口和类123456789101112131415161718192021222324252627// 可选属性interface employee&#123; degree?:string, skilled?:boolean&#125;function test(config:employee):boolean&#123; if(config.skilled)&#123; return true &#125;else if(config.degree==='master')&#123; return true &#125;else&#123; return false &#125;&#125;let t1=test(&#123;degree:'master'&#125;)let t2=test(&#123;degree:'bachelor',skilled:'false'&#125;)let t3=test(&#123;skilled:'true'&#125;)console.log(t1,t2,t3)// 只读属性interface Point&#123; readonly x:number, readonly y:number&#125;let p1:Point=&#123;x:10,y:5&#125;p1.y=12// error]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包学不会的深拷贝与浅拷贝]]></title>
    <url>%2F2019%2F11%2F14%2Fdeepclone%2F</url>
    <content type="text"><![CDATA[深拷贝与浅拷贝的含义首先要知道在js的世界中，有两种类型的值，分别是基础类型和引用类型。基础类型包括string,number,boolean,Symbol,undefined,null,引用类型包括array,object等。 基本数据类型：直接存储在栈（stack）中的数据 引用数据类型：在栈中存放的是指针，真实的数据存放在堆中。 首先要分清拷贝和赋值的区别引用类型的赋值是直接赋值了一个指针，二者指向相同的数据内存。而拷贝是要创建一个新的对象/数组，如果只拷贝一层数据的话叫浅拷贝，如果拷贝多层数据叫深拷贝。 12345678910111213141516let obj=&#123; name:'Mike', age:36, hobby:['movies','music','running']&#125;// 这是赋值,任何一个都能操作共有的内存数据let obj1=obj;obj1.name='fred';obj1.hobby[1]='eat';console.log(obj,obj1)；// 这是浅拷贝,只能拷贝一层数据，当对象中有引用类型的value时，只会拷贝这个引用的指针let obj2=&#123;...obj&#125;;obj2.name='max';//不会改变源对象obj2.hobby[1]='sleep'; //会改变源对象console.log(obj,obj2) 如何实现浅拷贝数组的浅拷贝 slice方法 1234let arr=[1,5,9], arr1=arr.slice();arr1.push(11);console.log(arr,arr1) concat方法,当不给concat传参时，该方法和slice()作用相同 12let arr1=arr.concat();... spread操作符 123456let arr=[1,3,5,[8,9]];let arr1=[...arr];arr.push(15);console.log(arr,arr1);arr1[3].push(18);console.log(arr,arr1); 对象的浅拷贝 手动实现 12345678910function shallowCopy(src)&#123; var target=&#123;&#125;; for(let key in src)&#123; if(src.hasOwnProperty(key))&#123; target[key]=src[key]; &#125; &#125; return target&#125;// hasOwnProperty方法可以排除来自原型链上的属性 Object.assign() 1234let obj=&#123;a:&#123;name:'weifo',age:33&#125;&#125;;let copyobj=Object.assign(&#123;&#125;,obj);copyobj.a.name='curt';concole.log(obj.a.name);//curt spread 123let obj=&#123;name:'weifo',skill:['english','code']&#125;;let copyobj=&#123;...obj,name:'fred'&#125;;//&#123;name:'fred',skill:[...]&#125;//es6语法 深拷贝的实现 trick版 12345678910111213JSON.parse(JSON.stringify(obj))// 该方法的局限性：symbol，undefined，函数的属性值会被忽略，例子如下let syb=Symbol(12);let obj=&#123; name:'fred', say:function()&#123; alert('It wont alert'); &#125;, syb:syb， age:undefined&#125;let copy=JSON.parse(JSON.stringify(obj));console.log(copy);//&#123;name:'fred'&#125; 手动实现 12345678910111213141516171819function deepclone(src)&#123; if(typeof src==='object')&#123; let clone=Array.isArray(src)?[]:&#123;&#125;; for(let key in src)&#123; clone[key]=deepclone(src[key]); &#125; return clone &#125;else&#123; return src; &#125;&#125;let test=&#123; name:'fred', cities:['tokyo','paris','london']&#125;let clone=deepclone(test);clone.cities.push('rome');clone.name='weifo';console.log(test,clone) 解决循环引用上面的方法可以满足大部分的应用场景了，除了遇到对象引用自身的情况，如果采用上面的方法，会有爆栈的错误提示。 123456789const test=&#123; name:'weifo', field:[3,5,11], field1:&#123; child:'name' &#125;&#125;test.test=test;//循环引用deepclone(test)//RangeError 为了解决循环引用的问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝对象时，先去存储对象中找，找到的话直接返回，没有则继续拷贝。123456789101112131415function deepclone(target,map=new Map())&#123; if(typeof target==='object')&#123; let clone=Array.isArray(src)?[]:&#123;&#125;; if(map.get(target))&#123; return target &#125; map.set(target,clone); for(let key in target)&#123; clone[key]=clone(target[key],map); &#125; return clone &#125;else&#123; return target &#125;&#125; 使用lodash12345var _=require('lodash');var objects = [&#123; 'a': 1 &#125;, &#123; 'b': 2 &#125;]; var deep = _.cloneDeep(objects);console.log(deep[0] === objects[0]);//false]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总得走出第一步吧！]]></title>
    <url>%2F2019%2F11%2F11%2Ffirst%2F</url>
    <content type="text"><![CDATA[总得走出第一步吧！脑子里昏昏沉沉，但是又有数条思绪在横冲直撞，此刻的我，也不知道自己抓住了哪一条，开始反思自己失败的人生。 我，23岁，单身，无存款，无工作，无社交。有一个成名在望的哥哥，他曾经断言我在毕业后会失业，他说对了，我从7月耍到了11月，从情人节到了光棍节，肆意地挥霍自己最宝贵的财富，当然不是钱，是自己的时间。人生重要的路就几步，青春尤其重要，道理都懂，但还是走入了人生的深坑。 从来不是一个理性的人明明知道自己是拖延症晚期患者，却没有没有能力去改变事实，这种病对自己来说无药可救。高中班主任试着让我们学会列计划，我在这块做得很烂，总是管理不好自己的时间，高中是做不完的作业，大学是看不完的手机。 手机控，即使在手机里面装了forest，卸了网易云和bilibili，却发现web端的应用其实更好用，每天在B站刷纪录片和美剧片段，大脑也开始适应盯着屏幕看视频的生活，因为每次开始学习，大脑就会喊累，看个算法就能让自己头晕眼花。 自己真的喜欢编程吗？我确实学了很长时间的编程了，从前端到后端，从JS到python，但就是没有拿得出手的作品，用行话说，是项目吧！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>梦想</tag>
      </tags>
  </entry>
</search>
